<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Smashters">
    <meta name="theme-color" content="#00432e">
    <link rel="apple-touch-icon" href="assets/images/apple-touch-icon.png">
    <link rel="manifest" href="manifest.json">
    <title>The Smashters - Dumpster Fire Golf Club</title>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <!-- PDF/Image Export Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        /* ═══════════════════════════════════════════════════════
           FONTS
           ═══════════════════════════════════════════════════════ */
        @font-face {
            font-family: 'Azalea';
            src: url('assets/fonts/Azalea.otf') format('opentype'),
                 url('assets/fonts/Azalea.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }

        /* ═══════════════════════════════════════════════════════
           CSS VARIABLES - Masters Inspired Palette
           ═══════════════════════════════════════════════════════ */
        :root {
            --masters-green: #006747;
            --masters-dark: #00432e;
            --masters-darkest: #002a1c;
            --masters-light-green: #1a8a5c;
            --masters-yellow: #FFE234;
            --masters-gold: #C8A951;
            --masters-cream: #F5F1E8;
            --masters-red: #CE1141;
            --masters-white: #FFFFFF;
            --masters-black: #1a1a1a;
            --team-a-color: #CE1141;
            --team-b-color: #004F9E;
            --birdie-color: #CE1141;
            --eagle-color: #C8A951;
            --bogey-color: #006747;
            --card-shadow: 0 2px 8px rgba(0,0,0,0.15);
            --card-shadow-hover: 0 4px 16px rgba(0,0,0,0.2);
            --radius: 8px;
            --radius-lg: 12px;
            --transition: all 0.2s ease;
        }

        /* ═══════════════════════════════════════════════════════
           BASE STYLES
           ═══════════════════════════════════════════════════════ */
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Georgia', 'Times New Roman', serif;
            background: var(--masters-cream);
            color: var(--masters-black);
            min-height: 100vh;
            -webkit-tap-highlight-color: transparent;
        }

        /* Azalea: logo/title only. Clean sans-serif for UI headers (Masters broadcast style) */
        .azalea, .header-titles h1, .splash-title {
            font-family: 'Azalea', 'Georgia', serif;
        }
        h2, h3 {
            font-family: 'Trebuchet MS', 'Helvetica Neue', Arial, sans-serif;
        }

        /* ═══════════════════════════════════════════════════════
           HEADER
           ═══════════════════════════════════════════════════════ */
        .app-header {
            background: linear-gradient(180deg, var(--masters-dark) 0%, var(--masters-green) 100%);
            color: var(--masters-white);
            text-align: center;
            padding: 10px 12px 0;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 12px rgba(0,0,0,0.3);
        }

        .header-top {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 6px;
            position: relative;
        }

        .header-logo {
            width: 48px;
            height: 48px;
            object-fit: contain;
            filter: brightness(0) invert(1);
        }


        .header-titles { text-align: center; }

        .header-titles h1 {
            font-size: 1.4rem;
            color: var(--masters-yellow);
            letter-spacing: 1.5px;
            line-height: 1.1;
        }

        .header-titles .subtitle {
            font-size: 0.75rem;
            color: var(--masters-white);
            letter-spacing: 1.5px;
            text-transform: uppercase;
            font-family: 'Trebuchet MS', 'Helvetica Neue', Arial, sans-serif;
            opacity: 0.9;
        }

        /* ═══════════════════════════════════════════════════════
           TAB NAVIGATION
           ═══════════════════════════════════════════════════════ */
        .tab-nav {
            display: flex;
            justify-content: center;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
            gap: 0;
            border-bottom: 2px solid var(--masters-yellow);
        }
        .tab-nav::-webkit-scrollbar { display: none; }

        .tab-btn {
            flex: 0 0 auto;
            padding: 10px 16px;
            background: none;
            border: none;
            color: rgba(255,255,255,0.6);
            font-family: 'Trebuchet MS', 'Helvetica Neue', Arial, sans-serif;
            font-size: 0.75rem;
            font-weight: bold;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            cursor: pointer;
            white-space: nowrap;
            transition: var(--transition);
            border-bottom: 3px solid transparent;
            margin-bottom: -2px;
        }

        .tab-btn:hover { color: rgba(255,255,255,0.9); }

        .tab-btn.active {
            color: var(--masters-yellow);
            border-bottom-color: var(--masters-yellow);
        }

        /* Hamburger button - hidden on desktop */
        .hamburger-btn {
            display: none;
            background: none;
            border: none;
            cursor: pointer;
            padding: 8px;
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            z-index: 101;
        }
        .hamburger-btn span {
            display: block;
            width: 24px;
            height: 2px;
            background: var(--masters-white);
            margin: 5px 0;
            transition: var(--transition);
            border-radius: 1px;
        }
        .hamburger-btn.open span:nth-child(1) {
            transform: rotate(45deg) translate(5px, 5px);
        }
        .hamburger-btn.open span:nth-child(2) { opacity: 0; }
        .hamburger-btn.open span:nth-child(3) {
            transform: rotate(-45deg) translate(5px, -5px);
        }

        /* Mobile menu overlay */
        .mobile-menu-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.4);
            z-index: 99;
        }
        .mobile-menu-overlay.active { display: block; }

        /* Mobile nav styles */
        @media (max-width: 768px) {
            .hamburger-btn { display: block; }

            .app-header { position: sticky; }

            .header-top {
                /* Use grid for true centering - logo and hamburger take equal space */
                display: grid;
                grid-template-columns: 48px 1fr 48px;
                align-items: center;
            }

            .header-logo {
                grid-column: 1;
            }

            .header-titles {
                grid-column: 2;
                text-align: center;
            }

            .tab-nav {
                display: none;
                flex-direction: column;
                position: absolute;
                top: 100%;
                left: 0;
                right: 0;
                background: var(--masters-dark);
                border-bottom: 3px solid var(--masters-yellow);
                box-shadow: 0 8px 24px rgba(0,0,0,0.3);
                overflow: visible;
                z-index: 100;
                gap: 0;
            }

            .tab-nav.open { display: flex; }

            .tab-btn {
                padding: 14px 20px;
                font-size: 0.9rem;
                border-bottom: none;
                border-left: 3px solid transparent;
                margin-bottom: 0;
                text-align: left;
            }

            .tab-btn:hover { background: rgba(255,255,255,0.05); }

            .tab-btn.active {
                border-bottom: none;
                border-left-color: var(--masters-yellow);
                background: rgba(255,255,255,0.08);
            }
        }

        /* ═══════════════════════════════════════════════════════
           MAIN CONTENT
           ═══════════════════════════════════════════════════════ */
        .tab-content {
            display: none;
            padding: 16px;
            max-width: 900px;
            margin: 0 auto;
            animation: fadeIn 0.2s ease;
        }
        .tab-content.active { display: block; }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(4px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* ═══════════════════════════════════════════════════════
           LEADERBOARD - Ryder Cup Broadcast Style
           ═══════════════════════════════════════════════════════ */
        .lb-board {
            border-radius: var(--radius-lg);
            overflow: hidden;
            box-shadow: var(--card-shadow);
            margin-bottom: 20px;
        }

        .lb-section-header {
            background: var(--masters-green);
            color: var(--masters-yellow);
            padding: 10px 16px;
            font-family: 'Trebuchet MS', 'Helvetica Neue', Arial, sans-serif;
            font-size: 0.85rem;
            font-weight: bold;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        /* Match row - 3 column broadcast layout */
        .lb-match-row {
            display: grid;
            grid-template-columns: 1fr 44px 1fr;
            min-height: 48px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            font-size: 0.9rem;
        }
        .lb-match-row:last-child { border-bottom: none; }

        .lb-cell-a, .lb-cell-b {
            display: flex;
            align-items: center;
            padding: 10px 12px;
            color: var(--masters-white);
            background: #e8e4db;
            color: var(--masters-black);
            transition: var(--transition);
        }

        /* Team A cell: score on left, name right-aligned */
        .lb-cell-a {
            justify-content: flex-end;
            text-align: right;
            gap: 10px;
        }

        /* Team B cell: name left-aligned, score on right */
        .lb-cell-b {
            justify-content: flex-start;
            text-align: left;
            gap: 10px;
        }

        .lb-player-name {
            font-weight: bold;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .lb-match-score {
            font-weight: bold;
            font-size: 0.8rem;
            white-space: nowrap;
            min-width: fit-content;
        }

        /* Leading team gets their color background */
        .lb-cell-a.leading {
            background: var(--team-a-color);
            color: var(--masters-white);
        }
        .lb-cell-b.leading {
            background: var(--team-b-color);
            color: var(--masters-white);
        }

        /* Tied/halved - both sides neutral */
        .lb-cell-a.tied, .lb-cell-b.tied {
            background: #e8e4db;
            color: var(--masters-black);
        }

        /* Pending - lighter */
        .lb-cell-a.pending, .lb-cell-b.pending {
            background: #f0ece3;
            color: #999;
        }

        /* Center thru column */
        .lb-cell-thru {
            display: flex;
            align-items: center;
            justify-content: center;
            background: #6b6b6b;
            color: var(--masters-white);
            font-size: 0.75rem;
            font-weight: bold;
            letter-spacing: 0.5px;
        }

        /* Team totals footer bar */
        .lb-totals-row {
            display: grid;
            grid-template-columns: 1fr 44px 1fr;
            min-height: 52px;
            font-size: 1rem;
        }

        .lb-totals-a, .lb-totals-b {
            display: flex;
            align-items: center;
            padding: 10px 14px;
            font-weight: bold;
            color: var(--masters-white);
            gap: 10px;
        }

        .lb-totals-a {
            background: var(--team-a-color);
            justify-content: flex-end;
            text-align: right;
        }
        .lb-totals-b {
            background: var(--team-b-color);
            justify-content: flex-start;
            text-align: left;
        }

        .lb-total-team-name {
            font-family: 'Trebuchet MS', 'Helvetica Neue', Arial, sans-serif;
            font-size: 0.75rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            opacity: 0.9;
        }

        .lb-total-pts {
            font-size: 1.6rem;
            font-family: 'Trebuchet MS', 'Helvetica Neue', Arial, sans-serif;
            font-weight: bold;
            line-height: 1;
        }

        .lb-totals-center {
            display: flex;
            align-items: center;
            justify-content: center;
            background: #4a4a4a;
        }

        .lb-totals-center img {
            width: 36px;
            height: 36px;
            object-fit: contain;
            border-radius: 4px;
        }

        /* Session breakdown row */
        .lb-breakdown-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            padding: 10px 12px;
            font-size: 0.75rem;
            background: rgba(0, 0, 0, 0.05);
            border-top: 1px solid rgba(0, 0, 0, 0.1);
        }

        .lb-breakdown-side {
            display: flex;
            flex-direction: column;
            gap: 2px;
            color: #555;
            line-height: 1.4;
        }

        .lb-breakdown-side:first-child {
            text-align: left;
            padding-right: 8px;
            border-right: 1px solid rgba(0, 0, 0, 0.1);
        }

        .lb-breakdown-side:last-child {
            text-align: right;
            padding-left: 8px;
        }

        /* Projected totals row */
        .lb-projected-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            padding: 8px 12px;
            background: rgba(200, 169, 81, 0.15);
            border-top: 1px solid rgba(200, 169, 81, 0.3);
            font-size: 0.8rem;
        }

        .lb-projected-side {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .lb-projected-side:first-child {
            justify-content: flex-start;
            padding-right: 8px;
        }

        .lb-projected-side:last-child {
            justify-content: flex-end;
            padding-left: 8px;
        }

        .lb-projected-label {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--masters-gold);
            font-weight: bold;
        }

        .lb-projected-value {
            font-size: 1.1rem;
            font-weight: bold;
            color: var(--masters-gold);
            font-family: 'Trebuchet MS', 'Helvetica Neue', Arial, sans-serif;
        }

        .lb-empty { text-align: center; padding: 60px 20px; color: #999; }
        .lb-empty h3 { color: var(--masters-green); margin-bottom: 8px; font-size: 1.3rem; }
        .lb-empty-logo { width: 140px; opacity: 0.25; margin-bottom: 20px; }

        @media (max-width: 600px) {
            .lb-match-row { grid-template-columns: 1fr 36px 1fr; font-size: 0.8rem; }
            .lb-totals-row { grid-template-columns: 1fr 36px 1fr; }
            .lb-cell-a, .lb-cell-b { padding: 8px 6px; }
            .lb-cell-thru { font-size: 0.65rem; }
            .lb-total-pts { font-size: 1.3rem; }
            .lb-total-team-name { font-size: 0.65rem; }
            .lb-breakdown-row { font-size: 0.65rem; padding: 8px 8px; }
            .lb-projected-row { font-size: 0.7rem; padding: 6px 8px; }
            .lb-projected-value { font-size: 0.95rem; }
            /* Allow player names to wrap on mobile */
            .lb-player-name {
                white-space: normal;
                overflow: visible;
                font-size: 0.75rem;
                line-height: 1.2;
            }
            .lb-projected-label { font-size: 0.6rem; }
        }

        /* ═══════════════════════════════════════════════════════
           SCORING
           ═══════════════════════════════════════════════════════ */
        .scoring-match-select { margin-bottom: 16px; }

        .scoring-match-btn {
            display: block;
            width: 100%;
            padding: 14px 16px;
            margin-bottom: 8px;
            background: var(--masters-white);
            border: 2px solid #ddd;
            border-radius: var(--radius);
            text-align: left;
            cursor: pointer;
            font-family: 'Georgia', serif;
            font-size: 0.9rem;
            transition: var(--transition);
        }
        .scoring-match-btn:hover { border-color: var(--masters-green); }
        .scoring-match-btn.active-match {
            border-color: var(--masters-green);
            background: #f0f8f0;
        }

        .scoring-interface {
            background: var(--masters-white);
            border-radius: var(--radius-lg);
            box-shadow: var(--card-shadow);
            overflow: hidden;
        }

        .scoring-header {
            background: var(--masters-green);
            color: var(--masters-white);
            padding: 10px 12px;
            text-align: center;
        }

        .scoring-header .match-label {
            font-family: 'Trebuchet MS', 'Helvetica Neue', Arial, sans-serif;
            font-size: 0.65rem;
            color: var(--masters-gold);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .scoring-header .match-status-lg {
            font-size: 1.05rem;
            font-weight: bold;
            margin: 3px 0;
        }

        .scoring-hole-nav {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px 12px;
            background: var(--masters-dark);
            color: var(--masters-white);
            gap: 16px;
        }

        .scoring-hole-nav .hole-info {
            text-align: center;
        }

        .scoring-hole-nav .hole-num {
            font-size: 1.1rem;
            font-weight: bold;
        }

        .scoring-hole-nav .hole-details {
            font-family: 'Trebuchet MS', 'Helvetica Neue', Arial, sans-serif;
            font-size: 0.65rem;
            color: var(--masters-gold);
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }

        .hole-nav-btn {
            background: rgba(255,255,255,0.15);
            border: none;
            color: var(--masters-white);
            width: 48px;
            height: 48px;
            border-radius: 50%;
            font-size: 1.3rem;
            cursor: pointer;
            transition: var(--transition);
            flex-shrink: 0;
        }
        .hole-nav-btn:hover { background: rgba(255,255,255,0.25); }
        .hole-nav-btn:disabled { opacity: 0.3; cursor: default; }

        /* Score entry rows */
        .scoring-team-section {
            padding: 8px 12px;
            border-bottom: 1px solid #eee;
        }

        .scoring-team-label {
            font-family: 'Trebuchet MS', 'Helvetica Neue', Arial, sans-serif;
            font-size: 0.7rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding: 4px 4px 2px;
        }
        .scoring-team-label.team-a { color: var(--team-a-color); }
        .scoring-team-label.team-b { color: var(--team-b-color); }

        .score-entry-row {
            display: flex;
            align-items: center;
            padding: 6px 4px;
            gap: 8px;
        }

        .score-entry-name {
            flex: 1;
            font-size: 0.9rem;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .score-entry-name .hcp-badge {
            font-size: 0.65rem;
            color: #999;
            display: block;
        }

        .score-entry-controls {
            display: flex;
            align-items: center;
            gap: 0;
            flex-shrink: 0;
        }

        .score-adj-btn {
            width: 48px;
            height: 48px;
            border: 2px solid #ddd;
            background: #f9f9f5;
            font-size: 1.4rem;
            font-weight: bold;
            cursor: pointer;
            transition: var(--transition);
            color: var(--masters-black);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .score-adj-btn:first-child { border-radius: var(--radius) 0 0 var(--radius); }
        .score-adj-btn:last-child { border-radius: 0 var(--radius) var(--radius) 0; }
        .score-adj-btn:hover { background: #eee; }
        .score-adj-btn:active { background: #ddd; }

        .score-value-display {
            width: 52px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3rem;
            font-weight: bold;
            border-top: 2px solid #ddd;
            border-bottom: 2px solid #ddd;
            background: var(--masters-white);
            position: relative;
        }

        .score-value-display.birdie { color: var(--birdie-color); }
        .score-value-display.eagle { color: var(--eagle-color); }
        .score-value-display.bogey { color: var(--bogey-color); }
        .score-value-display.double-bogey { color: #666; }
        .score-value-display.no-score { color: #ccc; }

        .score-vs-par {
            position: absolute;
            bottom: 1px;
            right: 3px;
            font-size: 0.5rem;
            font-weight: bold;
        }

        .best-ball-indicator {
            font-size: 0.75rem;
            padding: 4px 8px;
            color: #666;
            font-style: italic;
        }
        .best-ball-indicator strong { color: var(--masters-black); }

        .hole-result-banner {
            text-align: center;
            padding: 10px;
            font-family: 'Trebuchet MS', 'Helvetica Neue', Arial, sans-serif;
            font-weight: bold;
            font-size: 0.85rem;
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }
        .hole-result-banner.team-a-win { background: var(--team-a-color); color: var(--masters-white); }
        .hole-result-banner.team-b-win { background: var(--team-b-color); color: var(--masters-white); }
        .hole-result-banner.hole-halved { background: #f0f0e8; color: #666; }
        .hole-result-banner.hole-pending { background: #f9f9f5; color: #bbb; }

        .scoring-hole-strip {
            display: flex;
            overflow-x: auto;
            padding: 10px 12px;
            gap: 4px;
            background: #fafaf5;
            border-top: 1px solid #eee;
            -webkit-overflow-scrolling: touch;
        }

        .hole-dot {
            flex: 0 0 auto;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.65rem;
            font-weight: bold;
            border: 2px solid #ddd;
            background: var(--masters-white);
            color: #999;
            cursor: pointer;
            transition: var(--transition);
        }
        .hole-dot.current { border-color: var(--masters-green); background: var(--masters-green); color: var(--masters-white); }
        .hole-dot.team-a-won { border-color: var(--team-a-color); background: var(--team-a-color); color: var(--masters-white); }
        .hole-dot.team-b-won { border-color: var(--team-b-color); background: var(--team-b-color); color: var(--masters-white); }
        .hole-dot.halved-hole { border-color: var(--masters-gold); background: var(--masters-gold); color: var(--masters-white); }

        .scoring-clear-btn {
            display: block;
            width: 100%;
            padding: 10px;
            background: none;
            border: none;
            border-top: 1px solid #eee;
            font-family: 'Trebuchet MS', 'Helvetica Neue', Arial, sans-serif;
            font-size: 0.7rem;
            font-weight: bold;
            color: #999;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        .scoring-clear-btn:hover { background: #f5f5f0; color: var(--masters-red); }

        /* ═══════════════════════════════════════════════════════
           MATCHES
           ═══════════════════════════════════════════════════════ */
        .match-day-header {
            background: var(--masters-green);
            color: var(--masters-yellow);
            padding: 12px 16px;
            border-radius: var(--radius);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .match-day-header h3 { font-size: 0.9rem; letter-spacing: 0.5px; }

        .match-setup-card {
            background: var(--masters-white);
            border-radius: var(--radius);
            box-shadow: var(--card-shadow);
            margin-bottom: 12px;
            overflow: hidden;
        }

        .match-setup-header {
            background: var(--masters-dark);
            color: var(--masters-white);
            padding: 10px 16px;
            font-family: 'Trebuchet MS', 'Helvetica Neue', Arial, sans-serif;
            font-size: 0.75rem;
            font-weight: bold;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .match-setup-body {
            padding: 12px 16px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .match-team-col { flex: 1; }

        .match-team-col label {
            display: block;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #999;
            margin-bottom: 4px;
        }

        .match-vs-col { font-size: 0.75rem; color: #999; font-style: italic; }

        /* ═══════════════════════════════════════════════════════
           PLAYERS
           ═══════════════════════════════════════════════════════ */
        .player-card {
            background: var(--masters-white);
            border-radius: var(--radius);
            box-shadow: var(--card-shadow);
            margin-bottom: 10px;
            padding: 14px 16px;
            display: flex;
            align-items: center;
            gap: 12px;
            transition: var(--transition);
        }
        .player-card:hover { box-shadow: var(--card-shadow-hover); }

        .player-avatar {
            width: 42px;
            height: 42px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1rem;
            color: var(--masters-white);
            flex-shrink: 0;
        }
        .player-avatar.team-a { background: var(--team-a-color); }
        .player-avatar.team-b { background: var(--team-b-color); }
        .player-avatar.no-team { background: #bbb; }

        .player-info { flex: 1; }
        .player-info .player-name { font-weight: bold; font-size: 1rem; }
        .player-info .player-detail { font-size: 0.8rem; color: #777; }

        .player-actions { display: flex; gap: 6px; }

        /* ═══════════════════════════════════════════════════════
           DRAFT
           ═══════════════════════════════════════════════════════ */
        .draft-board {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin-bottom: 16px;
        }

        .draft-team-col {
            background: var(--masters-white);
            border-radius: var(--radius-lg);
            box-shadow: var(--card-shadow);
            overflow: hidden;
        }

        .draft-team-header {
            padding: 12px;
            text-align: center;
            font-family: 'Trebuchet MS', 'Helvetica Neue', Arial, sans-serif;
            font-weight: bold;
            font-size: 0.85rem;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            color: var(--masters-white);
        }
        .draft-team-header.team-a { background: var(--team-a-color); }
        .draft-team-header.team-b { background: var(--team-b-color); }

        .draft-team-list { padding: 8px; min-height: 100px; }

        .draft-pick-item {
            padding: 8px 10px;
            border-radius: 6px;
            margin-bottom: 4px;
            font-size: 0.85rem;
            background: #f5f5f0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .draft-pick-item .pick-num { font-size: 0.7rem; color: #999; width: 20px; }

        .draft-pool {
            background: var(--masters-white);
            border-radius: var(--radius-lg);
            box-shadow: var(--card-shadow);
            overflow: hidden;
        }

        .draft-pool-header {
            background: var(--masters-green);
            color: var(--masters-yellow);
            padding: 12px;
            text-align: center;
            font-family: 'Trebuchet MS', 'Helvetica Neue', Arial, sans-serif;
            font-weight: bold;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            font-size: 0.8rem;
        }

        .draft-pool-indicator {
            background: var(--masters-dark);
            color: var(--masters-white);
            padding: 10px;
            text-align: center;
            font-size: 0.85rem;
        }
        .draft-pool-indicator .picking-team { font-weight: bold; font-size: 1rem; }

        .draft-pool-list { padding: 8px; }

        .draft-player-btn {
            display: block;
            width: 100%;
            padding: 12px;
            margin-bottom: 6px;
            background: #f9f9f5;
            border: 2px solid #eee;
            border-radius: var(--radius);
            text-align: left;
            cursor: pointer;
            font-family: 'Georgia', serif;
            font-size: 0.9rem;
            transition: var(--transition);
        }
        .draft-player-btn:hover { border-color: var(--masters-green); background: #f0f8f0; }
        .draft-player-btn .player-hcp { font-size: 0.75rem; color: #999; }

        /* ═══════════════════════════════════════════════════════
           SETTINGS
           ═══════════════════════════════════════════════════════ */
        .settings-section {
            background: var(--masters-white);
            border-radius: var(--radius-lg);
            box-shadow: var(--card-shadow);
            margin-bottom: 16px;
            overflow: hidden;
        }

        .settings-section-header {
            background: var(--masters-green);
            color: var(--masters-yellow);
            padding: 12px 16px;
            font-family: 'Trebuchet MS', 'Helvetica Neue', Arial, sans-serif;
            font-size: 0.8rem;
            font-weight: bold;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .settings-section-body { padding: 16px; }

        .course-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8rem;
        }
        .course-table th {
            background: var(--masters-dark);
            color: var(--masters-yellow);
            padding: 6px 8px;
            text-align: center;
            font-family: 'Trebuchet MS', 'Helvetica Neue', Arial, sans-serif;
            font-size: 0.7rem;
            font-weight: bold;
            letter-spacing: 0.3px;
            text-transform: uppercase;
        }
        .course-table td {
            padding: 5px 4px;
            text-align: center;
            border-bottom: 1px solid #eee;
        }
        .course-table input {
            width: 44px;
            padding: 4px;
            text-align: center;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: 'Georgia', serif;
            font-size: 0.8rem;
        }
        .course-table input:focus { outline: none; border-color: var(--masters-green); }
        .course-table .hole-label { font-weight: bold; color: var(--masters-green); }

        /* ═══════════════════════════════════════════════════════
           FORMS & INPUTS
           ═══════════════════════════════════════════════════════ */
        .form-group { margin-bottom: 14px; }

        .form-group label {
            display: block;
            font-family: 'Trebuchet MS', 'Helvetica Neue', Arial, sans-serif;
            font-size: 0.75rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            color: #666;
            margin-bottom: 4px;
        }

        .form-input {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #ddd;
            border-radius: var(--radius);
            font-family: 'Georgia', serif;
            font-size: 0.95rem;
            transition: var(--transition);
            background: var(--masters-white);
        }
        .form-input:focus { outline: none; border-color: var(--masters-green); }

        select.form-input {
            -webkit-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23666' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            padding-right: 32px;
        }

        .form-row { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }

        /* ═══════════════════════════════════════════════════════
           BUTTONS
           ═══════════════════════════════════════════════════════ */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 10px 20px;
            border: none;
            border-radius: var(--radius);
            font-family: 'Trebuchet MS', 'Helvetica Neue', Arial, sans-serif;
            font-size: 0.8rem;
            font-weight: bold;
            cursor: pointer;
            transition: var(--transition);
            letter-spacing: 0.3px;
            text-transform: uppercase;
        }

        .btn-primary { background: var(--masters-green); color: var(--masters-white); }
        .btn-primary:hover { background: var(--masters-dark); }

        .btn-gold { background: var(--masters-gold); color: var(--masters-darkest); }
        .btn-gold:hover { background: var(--masters-yellow); }

        .btn-danger { background: var(--masters-red); color: var(--masters-white); }
        .btn-danger:hover { opacity: 0.9; }

        .btn-outline { background: transparent; border: 2px solid var(--masters-green); color: var(--masters-green); }
        .btn-outline:hover { background: var(--masters-green); color: var(--masters-white); }

        .btn-sm { padding: 6px 12px; font-size: 0.75rem; }
        .btn-block { display: flex; width: 100%; }
        .btn-icon { width: 32px; height: 32px; padding: 0; border-radius: 50%; font-size: 0.85rem; }

        /* ═══════════════════════════════════════════════════════
           UTILITIES
           ═══════════════════════════════════════════════════════ */
        .section-title {
            font-family: 'Trebuchet MS', 'Helvetica Neue', Arial, sans-serif;
            color: var(--masters-green);
            font-size: 1.1rem;
            font-weight: bold;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            margin-bottom: 16px;
        }

        .text-center { text-align: center; }
        .text-muted { color: #999; }
        .text-sm { font-size: 0.8rem; }
        .mb-8 { margin-bottom: 8px; }
        .mb-16 { margin-bottom: 16px; }
        .mt-16 { margin-top: 16px; }

        .empty-state { text-align: center; padding: 40px 20px; color: #999; position: relative; }
        .empty-state h3 { color: var(--masters-green); margin-bottom: 8px; }
        .empty-state p { font-size: 0.9rem; }
        .empty-state::before {
            content: '';
            display: block;
            width: 120px;
            height: 120px;
            margin: 0 auto 20px;
            background: url('assets/images/Phone Size DFCG No Background.png') center/contain no-repeat;
            opacity: 0.18;
        }

        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--masters-dark);
            color: var(--masters-white);
            padding: 12px 24px;
            border-radius: var(--radius);
            font-size: 0.85rem;
            z-index: 1000;
            transition: transform 0.3s ease;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        .toast.show { transform: translateX(-50%) translateY(0); }

        /* Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.5);
            z-index: 200;
            align-items: center;
            justify-content: center;
            padding: 16px;
        }
        .modal-overlay.active { display: flex; }

        .modal {
            background: var(--masters-cream);
            border-radius: var(--radius-lg);
            max-width: 500px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }

        .modal-header {
            background: var(--masters-green);
            color: var(--masters-yellow);
            padding: 14px 16px;
            font-family: 'Trebuchet MS', 'Helvetica Neue', Arial, sans-serif;
            font-size: 0.9rem;
            font-weight: bold;
            letter-spacing: 1px;
            text-transform: uppercase;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-radius: var(--radius-lg) var(--radius-lg) 0 0;
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--masters-white);
            font-size: 1.5rem;
            cursor: pointer;
            line-height: 1;
        }

        .modal-body { padding: 16px; }

        .modal-footer {
            padding: 12px 16px;
            display: flex;
            gap: 8px;
            justify-content: flex-end;
            border-top: 1px solid #ddd;
        }

        /* ═══════════════════════════════════════════════════════
           MOBILE GATE & OPT-IN PAGES
           ═══════════════════════════════════════════════════════ */
        .gate-overlay, .optin-overlay {
            position: fixed;
            inset: 0;
            z-index: 1100;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 40px 30px;
        }
        .gate-overlay.active, .optin-overlay.active {
            display: flex;
        }

        /* Gate page: "Add to Home Screen" */
        .gate-overlay {
            background: linear-gradient(160deg, var(--masters-dark) 0%, var(--masters-green) 40%, var(--masters-dark) 100%);
            color: var(--masters-white);
        }
        .gate-logo {
            width: 50%;
            max-width: 220px;
            height: auto;
            margin-bottom: 30px;
            filter: brightness(0) invert(1);
        }
        .gate-title {
            font-family: 'Azalea', 'Georgia', serif;
            color: var(--masters-yellow);
            font-size: 1.6rem;
            letter-spacing: 2px;
            margin-bottom: 12px;
        }
        .gate-subtitle {
            font-size: 0.95rem;
            color: var(--masters-white);
            opacity: 0.85;
            margin-bottom: 30px;
            line-height: 1.5;
        }
        .gate-instructions {
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 20px 24px;
            width: 100%;
            max-width: 340px;
            text-align: left;
        }
        .gate-instructions h3 {
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--masters-yellow);
            margin-bottom: 14px;
        }
        .gate-step {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            margin-bottom: 12px;
            font-size: 0.9rem;
            line-height: 1.4;
        }
        .gate-step-num {
            background: var(--masters-yellow);
            color: var(--masters-dark);
            min-width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.8rem;
            flex-shrink: 0;
        }

        /* Opt-in page: waiver / legal feel */
        .optin-overlay {
            background: #ffffff;
            color: var(--masters-dark);
            padding: 50px 28px 40px;
            justify-content: flex-start;
        }
        .optin-title {
            font-family: 'Trebuchet MS', 'Helvetica Neue', Arial, sans-serif;
            font-size: 1.1rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--masters-dark);
            margin-bottom: 28px;
            padding-bottom: 12px;
            border-bottom: 1px solid #ccc;
            width: 100%;
            max-width: 360px;
            opacity: 0;
            animation: splashFadeIn 0.8s ease-out 0.2s forwards;
        }
        .optin-text {
            font-family: 'Georgia', 'Times New Roman', serif;
            font-size: 0.95rem;
            color: #2a2a2a;
            line-height: 1.7;
            margin-bottom: 36px;
            max-width: 360px;
            text-align: left;
            opacity: 0;
            animation: splashFadeIn 0.8s ease-out 0.6s forwards;
        }
        .optin-btn {
            background: var(--masters-dark);
            color: #ffffff;
            border: none;
            padding: 14px 48px;
            font-family: 'Trebuchet MS', 'Helvetica Neue', Arial, sans-serif;
            font-size: 0.95rem;
            font-weight: bold;
            letter-spacing: 1.5px;
            text-transform: uppercase;
            border-radius: 6px;
            cursor: pointer;
            opacity: 0;
            animation: splashFadeIn 0.8s ease-out 1.2s forwards;
            transition: transform 0.15s ease, background 0.15s ease;
        }
        .optin-btn:active {
            transform: scale(0.96);
            background: var(--masters-green);
        }

        /* ═══════════════════════════════════════════════════════
           SPLASH SCREEN
           ═══════════════════════════════════════════════════════ */
        .splash-overlay {
            position: fixed;
            inset: 0;
            z-index: 999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 1s ease;
        }
        .splash-overlay.fade-out { opacity: 0; pointer-events: none; }
        .splash-overlay.hidden { display: none; }

        /* Phase 1: DFGC Presents (white background, on top of phase 2) */
        .splash-phase1 {
            background: #ffffff;
            z-index: 1000;
        }

        .splash-phase1-logo {
            width: 65%;
            max-width: 400px;
            height: auto;
            opacity: 0;
            animation: splashFadeIn 1.2s ease-out 0.3s forwards;
        }

        .splash-phase1-presents {
            font-family: 'Azalea', 'Georgia', serif;
            color: var(--masters-dark);
            font-size: 1.4rem;
            letter-spacing: 3px;
            margin-top: 10px;
            opacity: 0;
            animation: splashFadeIn 1s ease-out 1s forwards;
        }

        /* Video Phase: Jacket video */
        .splash-video {
            background: #000;
            z-index: 999;
            transition: opacity 3s ease;
        }
        .splash-video video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* Phase 2: The Smashters (green background) */
        .splash-phase2 {
            background: linear-gradient(160deg, var(--masters-dark) 0%, var(--masters-green) 40%, var(--masters-dark) 100%);
        }

        .splash-logo {
            width: 55%;
            max-width: 300px;
            height: auto;
            filter: brightness(0) invert(1);
            opacity: 0;
        }

        .splash-phase2.active .splash-logo {
            animation: splashFadeIn 1.2s ease-out 0.2s forwards;
        }

        .splash-title {
            font-family: 'Azalea', 'Georgia', serif;
            color: var(--masters-yellow);
            font-size: 2.4rem;
            letter-spacing: 2px;
            margin-top: 10px;
            opacity: 0;
        }

        .splash-phase2.active .splash-title {
            animation: splashFadeIn 1s ease-out 0.8s forwards;
        }

        .splash-subtitle {
            color: var(--masters-white);
            font-family: 'Trebuchet MS', 'Helvetica Neue', Arial, sans-serif;
            font-size: 0.85rem;
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-top: 8px;
            opacity: 0;
            animation: splashFadeIn 1s ease-out 1.2s forwards;
        }

        .splash-year {
            color: var(--masters-gold);
            font-family: 'Trebuchet MS', 'Helvetica Neue', Arial, sans-serif;
            font-size: 1rem;
            font-weight: bold;
            letter-spacing: 2px;
            margin-top: 12px;
            opacity: 0;
        }

        .splash-phase2.active .splash-year {
            animation: splashFadeIn 1s ease-out 1.5s forwards;
        }

        @keyframes splashFadeIn {
            from { opacity: 0; transform: translateY(8px); }
            to { opacity: 1; transform: translateY(0); }
        }

        #burnCanvas {
            position: fixed;
            inset: 0;
            z-index: 1001;
            pointer-events: none;
        }

        /* ═══════════════════════════════════════════════════════
           INSTALL BANNER
           ═══════════════════════════════════════════════════════ */
        .install-banner {
            display: none;
            background: linear-gradient(135deg, var(--masters-dark) 0%, var(--masters-green) 100%);
            color: var(--masters-white);
            padding: 14px 16px;
            margin: 12px 16px;
            border-radius: var(--radius-lg);
            box-shadow: var(--card-shadow);
            max-width: 900px;
            margin-left: auto;
            margin-right: auto;
        }
        .install-banner.show { display: block; }
        .install-banner-top {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .install-banner-icon {
            width: 44px;
            height: 44px;
            border-radius: 10px;
            object-fit: contain;
            background: var(--masters-darkest);
            padding: 6px;
            flex-shrink: 0;
        }
        .install-banner-text { flex: 1; }
        .install-banner-text strong {
            display: block;
            font-size: 0.95rem;
            margin-bottom: 2px;
        }
        .install-banner-text span {
            font-size: 0.75rem;
            opacity: 0.85;
        }
        .install-banner-close {
            background: none;
            border: none;
            color: rgba(255,255,255,0.6);
            font-size: 1.3rem;
            cursor: pointer;
            padding: 4px;
            line-height: 1;
            flex-shrink: 0;
        }
        .install-banner-close:hover { color: #fff; }
        .install-banner-actions {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }
        .install-banner-actions .btn { flex: 1; justify-content: center; font-size: 0.75rem; padding: 8px 12px; }
        .install-ios-steps {
            margin-top: 10px;
            padding: 10px 12px;
            background: rgba(0,0,0,0.2);
            border-radius: var(--radius);
            font-size: 0.8rem;
            line-height: 1.6;
        }
        .install-ios-steps .step-num {
            display: inline-block;
            width: 20px;
            height: 20px;
            background: var(--masters-yellow);
            color: var(--masters-darkest);
            border-radius: 50%;
            text-align: center;
            line-height: 20px;
            font-size: 0.65rem;
            font-weight: bold;
            margin-right: 6px;
        }
        .install-ios-steps .share-icon {
            display: inline-block;
            width: 16px;
            height: 16px;
            vertical-align: text-bottom;
        }

        /* ═══════════════════════════════════════════════════════
           LIVE SHARING
           ═══════════════════════════════════════════════════════ */
        .live-banner {
            background: var(--masters-red);
            color: var(--masters-white);
            text-align: center;
            padding: 6px 12px;
            font-family: 'Trebuchet MS', 'Helvetica Neue', Arial, sans-serif;
            font-size: 0.7rem;
            font-weight: bold;
            letter-spacing: 0.5px;
            display: none;
            align-items: center;
            justify-content: center;
            gap: 8px;
            flex-wrap: wrap;
        }
        .live-banner.active { display: flex; }
        .live-dot {
            width: 8px;
            height: 8px;
            background: #fff;
            border-radius: 50%;
            animation: livePulse 1.5s infinite;
            flex-shrink: 0;
        }
        @keyframes livePulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        .live-banner-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 2px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.7rem;
            font-family: 'Georgia', serif;
        }
        .live-banner-btn:hover { background: rgba(255,255,255,0.35); }

        /* Viewer mode: disable score editing */
        .viewer-mode .score-adj-btn { pointer-events: none; opacity: 0.3; }
        .viewer-mode .scoring-clear-btn { display: none; }
        .viewer-mode .btn-danger { display: none; }
        .viewer-mode .match-setup-header .btn { display: none; }
        .viewer-mode .match-day-header .btn { display: none; }
        .viewer-mode .player-actions { display: none; }

        /* Scorer mode: only allow their match */
        .scorer-mode .score-adj-btn.disabled-scorer { pointer-events: none; opacity: 0.3; }
        .scorer-mode .scoring-clear-btn.disabled-scorer { display: none; }

        /* Join live card */
        .join-live-card {
            background: var(--masters-white);
            border-radius: var(--radius-lg);
            box-shadow: var(--card-shadow);
            padding: 20px;
            text-align: center;
            margin-bottom: 20px;
            border: 2px solid var(--masters-green);
        }
        .join-live-card h3 {
            color: var(--masters-green);
            font-size: 1.1rem;
            margin-bottom: 12px;
        }
        .join-live-input {
            width: 100%;
            max-width: 200px;
            padding: 10px 12px;
            border: 2px solid #ddd;
            border-radius: var(--radius);
            font-family: 'Georgia', serif;
            font-size: 1.1rem;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 3px;
            margin-bottom: 10px;
        }
        .join-live-input:focus { outline: none; border-color: var(--masters-green); }
        .join-live-btns { display: flex; gap: 8px; justify-content: center; flex-wrap: wrap; }

        /* Match code display */
        .match-code-list { margin-top: 12px; }
        .match-code-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 12px;
            background: #f5f5f0;
            border-radius: var(--radius);
            margin-bottom: 6px;
            font-size: 0.85rem;
        }
        .match-code-value {
            font-family: monospace;
            font-size: 1.1rem;
            font-weight: bold;
            color: var(--masters-green);
            letter-spacing: 2px;
            background: var(--masters-white);
            padding: 4px 10px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }

        /* ═══════════════════════════════════════════════════════
           RESPONSIVE
           ═══════════════════════════════════════════════════════ */
        @media (max-width: 600px) {
            .header-titles h1 { font-size: 1.2rem; }
            .lb-team-pts { font-size: 2.2rem; }
            .form-row { grid-template-columns: 1fr; }
            .draft-board { grid-template-columns: 1fr; }
            .score-entry-name { font-size: 0.8rem; }
            .score-adj-btn { width: 44px; height: 44px; font-size: 1.2rem; }
            .score-value-display { width: 48px; height: 44px; font-size: 1.2rem; }

            /* Sessions section - wrap to multiple lines on mobile */
            .session-config-row {
                flex-wrap: wrap !important;
            }
            .session-config-row input[id^="session_name_"],
            .session-config-row select[id^="session_format_"] {
                flex: 1 1 100% !important;
                min-width: 100% !important;
            }
            .session-config-row input[id^="session_date_"] {
                flex: 1 1 100% !important;
                min-width: 100% !important;
            }
            .session-config-row button {
                flex: 0 0 auto !important;
            }
        }

        @media (min-width: 768px) {
            .tab-content { padding: 24px; }
            .header-logo { width: 72px; height: 72px; }
            .header-titles h1 { font-size: 2rem; }
        }

        /* ═══════════════════════════════════════════════════════
           BIRDIE FLAMES 🔥
           ═══════════════════════════════════════════════════════ */
        .flame-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
        }

        .flame {
            position: absolute;
            font-size: 3rem;
            animation: floatFlame 2s ease-out forwards;
            filter: drop-shadow(0 0 10px rgba(255, 100, 0, 0.8));
        }

        @keyframes floatFlame {
            0% {
                transform: translateY(0) scale(0.5) rotate(0deg);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            50% {
                transform: translateY(-150px) scale(1.2) rotate(10deg);
                opacity: 1;
            }
            100% {
                transform: translateY(-300px) scale(1.5) rotate(20deg);
                opacity: 0;
            }
        }

        .birdie-burst {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 5rem;
            font-weight: bold;
            color: var(--masters-red);
            text-shadow: 0 0 20px rgba(206, 17, 65, 0.8),
                         0 0 40px rgba(206, 17, 65, 0.6);
            animation: birdiePopBurst 1.5s ease-out forwards;
            pointer-events: none;
            z-index: 10000;
        }

        @keyframes birdiePopBurst {
            0% {
                transform: translate(-50%, -50%) scale(0);
                opacity: 0;
            }
            20% {
                transform: translate(-50%, -50%) scale(1.3);
                opacity: 1;
            }
            60% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(0.8);
                opacity: 0;
            }
        }
    </style>
</head>
<body>

    <!-- ═══════════════════════════════════════════════════════
         MOBILE GATE: Add to Home Screen
         ═══════════════════════════════════════════════════════ -->
    <div class="gate-overlay" id="mobileGate">
        <img src="assets/images/smashters-logo-green.png" alt="The Smashters" class="gate-logo">
        <div class="gate-title">The Smashters</div>
        <div class="gate-subtitle">For the best experience, add this app to your home screen.</div>
        <div class="gate-instructions" id="gateInstructions"></div>
    </div>

    <!-- ═══════════════════════════════════════════════════════
         OPT-IN PAGE: Waiver
         ═══════════════════════════════════════════════════════ -->
    <div class="optin-overlay" id="optInPage">
        <div class="optin-title">Waiver of Responsibility</div>
        <div class="optin-text">
            By tapping "I Accept," you acknowledge that the Dumpster Fire Golf Club (DFGC) is not responsible for any damage to your ego, your handicap, your marriage, or your dignity.
            <br><br>
            You voluntarily assume all risks including but not limited to: devastating shanks, questionable side bets, unsolicited swing advice, and decisions that seemed brilliant on the 10th tee.
            <br><br>
            What happens at DFGC stays at DFGC. Unless it's on video.
        </div>
        <button class="optin-btn" id="optInBtn">I Accept</button>
    </div>

    <!-- ═══════════════════════════════════════════════════════
         SPLASH SCREEN - Phase 1: DFGC Presents
         ═══════════════════════════════════════════════════════ -->
    <div class="splash-overlay splash-phase1" id="splashPhase1">
        <img src="assets/images/Phone Size DFCG No Background.png" alt="Dumpster Fire Golf Club" class="splash-phase1-logo">
        <div class="splash-phase1-presents">Presents</div>
    </div>

    <!-- ═══════════════════════════════════════════════════════
         SPLASH SCREEN - Video Phase: Jackets
         ═══════════════════════════════════════════════════════ -->
    <div class="splash-overlay splash-video" id="splashVideo">
        <video id="splashVideoEl" muted playsinline preload="auto"
            src="assets/images/Jacket.mp4"></video>
    </div>

    <!-- ═══════════════════════════════════════════════════════
         SPLASH SCREEN - Phase 2: The Smashters
         ═══════════════════════════════════════════════════════ -->
    <canvas id="burnCanvas" width="0" height="0"></canvas>
    <div class="splash-overlay splash-phase2" id="splashPhase2">
        <img src="assets/images/smashters-logo-green.png" alt="" class="splash-logo">
        <div class="splash-title">The Smashters</div>
        <div class="splash-year" id="splashYear"></div>
    </div>

    <!-- ═══════════════════════════════════════════════════════
         HEADER & NAVIGATION
         ═══════════════════════════════════════════════════════ -->
    <header class="app-header">
        <div class="header-top">
            <img src="assets/images/smashters-logo-green.png" alt="Smashters" class="header-logo">
            <button class="hamburger-btn" id="hamburgerBtn" onclick="toggleMobileMenu()">
                <span></span><span></span><span></span>
            </button>
            <div class="header-titles">
                <h1>The Smashters</h1>
                <div class="subtitle">Dumpster Fire Golf Club</div>
            </div>
        </div>
        <nav class="tab-nav" id="tabNav">
            <button class="tab-btn active" data-tab="schedule">Schedule</button>
            <button class="tab-btn" data-tab="leaderboard">Leaderboard</button>
            <button class="tab-btn" data-tab="individual">Individual</button>
            <button class="tab-btn" data-tab="scoring">Scoring</button>
            <button class="tab-btn" data-tab="matches">Matches</button>
            <button class="tab-btn" data-tab="players">Players</button>
            <button class="tab-btn" data-tab="draft">Draft</button>
            <button class="tab-btn" data-tab="settings">Settings</button>
        </nav>
    </header>
    <div class="mobile-menu-overlay" id="mobileMenuOverlay" onclick="closeMobileMenu()"></div>

    <!-- Live Banner -->
    <div class="live-banner" id="liveBanner"></div>

    <!-- Install Banner -->
    <div class="install-banner" id="installBanner"></div>

    <section class="tab-content active" id="tab-leaderboard"><div id="leaderboard-content"></div></section>
    <section class="tab-content" id="tab-individual"><div id="individual-content"></div></section>
    <section class="tab-content" id="tab-scoring"><div id="scoring-content"></div></section>
    <section class="tab-content" id="tab-schedule"><div id="schedule-content"></div></section>
    <section class="tab-content" id="tab-matches"><div id="matches-content"></div></section>
    <section class="tab-content" id="tab-players"><div id="players-content"></div></section>
    <section class="tab-content" id="tab-draft"><div id="draft-content"></div></section>
    <section class="tab-content" id="tab-settings"><div id="settings-content"></div></section>

    <div class="modal-overlay" id="modalOverlay">
        <div class="modal" id="modalContainer"></div>
    </div>
    <div class="toast" id="toast"></div>

    <script>
    /* ═══════════════════════════════════════════════════════════
       THE SMASHTERS APP
       Dumpster Fire Golf Club - Ryder Cup Style Event Manager
       ═══════════════════════════════════════════════════════════ */

    // ─────────────────────────────────────────────────────────
    // COURSE DATA
    // ─────────────────────────────────────────────────────────
    // App version for cache busting and migration
    const APP_VERSION = '2.6.2';
    const VERSION_KEY = 'smashters-version';

    const DEFAULT_COURSE_HOLES = [
        { hole: 1,  par: 4, hcp: 15 },
        { hole: 2,  par: 5, hcp: 13 },
        { hole: 3,  par: 3, hcp: 9 },
        { hole: 4,  par: 4, hcp: 1 },
        { hole: 5,  par: 5, hcp: 7 },
        { hole: 6,  par: 4, hcp: 3 },
        { hole: 7,  par: 3, hcp: 17 },
        { hole: 8,  par: 4, hcp: 11 },
        { hole: 9,  par: 4, hcp: 5 },
        { hole: 10, par: 4, hcp: 8 },
        { hole: 11, par: 4, hcp: 2 },
        { hole: 12, par: 3, hcp: 16 },
        { hole: 13, par: 4, hcp: 6 },
        { hole: 14, par: 4, hcp: 10 },
        { hole: 15, par: 5, hcp: 12 },
        { hole: 16, par: 3, hcp: 18 },
        { hole: 17, par: 4, hcp: 4 },
        { hole: 18, par: 5, hcp: 14 },
    ];

    // ─────────────────────────────────────────────────────────
    // STATE
    // ─────────────────────────────────────────────────────────
    const STORAGE_KEY = 'smashters-state';

    const defaultState = () => ({
        config: {
            eventName: 'The Smashters',
            clubName: 'Dumpster Fire Golf Club',
            year: new Date().getFullYear(),
            teamA: { name: 'Team Fire', color: '#CE1141' },
            teamB: { name: 'Team Ice', color: '#004F9E' },
            teamSize: 6,
            courseName: '',
            eventDate: '',
            courseHoles: JSON.parse(JSON.stringify(DEFAULT_COURSE_HOLES)),
            useHandicaps: true,
            sessions: [
                { id: 'session-1', name: 'Day 1', format: 'fourball', order: 1, date: '' },
                { id: 'session-2', name: 'Day 2', format: 'singles', order: 2, date: '' }
            ],
        },
        players: {},
        draft: {
            status: 'pending',
            captainA: null,
            captainB: null,
            picks: [],
            currentTeam: 'A',
        },
        matches: {},
        bonusEvents: {},
        ui: {
            activeTab: 'schedule',
            activeMatchId: null,
            scoringHole: 1,
            settingsUnlocked: false,
            individualView: 'points',
            individualType: 'gross',
            individualSession: 'all',
        },
    });

    let S = loadState();

    function loadState() {
        try {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (saved) {
                const parsed = JSON.parse(saved);
                const base = defaultState();

                // Migrate old day-based matches to session-based
                const matches = parsed.matches || {};
                Object.values(matches).forEach(match => {
                    if (match.day && !match.sessionId) {
                        match.sessionId = `session-${match.day}`;
                    }
                    // Ensure holes property exists
                    if (!match.holes) {
                        match.holes = {};
                    }
                });

                const loadedState = {
                    config: { ...base.config, ...parsed.config,
                        teamA: { ...base.config.teamA, ...(parsed.config?.teamA || {}) },
                        teamB: { ...base.config.teamB, ...(parsed.config?.teamB || {}) },
                        courseHoles: parsed.config?.courseHoles || base.config.courseHoles,
                        sessions: parsed.config?.sessions || base.config.sessions,
                    },
                    players: parsed.players || {},
                    draft: { ...base.draft, ...parsed.draft },
                    matches,
                    bonusEvents: parsed.bonusEvents || {},
                    ui: { ...base.ui, ...parsed.ui, settingsUnlocked: false },
                };

                console.log(`State loaded: ${Object.keys(loadedState.players).length} players, ${Object.keys(loadedState.matches).length} matches`);
                return loadedState;
            }
        } catch (e) {
            console.error('Load state error:', e);
            // Try to load from backup if main state is corrupted
            try {
                const backup = localStorage.getItem(STORAGE_KEY + '-backup');
                if (backup) {
                    console.warn('Main state corrupted, attempting backup restore...');
                    const parsed = JSON.parse(backup);
                    if (parsed && (Object.keys(parsed.players || {}).length > 0 || Object.keys(parsed.matches || {}).length > 0)) {
                        showToast('Restored from backup');
                        return loadState(); // Will load from main key after backup is copied
                    }
                }
            } catch (backupError) {
                console.error('Backup restore failed:', backupError);
            }
        }
        return defaultState();
    }

    function saveState(skipFirebaseSync = false) {
        // Validate state before saving - prevent saving empty/corrupted data
        const playerCount = Object.keys(S.players || {}).length;
        const matchCount = Object.keys(S.matches || {}).length;

        // If we're about to wipe out data, create a backup first
        if (playerCount > 0 || matchCount > 0) {
            try {
                const backup = localStorage.getItem(STORAGE_KEY);
                if (backup) {
                    localStorage.setItem(STORAGE_KEY + '-backup', backup);
                    localStorage.setItem(STORAGE_KEY + '-backup-time', Date.now().toString());
                }
            } catch (e) { console.error('Backup error:', e); }
        }

        // Update local timestamp
        S._lastSync = Date.now();

        // Save to localStorage
        try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(S));
            console.log(`State saved: ${playerCount} players, ${matchCount} matches`);
        }
        catch (e) { console.error('Save state error:', e); }

        // Sync to Firebase if live (unless explicitly skipped)
        if (!skipFirebaseSync && (LiveSync.isAdmin || LiveSync.isScorer)) {
            LiveSync.syncToFirebase();
        }
    }

    function genId() {
        return Date.now().toString(36) + Math.random().toString(36).slice(2, 7);
    }

    function requireAdmin(operation) {
        if (S.ui.settingsUnlocked) {
            return true;
        }
        const code = prompt(`Admin access required to ${operation}.\nEnter admin code:`);
        if (code === '1313') {
            S.ui.settingsUnlocked = true;
            saveState();
            showToast('Admin access granted');
            return true;
        }
        if (code !== null) {
            showToast('Incorrect admin code');
        }
        return false;
    }

    // ─────────────────────────────────────────────────────────
    // TOAST & MODAL
    // ─────────────────────────────────────────────────────────
    function showToast(msg) {
        const t = document.getElementById('toast');
        t.textContent = msg;
        t.classList.add('show');
        setTimeout(() => t.classList.remove('show'), 2500);
    }

    function openModal(title, bodyHtml, footerHtml) {
        const overlay = document.getElementById('modalOverlay');
        document.getElementById('modalContainer').innerHTML = `
            <div class="modal-header">
                <span>${title}</span>
                <button class="modal-close" onclick="closeModal()">&times;</button>
            </div>
            <div class="modal-body">${bodyHtml}</div>
            ${footerHtml ? `<div class="modal-footer">${footerHtml}</div>` : ''}
        `;
        overlay.classList.add('active');
    }

    function closeModal() {
        document.getElementById('modalOverlay').classList.remove('active');
    }

    // ─────────────────────────────────────────────────────────
    // TAB NAVIGATION
    // ─────────────────────────────────────────────────────────
    function switchTab(tabId) {
        // Password protect settings tab
        if (tabId === 'settings' && !S.ui.settingsUnlocked) {
            const password = prompt('Enter settings password:');
            if (password !== '1313') {
                showToast('Incorrect password');
                return;
            }
            S.ui.settingsUnlocked = true;
            saveState();
        }

        document.querySelectorAll('.tab-btn').forEach(b => b.classList.toggle('active', b.dataset.tab === tabId));
        document.querySelectorAll('.tab-content').forEach(s => s.classList.toggle('active', s.id === `tab-${tabId}`));
        S.ui.activeTab = tabId;
        saveState();
        renderTab(tabId);
    }

    document.getElementById('tabNav').addEventListener('click', e => {
        if (e.target.classList.contains('tab-btn')) {
            switchTab(e.target.dataset.tab);
            closeMobileMenu();
        }
    });

    // ─────────────────────────────────────────────────────────
    // MOBILE HAMBURGER MENU
    // ─────────────────────────────────────────────────────────
    function toggleMobileMenu() {
        const nav = document.getElementById('tabNav');
        const btn = document.getElementById('hamburgerBtn');
        const overlay = document.getElementById('mobileMenuOverlay');
        const isOpen = nav.classList.contains('open');
        nav.classList.toggle('open', !isOpen);
        btn.classList.toggle('open', !isOpen);
        overlay.classList.toggle('active', !isOpen);
    }

    function closeMobileMenu() {
        document.getElementById('tabNav').classList.remove('open');
        document.getElementById('hamburgerBtn').classList.remove('open');
        document.getElementById('mobileMenuOverlay').classList.remove('active');
    }

    function renderTab(tabId) {
        const r = { leaderboard: renderLeaderboard, individual: renderIndividual, scoring: renderScoring,
            schedule: renderSchedule, matches: renderMatches, players: renderPlayers, draft: renderDraft, settings: renderSettings };
        if (r[tabId]) r[tabId]();
    }

    // ─────────────────────────────────────────────────────────
    // HELPERS
    // ─────────────────────────────────────────────────────────
    function getPlayer(id) { return S.players[id] || null; }
    function getPlayerName(id) { return S.players[id]?.name || 'Unknown'; }
    function getPlayerHcp(id) { return parseInt(S.players[id]?.handicap) || 0; }
    function getTeamPlayers(team) {
        return Object.values(S.players)
            .filter(p => p.team === team)
            .sort((a, b) => {
                const hcpA = a.handicap || 999;
                const hcpB = b.handicap || 999;
                return hcpA - hcpB;
            });
    }
    function getMatchesByDay(day) { return Object.values(S.matches).filter(m => m.day === day || m.sessionId === `session-${day}`).sort((a, b) => a.order - b.order); }
    function getMatchesBySession(sessionId) { return Object.values(S.matches).filter(m => m.sessionId === sessionId).sort((a, b) => a.order - b.order); }

    function getHoleInfo(holeNum) {
        return S.config.courseHoles[holeNum - 1] || { hole: holeNum, par: 4, hcp: holeNum };
    }

    function formatScore(n) {
        if (n === Math.floor(n)) return n.toString();
        return Math.floor(n) + '\u00BD';
    }

    // ─────────────────────────────────────────────────────────
    // HANDICAP & SCORING LOGIC
    // ─────────────────────────────────────────────────────────
    // Returns how many strokes a player receives on a given hole
    function getStrokesOnHole(playerHcp, holeHcpRank) {
        if (!playerHcp || playerHcp <= 0) return 0;
        const full = Math.floor(playerHcp / 18);
        const extra = playerHcp % 18;
        return full + (holeHcpRank <= extra ? 1 : 0);
    }

    // Get match play strokes for a player (spinning off the low handicap in the match)
    function getMatchPlayStrokes(match, playerId) {
        if (!match || !S.config.useHandicaps) return 0;
        const allPlayerIds = [...match.teamA, ...match.teamB];

        // Four Ball: use 90% of course handicap, Singles: use 100%
        const handicapPercent = match.type === 'fourball' ? 0.9 : 1.0;

        // Get all adjusted handicaps
        const allHandicaps = allPlayerIds.map(id => {
            const courseHcp = getPlayerHcp(id) || 0;
            return Math.round(courseHcp * handicapPercent);
        });

        // Spin off the low (from adjusted handicaps)
        const lowHandicap = Math.min(...allHandicaps);
        const playerHandicap = getPlayerHcp(playerId) || 0;
        const adjustedHcp = Math.round(playerHandicap * handicapPercent);

        return Math.max(0, adjustedHcp - lowHandicap);
    }

    // Get team handicap for alternate shot (average of team members, rounded)
    function getTeamHandicap(teamIds) {
        const hcps = teamIds.map(id => getPlayerHcp(id) || 0);
        return Math.round(hcps.reduce((a, b) => a + b, 0) / hcps.length);
    }

    // Get match play strokes for alternate shot teams (spinning off the low team handicap)
    function getAlternateShotStrokes(match) {
        if (!match || !S.config.useHandicaps) return { teamA: 0, teamB: 0 };
        const teamAHcp = getTeamHandicap(match.teamA);
        const teamBHcp = getTeamHandicap(match.teamB);
        const lowTeamHcp = Math.min(teamAHcp, teamBHcp);
        return {
            teamA: Math.max(0, teamAHcp - lowTeamHcp),
            teamB: Math.max(0, teamBHcp - lowTeamHcp)
        };
    }

    // Get the net score for a player on a hole (uses full course handicap)
    function getNetScore(playerId, holeNum, grossScore) {
        if (grossScore === null || grossScore === undefined) return null;
        if (!S.config.useHandicaps) return grossScore;
        const holeInfo = getHoleInfo(holeNum);
        const strokes = getStrokesOnHole(getPlayerHcp(playerId), holeInfo.hcp);
        return grossScore - strokes;
    }

    // Get the net score for a player on a hole in match play (uses match play strokes - spinning off the low)
    function getMatchNetScore(match, playerId, holeNum, grossScore) {
        if (grossScore === null || grossScore === undefined) return null;
        if (!S.config.useHandicaps) return grossScore;
        const holeInfo = getHoleInfo(holeNum);
        const matchPlayHcp = getMatchPlayStrokes(match, playerId);
        const strokes = getStrokesOnHole(matchPlayHcp, holeInfo.hcp);
        return grossScore - strokes;
    }

    // Determine who wins a hole from the match scores
    // Returns 'A', 'B', 'halved', or null (incomplete)
    function getHoleWinner(match, holeNum) {
        if (!match || !match.holes) return null; // Guard against undefined match or holes
        const holeScores = match.holes[holeNum];
        if (!holeScores) return null;

        // Get all players and their scores
        const teamAIds = match.teamA;
        const teamBIds = match.teamB;

        // Check if all required scores are entered
        let allHaveScores;
        if (match.type === 'foursomes') {
            // Foursomes: only need score from first player of each team
            allHaveScores = (holeScores[teamAIds[0]] !== undefined && holeScores[teamAIds[0]] !== null) &&
                           (holeScores[teamBIds[0]] !== undefined && holeScores[teamBIds[0]] !== null);
        } else {
            // Four Ball or Singles: need scores from all players
            const allPlayers = [...teamAIds, ...teamBIds];
            allHaveScores = allPlayers.every(id => holeScores[id] !== undefined && holeScores[id] !== null);
        }
        if (!allHaveScores) return null;

        if (match.type === 'fourball') {
            // Best ball: lowest net score from each team (using match play strokes)
            const teamANets = teamAIds.map(id => getMatchNetScore(match, id, holeNum, holeScores[id])).filter(s => s !== null);
            const teamBNets = teamBIds.map(id => getMatchNetScore(match, id, holeNum, holeScores[id])).filter(s => s !== null);
            if (teamANets.length === 0 || teamBNets.length === 0) return null;
            const bestA = Math.min(...teamANets);
            const bestB = Math.min(...teamBNets);
            if (bestA < bestB) return 'A';
            if (bestB < bestA) return 'B';
            return 'halved';
        } else if (match.type === 'foursomes') {
            // Foursomes (Alternate Shot): one score per team, use team handicap strokes
            const teamStrokes = getAlternateShotStrokes(match);
            const holeInfo = getHoleInfo(holeNum);

            // Score is stored under first player of each team
            const grossA = holeScores[teamAIds[0]];
            const grossB = holeScores[teamBIds[0]];
            if (grossA === null || grossA === undefined || grossB === null || grossB === undefined) return null;

            // Apply team strokes
            const strokesA = getStrokesOnHole(teamStrokes.teamA, holeInfo.hcp);
            const strokesB = getStrokesOnHole(teamStrokes.teamB, holeInfo.hcp);
            const netA = S.config.useHandicaps ? grossA - strokesA : grossA;
            const netB = S.config.useHandicaps ? grossB - strokesB : grossB;

            if (netA < netB) return 'A';
            if (netB < netA) return 'B';
            return 'halved';
        } else {
            // Singles: direct comparison (using match play strokes)
            const netA = getMatchNetScore(match, teamAIds[0], holeNum, holeScores[teamAIds[0]]);
            const netB = getMatchNetScore(match, teamBIds[0], holeNum, holeScores[teamBIds[0]]);
            if (netA === null || netB === null) return null;
            if (netA < netB) return 'A';
            if (netB < netA) return 'B';
            return 'halved';
        }
    }

    // ─────────────────────────────────────────────────────────
    // MATCH PLAY STATUS
    // ─────────────────────────────────────────────────────────
    function getMatchPlayStatus(match) {
        let score = 0; // positive = A leading
        let holesPlayed = 0;

        for (let h = 1; h <= 18; h++) {
            const winner = getHoleWinner(match, h);
            if (winner === 'A') { score++; holesPlayed++; }
            else if (winner === 'B') { score--; holesPlayed++; }
            else if (winner === 'halved') { holesPlayed++; }
            // null = not played or incomplete, stop counting consecutive
        }

        const holesRemaining = 18 - holesPlayed;
        const lead = Math.abs(score);
        const leader = score > 0 ? 'A' : score < 0 ? 'B' : null;
        const isDormie = lead > 0 && lead === holesRemaining;
        const isWon = lead > holesRemaining && holesPlayed > 0;
        const isFinished = holesPlayed === 18;
        const isComplete = match.status === 'complete' || isWon || isFinished;

        if (isComplete && isWon && holesPlayed < 18) {
            return { leader, text: `${lead} & ${holesRemaining}`, isComplete: true, holesPlayed, score, isDormie: false };
        } else if (isComplete && isFinished) {
            if (score === 0) return { leader: null, text: 'HALVED', isComplete: true, holesPlayed, score, isDormie: false };
            return { leader, text: `${lead} UP`, isComplete: true, holesPlayed, score, isDormie: false };
        } else if (holesPlayed === 0) {
            return { leader: null, text: '-', isComplete: false, holesPlayed: 0, score: 0, isDormie: false };
        } else {
            if (score === 0) return { leader: null, text: 'ALL SQUARE', isComplete: false, holesPlayed, score, isDormie };
            return { leader, text: `${lead} UP`, isComplete: false, holesPlayed, score, isDormie };
        }
    }

    function getMatchPoints(match) {
        const status = getMatchPlayStatus(match);
        if (!status.isComplete) return { A: 0, B: 0, settled: false };
        if (status.text === 'HALVED') return { A: 0.5, B: 0.5, settled: true };
        if (status.leader === 'A') return { A: 1, B: 0, settled: true };
        return { A: 0, B: 1, settled: true };
    }

    function getBonusEventPoints(sessionId) {
        let a = 0, b = 0;
        const sumAll = arguments.length === 0;
        Object.values(S.bonusEvents).forEach(evt => {
            if (sumAll) {
                a += (evt.pointsA || 0);
                b += (evt.pointsB || 0);
            } else if (sessionId === null) {
                if (!evt.sessionId) { a += (evt.pointsA || 0); b += (evt.pointsB || 0); }
            } else {
                if (evt.sessionId === sessionId) { a += (evt.pointsA || 0); b += (evt.pointsB || 0); }
            }
        });
        return { A: a, B: b };
    }

    function getTeamScores() {
        let a = 0, b = 0;
        Object.values(S.matches).forEach(m => {
            const pts = getMatchPoints(m);
            a += pts.A; b += pts.B;
        });
        const bonus = getBonusEventPoints();
        a += bonus.A; b += bonus.B;
        return { A: a, B: b };
    }

    function getSessionScores(sessionId) {
        let a = 0, b = 0;
        const matches = getMatchesBySession(sessionId);
        matches.forEach(m => {
            const pts = getMatchPoints(m);
            a += pts.A; b += pts.B;
        });
        const bonus = getBonusEventPoints(sessionId);
        a += bonus.A; b += bonus.B;
        return { A: a, B: b };
    }

    function getProjectedMatchPoints(match) {
        const status = getMatchPlayStatus(match);

        // If match is complete, return actual points
        if (status.isComplete) {
            return getMatchPoints(match);
        }

        // If no holes played yet, no projection
        if (status.holesPlayed === 0) {
            return { A: 0, B: 0, settled: false };
        }

        // Project based on current leader
        if (status.text === 'ALL SQUARE') {
            return { A: 0.5, B: 0.5, settled: false }; // Projected halved
        } else if (status.leader === 'A') {
            return { A: 1, B: 0, settled: false }; // Projected Team A win
        } else if (status.leader === 'B') {
            return { A: 0, B: 1, settled: false }; // Projected Team B win
        }

        return { A: 0, B: 0, settled: false };
    }

    function getProjectedTeamScores() {
        let a = 0, b = 0;
        let hasProjections = false;

        Object.values(S.matches).forEach(m => {
            const pts = getProjectedMatchPoints(m);
            a += pts.A;
            b += pts.B;
            if (!pts.settled) hasProjections = true;
        });

        const bonus = getBonusEventPoints();
        a += bonus.A; b += bonus.B;
        return { A: a, B: b, hasProjections };
    }

    // ─────────────────────────────────────────────────────────
    // INDIVIDUAL STATISTICS
    // ─────────────────────────────────────────────────────────
    const IndividualStats = {
        calculatePlayerStats(playerId, sessionId = null) {
            const matches = sessionId ?
                Object.values(S.matches).filter(m => m.sessionId === sessionId) :
                Object.values(S.matches);

            const stats = {
                playerId,
                playerName: getPlayerName(playerId),
                team: S.players[playerId]?.team,
                holesPlayed: 0,
                grossTotal: 0,
                netTotal: 0,
                birdiesGross: 0,
                birdiesNet: 0,
                eaglesGross: 0,
                eaglesNet: 0,
                parsGross: 0,
                parsNet: 0,
                bogeysGross: 0,
                bogeysNet: 0,
                doubleBogeysGross: 0,
                doubleBogeysNet: 0,
                bestHoleGross: null,
                bestHoleNet: null,
                worstHoleGross: null,
                worstHoleNet: null
            };

            // Find all matches this player participated in
            const playerMatches = matches.filter(m =>
                m.teamA.includes(playerId) || m.teamB.includes(playerId)
            );

            playerMatches.filter(m => m.type !== 'foursomes').forEach(match => {
                Object.keys(match.holes || {}).forEach(holeNum => {
                    const grossScore = match.holes[holeNum][playerId];
                    if (grossScore === undefined || grossScore === null) return;

                    const holeInfo = getHoleInfo(parseInt(holeNum));
                    const par = holeInfo.par;
                    const netScore = getNetScore(playerId, parseInt(holeNum), grossScore);

                    stats.holesPlayed++;
                    stats.grossTotal += grossScore;
                    stats.netTotal += netScore;

                    // Gross classification
                    const grossDiff = grossScore - par;
                    if (grossDiff <= -2) stats.eaglesGross++;
                    else if (grossDiff === -1) stats.birdiesGross++;
                    else if (grossDiff === 0) stats.parsGross++;
                    else if (grossDiff === 1) stats.bogeysGross++;
                    else stats.doubleBogeysGross++;

                    // Net classification
                    const netDiff = netScore - par;
                    if (netDiff <= -2) stats.eaglesNet++;
                    else if (netDiff === -1) stats.birdiesNet++;
                    else if (netDiff === 0) stats.parsNet++;
                    else if (netDiff === 1) stats.bogeysNet++;
                    else stats.doubleBogeysNet++;

                    // Track best/worst
                    if (stats.bestHoleGross === null || grossDiff < (stats.bestHoleGross.gross - stats.bestHoleGross.par)) {
                        stats.bestHoleGross = { hole: parseInt(holeNum), gross: grossScore, par };
                    }
                    if (stats.bestHoleNet === null || netDiff < (stats.bestHoleNet.net - stats.bestHoleNet.par)) {
                        stats.bestHoleNet = { hole: parseInt(holeNum), net: netScore, par };
                    }
                    if (stats.worstHoleGross === null || grossDiff > (stats.worstHoleGross.gross - stats.worstHoleGross.par)) {
                        stats.worstHoleGross = { hole: parseInt(holeNum), gross: grossScore, par };
                    }
                    if (stats.worstHoleNet === null || netDiff > (stats.worstHoleNet.net - stats.worstHoleNet.par)) {
                        stats.worstHoleNet = { hole: parseInt(holeNum), net: netScore, par };
                    }
                });
            });

            // Calculate averages
            stats.grossAverage = stats.holesPlayed > 0 ? (stats.grossTotal / stats.holesPlayed).toFixed(2) : '0.00';
            stats.netAverage = stats.holesPlayed > 0 ? (stats.netTotal / stats.holesPlayed).toFixed(2) : '0.00';

            return stats;
        },

        getAllPlayerStats(sessionId = null) {
            const allPlayers = Object.keys(S.players);
            return allPlayers
                .map(playerId => this.calculatePlayerStats(playerId, sessionId))
                .filter(stats => stats.holesPlayed > 0);
        },

        getBirdieLeaders(type = 'gross', sessionId = null) {
            const allStats = this.getAllPlayerStats(sessionId);
            const field = type === 'gross' ? 'birdiesGross' : 'birdiesNet';
            return allStats.sort((a, b) => b[field] - a[field]).slice(0, 10);
        },

        getEagleLeaders(type = 'gross', sessionId = null) {
            const allStats = this.getAllPlayerStats(sessionId);
            const field = type === 'gross' ? 'eaglesGross' : 'eaglesNet';
            return allStats
                .filter(s => s[field] > 0)
                .sort((a, b) => b[field] - a[field]);
        },

        getScoringLeaders(type = 'gross', sessionId = null) {
            const allStats = this.getAllPlayerStats(sessionId);
            const field = type === 'gross' ? 'grossAverage' : 'netAverage';
            return allStats
                .filter(s => s.holesPlayed >= 9) // Minimum 9 holes
                .sort((a, b) => parseFloat(a[field]) - parseFloat(b[field]))
                .slice(0, 10);
        },

        getPlayerRelativeToParBySession(playerId, sessionId) {
            const matches = Object.values(S.matches).filter(m =>
                m.sessionId === sessionId &&
                m.type !== 'foursomes' &&
                (m.teamA.includes(playerId) || m.teamB.includes(playerId))
            );
            let totalRelToPar = 0;
            let holesPlayed = 0;
            matches.forEach(match => {
                Object.keys(match.holes || {}).forEach(holeNum => {
                    const gross = match.holes[holeNum][playerId];
                    if (gross === undefined || gross === null) return;
                    const par = getHoleInfo(parseInt(holeNum)).par;
                    totalRelToPar += (gross - par);
                    holesPlayed++;
                });
            });
            return { totalRelToPar, holesPlayed };
        },

        getDailyScoresData() {
            const sessions = S.config.sessions.sort((a, b) => a.order - b.order);
            const allPlayers = Object.keys(S.players);
            const scoringSessions = sessions.filter(session =>
                getMatchesBySession(session.id).some(m => m.type !== 'foursomes')
            );
            const playerData = allPlayers.map(playerId => {
                const sessionScores = {};
                let overallRelToPar = 0;
                let overallHolesPlayed = 0;
                scoringSessions.forEach(session => {
                    const result = this.getPlayerRelativeToParBySession(playerId, session.id);
                    sessionScores[session.id] = result;
                    overallRelToPar += result.totalRelToPar;
                    overallHolesPlayed += result.holesPlayed;
                });
                return {
                    playerId,
                    playerName: getPlayerName(playerId),
                    team: S.players[playerId]?.team,
                    sessionScores,
                    overallRelToPar,
                    overallHolesPlayed,
                };
            }).filter(p => p.overallHolesPlayed > 0);
            playerData.sort((a, b) => a.overallRelToPar - b.overallRelToPar);
            return { scoringSessions, playerData };
        },

        getPointLeaders() {
            const allPlayers = Object.keys(S.players);
            const allMatches = Object.values(S.matches);
            const records = allPlayers.map(playerId => {
                let wins = 0, losses = 0, ties = 0;
                allMatches.forEach(match => {
                    const isTeamA = match.teamA.includes(playerId);
                    const isTeamB = match.teamB.includes(playerId);
                    if (!isTeamA && !isTeamB) return;
                    const points = getMatchPoints(match);
                    if (!points.settled) return;
                    const playerPoints = points[isTeamA ? 'A' : 'B'];
                    if (playerPoints === 1) wins++;
                    else if (playerPoints === 0.5) ties++;
                    else losses++;
                });
                return {
                    playerId,
                    playerName: getPlayerName(playerId),
                    team: S.players[playerId]?.team,
                    wins, losses, ties,
                    totalPoints: wins + (ties * 0.5),
                    matchesPlayed: wins + losses + ties,
                };
            }).filter(r => r.matchesPlayed > 0);
            records.sort((a, b) => b.totalPoints - a.totalPoints || b.wins - a.wins);
            return records;
        }
    };

    // ─────────────────────────────────────────────────────────
    // RENDER: LEADERBOARD
    // ─────────────────────────────────────────────────────────
    function renderLeaderboard() {
        const el = document.getElementById('leaderboard-content');
        const allMatches = Object.values(S.matches);

        if (allMatches.length === 0 && Object.keys(S.players).length === 0 && Object.keys(S.bonusEvents).length === 0) {
            el.innerHTML = `<div class="lb-empty"><img src="assets/images/Phone Size DFCG No Background.png" alt="DFGC" class="lb-empty-logo"><h3>Welcome to The Smashters</h3>
                <p>Add players in the <strong>Players</strong> tab to get started,<br>then set up matches in the <strong>Matches</strong> tab.</p></div>`;
            return;
        }

        const scores = getTeamScores();
        let html = '';

        // Loop through sessions dynamically
        const sessions = S.config.sessions.sort((a, b) => a.order - b.order);
        sessions.forEach((session, index) => {
            const matches = getMatchesBySession(session.id);
            const sessionBonuses = Object.values(S.bonusEvents)
                .filter(evt => evt.sessionId === session.id)
                .sort((a, b) => (a.order || 0) - (b.order || 0));

            if (matches.length > 0 || sessionBonuses.length > 0) {
                const formatLabel = {
                    fourball: 'Four Ball',
                    foursomes: 'Foursomes',
                    singles: 'Singles',
                    other: 'Other'
                }[session.format] || 'Match';

                html += `<div class="lb-board" ${index > 0 ? 'style="margin-top:16px;"' : ''}>`;
                html += `<div class="lb-section-header">${session.name} &mdash; ${formatLabel}</div>`;
                html += matches.map(m => renderLeaderboardMatch(m)).join('');
                sessionBonuses.forEach(evt => { html += renderLeaderboardBonusEvent(evt); });
                // Session subtotal row (mini totals bar)
                const sessScores = getSessionScores(session.id);
                html += `<div style="display:grid;grid-template-columns:1fr 36px 1fr;min-height:38px;">
                    <div style="display:flex;align-items:center;justify-content:flex-end;gap:8px;padding:6px 12px;background:${S.config.teamA.color};color:#fff;font-weight:700;">
                        <span style="font-size:0.65rem;text-transform:uppercase;letter-spacing:0.5px;opacity:0.9;">${S.config.teamA.name}</span>
                        <span style="font-size:1.15rem;font-family:'Trebuchet MS',sans-serif;font-weight:bold;">${formatScore(sessScores.A)}</span>
                    </div>
                    <div style="display:flex;align-items:center;justify-content:center;background:#4a4a4a;color:var(--masters-yellow);font-size:0.55rem;font-weight:600;">PTS</div>
                    <div style="display:flex;align-items:center;justify-content:flex-start;gap:8px;padding:6px 12px;background:${S.config.teamB.color};color:#fff;font-weight:700;">
                        <span style="font-size:1.15rem;font-family:'Trebuchet MS',sans-serif;font-weight:bold;">${formatScore(sessScores.B)}</span>
                        <span style="font-size:0.65rem;text-transform:uppercase;letter-spacing:0.5px;opacity:0.9;">${S.config.teamB.name}</span>
                    </div>
                </div>`;
                html += `</div>`;
            }
        });

        // Standalone bonus events (no session tie)
        const standaloneBonuses = Object.values(S.bonusEvents)
            .filter(evt => !evt.sessionId)
            .sort((a, b) => (a.order || 0) - (b.order || 0));
        if (standaloneBonuses.length > 0) {
            html += `<div class="lb-board" style="margin-top:16px;">`;
            html += `<div class="lb-section-header">Bonus Events</div>`;
            standaloneBonuses.forEach(evt => { html += renderLeaderboardBonusEvent(evt); });
            // Bonus events subtotal
            let bonusA = 0, bonusB = 0;
            standaloneBonuses.forEach(e => { bonusA += (e.pointsA || 0); bonusB += (e.pointsB || 0); });
            html += `<div style="display:grid;grid-template-columns:1fr 36px 1fr;min-height:38px;">
                <div style="display:flex;align-items:center;justify-content:flex-end;gap:8px;padding:6px 12px;background:${S.config.teamA.color};color:#fff;font-weight:700;">
                    <span style="font-size:0.65rem;text-transform:uppercase;letter-spacing:0.5px;opacity:0.9;">${S.config.teamA.name}</span>
                    <span style="font-size:1.15rem;font-family:'Trebuchet MS',sans-serif;font-weight:bold;">${formatScore(bonusA)}</span>
                </div>
                <div style="display:flex;align-items:center;justify-content:center;background:#4a4a4a;color:var(--masters-yellow);font-size:0.55rem;font-weight:600;">PTS</div>
                <div style="display:flex;align-items:center;justify-content:flex-start;gap:8px;padding:6px 12px;background:${S.config.teamB.color};color:#fff;font-weight:700;">
                    <span style="font-size:1.15rem;font-family:'Trebuchet MS',sans-serif;font-weight:bold;">${formatScore(bonusB)}</span>
                    <span style="font-size:0.65rem;text-transform:uppercase;letter-spacing:0.5px;opacity:0.9;">${S.config.teamB.name}</span>
                </div>
            </div>`;
            html += `</div>`;
        }

        // Build session subtotals breakdown
        let sessionBreakdownA = '';
        let sessionBreakdownB = '';
        let breakdownParts = 0;
        sessions.forEach(session => {
            const matches = getMatchesBySession(session.id);
            const sessionBonuses = Object.values(S.bonusEvents).filter(evt => evt.sessionId === session.id);
            if (matches.length > 0 || sessionBonuses.length > 0) {
                const sessionScores = getSessionScores(session.id);
                sessionBreakdownA += `${breakdownParts > 0 ? ' | ' : ''}${session.name}: ${formatScore(sessionScores.A)}`;
                sessionBreakdownB += `${breakdownParts > 0 ? ' | ' : ''}${session.name}: ${formatScore(sessionScores.B)}`;
                breakdownParts++;
            }
        });
        // Add standalone bonus subtotal
        let standaloneA = 0, standaloneB = 0;
        Object.values(S.bonusEvents).filter(e => !e.sessionId).forEach(e => {
            standaloneA += (e.pointsA || 0);
            standaloneB += (e.pointsB || 0);
        });
        if (standaloneA > 0 || standaloneB > 0) {
            sessionBreakdownA += `${breakdownParts > 0 ? ' | ' : ''}Bonus: ${formatScore(standaloneA)}`;
            sessionBreakdownB += `${breakdownParts > 0 ? ' | ' : ''}Bonus: ${formatScore(standaloneB)}`;
        }

        // Get projected scores
        const projected = getProjectedTeamScores();
        const showProjected = projected.hasProjections && (projected.A !== scores.A || projected.B !== scores.B);

        // Team totals bar with subtotals and projections
        html += `
            <div class="lb-board" style="margin-top:16px;">
                <div class="lb-section-header">Event Totals</div>
                <div class="lb-totals-row">
                    <div class="lb-totals-a">
                        <span class="lb-total-team-name">${S.config.teamA.name}</span>
                        <span class="lb-total-pts">${formatScore(scores.A)}</span>
                    </div>
                    <div class="lb-totals-center">
                        <img src="assets/images/smashters-logo-green.png" alt="" style="filter:brightness(0) invert(1);">
                    </div>
                    <div class="lb-totals-b">
                        <span class="lb-total-pts">${formatScore(scores.B)}</span>
                        <span class="lb-total-team-name">${S.config.teamB.name}</span>
                    </div>
                </div>`;

        // Session breakdown row
        if (sessionBreakdownA && sessionBreakdownB) {
            html += `
                <div class="lb-breakdown-row">
                    <div class="lb-breakdown-side">${sessionBreakdownA}</div>
                    <div class="lb-breakdown-side">${sessionBreakdownB}</div>
                </div>`;
        }

        // Projected totals row (if matches in progress)
        if (showProjected) {
            html += `
                <div class="lb-projected-row">
                    <div class="lb-projected-side">
                        <span class="lb-projected-label">Projected:</span>
                        <span class="lb-projected-value">${formatScore(projected.A)}</span>
                    </div>
                    <div class="lb-projected-side">
                        <span class="lb-projected-value">${formatScore(projected.B)}</span>
                        <span class="lb-projected-label">Projected:</span>
                    </div>
                </div>`;
        }

        html += `</div>`;

        if (allMatches.length === 0) {
            html += `<div class="empty-state mt-16"><p>No matches set up yet. Head to the <strong>Matches</strong> tab to create pairings.</p></div>`;
        } else {
            // Share Results button removed for now
        }


        el.innerHTML = html;
    }

    function enableScoring() {
        const code = prompt('Enter scorer code:');
        if (code === '6969') {
            LiveSync.isScorer = true;
            LiveSync.scorerMatchId = null; // Can score all matches
            LiveSync.updateBanner();
            showToast('Scoring enabled!');
            switchTab('scoring');
        } else {
            showToast('Incorrect scorer code');
        }
    }

    function renderLeaderboardMatch(match) {
        const status = getMatchPlayStatus(match);
        // Keep each player name together, only allow breaking at separator
        const teamANames = match.teamA.map(id => `<span style="white-space:nowrap;">${getPlayerName(id)}</span>`).join(' / ');
        const teamBNames = match.teamB.map(id => `<span style="white-space:nowrap;">${getPlayerName(id)}</span>`).join(' / ');
        const isALeading = status.leader === 'A';
        const isBLeading = status.leader === 'B';
        const isTied = status.text === 'ALL SQUARE' || status.text === 'HALVED';
        const isPending = status.holesPlayed === 0;

        // Thru / Final indicator for center column
        const thru = isPending ? '' :
            status.isComplete ? 'F' : status.holesPlayed;

        // Cell state classes
        let cellAClass = 'pending', cellBClass = 'pending';
        if (isPending) {
            cellAClass = 'pending'; cellBClass = 'pending';
        } else if (isTied) {
            cellAClass = 'tied'; cellBClass = 'tied';
        } else if (isALeading) {
            cellAClass = 'leading'; cellBClass = 'tied';
        } else if (isBLeading) {
            cellAClass = 'tied'; cellBClass = 'leading';
        }

        // Score text goes on the leading team's side
        // For tied/halved it shows on both sides
        let scoreA = '', scoreB = '';
        if (isPending) {
            // nothing
        } else if (isTied) {
            const label = status.isComplete ? 'Tied' : 'Tied';
            scoreA = label;
            scoreB = label;
        } else if (isALeading) {
            scoreA = status.text;
        } else if (isBLeading) {
            scoreB = status.text;
        }

        return `
            <div class="lb-match-row">
                <div class="lb-cell-a ${cellAClass}">
                    ${scoreA ? `<span class="lb-match-score">${scoreA}</span>` : ''}
                    <span class="lb-player-name">${teamANames}</span>
                </div>
                <div class="lb-cell-thru">${thru}</div>
                <div class="lb-cell-b ${cellBClass}">
                    <span class="lb-player-name">${teamBNames}</span>
                    ${scoreB ? `<span class="lb-match-score">${scoreB}</span>` : ''}
                </div>
            </div>`;
    }

    function renderLeaderboardBonusEvent(evt) {
        const ptsA = evt.pointsA || 0;
        const ptsB = evt.pointsB || 0;
        const isALeading = ptsA > ptsB;
        const isBLeading = ptsB > ptsA;

        let cellAClass = 'tied', cellBClass = 'tied';
        if (isALeading) { cellAClass = 'leading'; }
        else if (isBLeading) { cellBClass = 'leading'; }

        const notesAHtml = evt.notesA ? `<span style="display:block;font-size:0.65rem;color:#888;margin-top:1px;">${evt.notesA}</span>` : '';
        const notesBHtml = evt.notesB ? `<span style="display:block;font-size:0.65rem;color:#888;margin-top:1px;">${evt.notesB}</span>` : '';

        return `
            <div style="background:#4a4a4a;color:var(--masters-cream);padding:6px 16px;font-family:'Trebuchet MS','Helvetica Neue',Arial,sans-serif;font-size:0.75rem;font-weight:bold;letter-spacing:0.5px;text-transform:uppercase;">${evt.name}</div>
            <div class="lb-match-row">
                <div class="lb-cell-a ${cellAClass}">
                    ${ptsA > 0 ? `<span class="lb-match-score">${formatScore(ptsA)}</span>` : ''}
                    <span class="lb-player-name">${S.config.teamA.name}${notesAHtml}</span>
                </div>
                <div class="lb-cell-thru" style="font-size:0.6rem;">&#9733;</div>
                <div class="lb-cell-b ${cellBClass}">
                    <span class="lb-player-name">${S.config.teamB.name}${notesBHtml}</span>
                    ${ptsB > 0 ? `<span class="lb-match-score">${formatScore(ptsB)}</span>` : ''}
                </div>
            </div>`;
    }

    function renderFoursomesScoreRow(match, teamIds, holeNum, holeScores, holeInfo, teamLetter) {
        // Get player names
        const names = teamIds.map(id => getPlayer(id)?.name || 'Unknown').join(' / ');

        // Get team handicap and strokes
        const teamHcp = getTeamHandicap(teamIds);
        const teamStrokes = getAlternateShotStrokes(match);
        const matchPlayHcp = teamLetter === 'A' ? teamStrokes.teamA : teamStrokes.teamB;
        const strokesReceived = S.config.useHandicaps ? getStrokesOnHole(matchPlayHcp, holeInfo.hcp) : 0;

        // Score stored under first player
        const scorePlayerId = teamIds[0];
        const grossScore = holeScores[scorePlayerId];
        const hasScore = grossScore !== undefined && grossScore !== null;
        const par = holeInfo.par;

        // Score display class
        let scoreClass = 'no-score';
        let vsParText = '';
        if (hasScore) {
            const diff = grossScore - par;
            if (diff <= -2) { scoreClass = 'eagle'; vsParText = diff; }
            else if (diff === -1) { scoreClass = 'birdie'; vsParText = '-1'; }
            else if (diff === 0) { scoreClass = ''; vsParText = 'E'; }
            else if (diff === 1) { scoreClass = 'bogey'; vsParText = '+1'; }
            else { scoreClass = 'double-bogey'; vsParText = '+' + diff; }
        }

        const displayScore = hasScore ? grossScore : '-';
        const strokeDots = strokesReceived > 0 ? ' <span style="color:var(--masters-red);font-size:0.7rem;">' + '\u25CF'.repeat(strokesReceived) + '</span>' : '';

        // Show team handicap and match play handicap
        const hcpDisplay = matchPlayHcp !== teamHcp && matchPlayHcp > 0
            ? `Team HCP ${teamHcp} (${matchPlayHcp})`
            : `Team HCP ${teamHcp}`;

        return `
            <div class="score-entry-row">
                <div class="score-entry-name">
                    ${names}${strokeDots}
                    <span class="hcp-badge">${hcpDisplay}</span>
                </div>
                <div class="score-entry-controls">
                    <button class="score-adj-btn" onclick="adjustScore('${scorePlayerId}', ${holeNum}, -1)">&minus;</button>
                    <div class="score-value-display ${scoreClass}">
                        ${displayScore}
                        ${vsParText ? `<span class="score-vs-par">${vsParText}</span>` : ''}
                    </div>
                    <button class="score-adj-btn" onclick="adjustScore('${scorePlayerId}', ${holeNum}, 1)">+</button>
                </div>
            </div>`;
    }

    // ─────────────────────────────────────────────────────────
    // RENDER: INDIVIDUAL STATS
    // ─────────────────────────────────────────────────────────
    function renderIndividual() {
        const el = document.getElementById('individual-content');

        // Tab selector for different views
        const selectedView = S.ui.individualView || 'points';
        const selectedType = S.ui.individualType || 'gross';
        const selectedSession = S.ui.individualSession || 'all';

        const sessions = S.config.sessions.sort((a, b) => a.order - b.order);

        let html = `<h2 class="section-title">Individual Performance</h2>`;

        // View selector
        html += `<div style="display:flex;gap:8px;margin-bottom:16px;flex-wrap:wrap;">
            <button class="btn ${selectedView === 'points' ? 'btn-primary' : 'btn-outline'} btn-sm"
                onclick="setIndividualView('points')">Point Leaders</button>
            <button class="btn ${selectedView === 'daily' ? 'btn-primary' : 'btn-outline'} btn-sm"
                onclick="setIndividualView('daily')">Daily Scores</button>
            <button class="btn ${selectedView === 'stats' ? 'btn-primary' : 'btn-outline'} btn-sm"
                onclick="setIndividualView('stats')">Stats</button>
        </div>`;

        // Gross/Net and Session filter — only for stats view
        if (selectedView === 'stats') {
            html += `<div style="display:flex;gap:8px;margin-bottom:16px;">
                <button class="btn ${selectedType === 'gross' ? 'btn-gold' : 'btn-outline'} btn-sm"
                    onclick="setIndividualType('gross')">Gross</button>
                <button class="btn ${selectedType === 'net' ? 'btn-gold' : 'btn-outline'} btn-sm"
                    onclick="setIndividualType('net')">Net</button>
            </div>`;

            html += `<div style="margin-bottom:16px;">
                <select class="form-input" onchange="setIndividualSession(this.value)" style="width:auto;">
                    <option value="all" ${selectedSession === 'all' ? 'selected' : ''}>All Sessions</option>
                    ${sessions.map(s => `<option value="${s.id}" ${selectedSession === s.id ? 'selected' : ''}>${s.name}</option>`).join('')}
                </select>
            </div>`;
        }

        // Render selected view
        const sessionFilter = selectedSession === 'all' ? null : selectedSession;

        if (selectedView === 'points') {
            html += renderPointLeaders();
        } else if (selectedView === 'daily') {
            html += renderDailyScoresRelToPar();
        } else if (selectedView === 'stats') {
            html += renderAllStats(selectedType, sessionFilter);
        }


        el.innerHTML = html;
    }

    function setIndividualView(view) {
        S.ui.individualView = view;
        saveState();
        renderIndividual();
    }

    function setIndividualType(type) {
        S.ui.individualType = type;
        saveState();
        renderIndividual();
    }

    function setIndividualSession(sessionId) {
        S.ui.individualSession = sessionId;
        saveState();
        renderIndividual();
    }

    function renderDailyScores(type, sessionId) {
        const allStats = IndividualStats.getAllPlayerStats(sessionId);
        if (allStats.length === 0) {
            return `<div class="empty-state"><h3>No Scores Yet</h3><p>Scores will appear here once matches are played.</p></div>`;
        }

        const field = type === 'gross' ? 'grossTotal' : 'netTotal';
        const avgField = type === 'gross' ? 'grossAverage' : 'netAverage';
        const sorted = allStats.sort((a, b) => parseFloat(a[avgField]) - parseFloat(b[avgField]));

        let html = `<div class="lb-board">
            <div class="lb-section-header">Daily Scoring - ${type === 'gross' ? 'Gross' : 'Net'}</div>
            <div style="padding:12px;overflow-x:auto;">
                <table style="width:100%;border-collapse:collapse;">
                    <thead>
                        <tr style="border-bottom:2px solid #ddd;">
                            <th style="padding:8px;text-align:left;font-weight:600;">Rank</th>
                            <th style="padding:8px;text-align:left;font-weight:600;">Player</th>
                            <th style="padding:8px;text-align:center;font-weight:600;">Holes</th>
                            <th style="padding:8px;text-align:center;font-weight:600;">Total</th>
                            <th style="padding:8px;text-align:center;font-weight:600;">Avg</th>
                        </tr>
                    </thead>
                    <tbody>`;

        sorted.forEach((stats, i) => {
            const teamColor = stats.team === 'A' ? S.config.teamA.color : stats.team === 'B' ? S.config.teamB.color : '#666';
            html += `<tr style="border-bottom:1px solid #eee;">
                <td style="padding:8px;">${i + 1}</td>
                <td style="padding:8px;">
                    <span style="color:${teamColor};font-weight:bold;">${stats.playerName}</span>
                </td>
                <td style="padding:8px;text-align:center;">${stats.holesPlayed}</td>
                <td style="padding:8px;text-align:center;font-weight:bold;">${stats[field]}</td>
                <td style="padding:8px;text-align:center;font-weight:bold;">${stats[avgField]}</td>
            </tr>`;
        });

        return html + '</tbody></table></div></div>';
    }

    function renderBirdieLeaders(type, sessionId) {
        const leaders = IndividualStats.getBirdieLeaders(type, sessionId);
        const field = type === 'gross' ? 'birdiesGross' : 'birdiesNet';

        if (leaders.length === 0 || leaders.every(s => s[field] === 0)) {
            return `<div class="empty-state"><h3>No Birdies Yet</h3><p>Birdie leaders will appear here once scored.</p></div>`;
        }

        let html = `<div class="lb-board">
            <div class="lb-section-header">🔥 Birdie Leaders - ${type === 'gross' ? 'Gross' : 'Net'}</div>
            <div style="padding:12px;overflow-x:auto;">
                <table style="width:100%;border-collapse:collapse;">
                    <thead>
                        <tr style="border-bottom:2px solid #ddd;">
                            <th style="padding:8px;text-align:left;font-weight:600;">Rank</th>
                            <th style="padding:8px;text-align:left;font-weight:600;">Player</th>
                            <th style="padding:8px;text-align:center;font-weight:600;">Birdies</th>
                            <th style="padding:8px;text-align:center;font-weight:600;">Holes Played</th>
                        </tr>
                    </thead>
                    <tbody>`;

        leaders.forEach((stats, i) => {
            if (stats[field] === 0) return;
            const teamColor = stats.team === 'A' ? S.config.teamA.color : stats.team === 'B' ? S.config.teamB.color : '#666';
            const birdieRate = ((stats[field] / stats.holesPlayed) * 100).toFixed(1);

            html += `<tr style="border-bottom:1px solid #eee;">
                <td style="padding:8px;">${i + 1}</td>
                <td style="padding:8px;">
                    <span style="color:${teamColor};font-weight:bold;">${stats.playerName}</span>
                </td>
                <td style="padding:8px;text-align:center;font-size:1.2em;font-weight:bold;color:var(--birdie-color);">
                    ${stats[field]}
                </td>
                <td style="padding:8px;text-align:center;">${stats.holesPlayed} (${birdieRate}%)</td>
            </tr>`;
        });

        return html + '</tbody></table></div></div>';
    }

    function renderEagleLeaders(type, sessionId) {
        const leaders = IndividualStats.getEagleLeaders(type, sessionId);
        const field = type === 'gross' ? 'eaglesGross' : 'eaglesNet';

        if (leaders.length === 0) {
            return `<div class="empty-state"><h3>No Eagles Yet</h3><p>Eagle leaders will appear here once scored.</p></div>`;
        }

        let html = `<div class="lb-board">
            <div class="lb-section-header">🦅 Eagle Leaders - ${type === 'gross' ? 'Gross' : 'Net'}</div>
            <div style="padding:12px;overflow-x:auto;">
                <table style="width:100%;border-collapse:collapse;">
                    <thead>
                        <tr style="border-bottom:2px solid #ddd;">
                            <th style="padding:8px;text-align:left;font-weight:600;">Rank</th>
                            <th style="padding:8px;text-align:left;font-weight:600;">Player</th>
                            <th style="padding:8px;text-align:center;font-weight:600;">Eagles</th>
                            <th style="padding:8px;text-align:center;font-weight:600;">Holes Played</th>
                        </tr>
                    </thead>
                    <tbody>`;

        leaders.forEach((stats, i) => {
            const teamColor = stats.team === 'A' ? S.config.teamA.color : stats.team === 'B' ? S.config.teamB.color : '#666';

            html += `<tr style="border-bottom:1px solid #eee;">
                <td style="padding:8px;">${i + 1}</td>
                <td style="padding:8px;">
                    <span style="color:${teamColor};font-weight:bold;">${stats.playerName}</span>
                </td>
                <td style="padding:8px;text-align:center;font-size:1.2em;font-weight:bold;color:var(--eagle-color);">
                    ${stats[field]}
                </td>
                <td style="padding:8px;text-align:center;">${stats.holesPlayed}</td>
            </tr>`;
        });

        return html + '</tbody></table></div></div>';
    }

    function renderScoringAverage(type, sessionId) {
        const leaders = IndividualStats.getScoringLeaders(type, sessionId);
        const avgField = type === 'gross' ? 'grossAverage' : 'netAverage';

        if (leaders.length === 0) {
            return `<div class="empty-state"><h3>Not Enough Data</h3><p>Scoring averages require at least 9 holes played.</p></div>`;
        }

        let html = `<div class="lb-board">
            <div class="lb-section-header">Scoring Average - ${type === 'gross' ? 'Gross' : 'Net'} (min. 9 holes)</div>
            <div style="padding:12px;overflow-x:auto;">
                <table style="width:100%;border-collapse:collapse;">
                    <thead>
                        <tr style="border-bottom:2px solid #ddd;">
                            <th style="padding:8px;text-align:left;font-weight:600;">Rank</th>
                            <th style="padding:8px;text-align:left;font-weight:600;">Player</th>
                            <th style="padding:8px;text-align:center;font-weight:600;">Average</th>
                            <th style="padding:8px;text-align:center;font-weight:600;">Holes</th>
                        </tr>
                    </thead>
                    <tbody>`;

        leaders.forEach((stats, i) => {
            const teamColor = stats.team === 'A' ? S.config.teamA.color : stats.team === 'B' ? S.config.teamB.color : '#666';

            html += `<tr style="border-bottom:1px solid #eee;">
                <td style="padding:8px;">${i + 1}</td>
                <td style="padding:8px;">
                    <span style="color:${teamColor};font-weight:bold;">${stats.playerName}</span>
                </td>
                <td style="padding:8px;text-align:center;font-size:1.1em;font-weight:bold;">
                    ${stats[avgField]}
                </td>
                <td style="padding:8px;text-align:center;">${stats.holesPlayed}</td>
            </tr>`;
        });

        return html + '</tbody></table></div></div>';
    }

    function renderAllStats(type, sessionId) {
        const allStats = IndividualStats.getAllPlayerStats(sessionId);
        if (allStats.length === 0) {
            return `<div class="empty-state"><h3>No Stats Yet</h3><p>Statistics will appear here once matches are played.</p></div>`;
        }

        const sorted = allStats.sort((a, b) => a.playerName.localeCompare(b.playerName));

        const birdieField = type === 'gross' ? 'birdiesGross' : 'birdiesNet';
        const eagleField = type === 'gross' ? 'eaglesGross' : 'eaglesNet';
        const parField = type === 'gross' ? 'parsGross' : 'parsNet';
        const bogeyField = type === 'gross' ? 'bogeysGross' : 'bogeysNet';
        const dblBogeyField = type === 'gross' ? 'doubleBogeysGross' : 'doubleBogeysNet';
        const totalField = type === 'gross' ? 'grossTotal' : 'netTotal';

        let html = `<div class="lb-board">
            <div class="lb-section-header">Player Statistics - ${type === 'gross' ? 'Gross' : 'Net'}</div>
            <div style="padding:12px;overflow-x:auto;">
                <table style="width:100%;border-collapse:collapse;font-size:0.85em;">
                    <thead>
                        <tr style="border-bottom:2px solid #ddd;">
                            <th style="padding:6px;text-align:left;font-weight:600;">Player</th>
                            <th style="padding:6px;text-align:center;font-weight:600;">Holes</th>
                            <th style="padding:6px;text-align:center;font-weight:600;">Avg</th>
                            <th style="padding:6px;text-align:center;font-weight:600;">🦅</th>
                            <th style="padding:6px;text-align:center;font-weight:600;">🔥</th>
                            <th style="padding:6px;text-align:center;font-weight:600;">Pars</th>
                            <th style="padding:6px;text-align:center;font-weight:600;">Bogey</th>
                            <th style="padding:6px;text-align:center;font-weight:600;">Bogey+</th>
                        </tr>
                    </thead>
                    <tbody>`;

        sorted.forEach(stats => {
            const teamColor = stats.team === 'A' ? S.config.teamA.color : stats.team === 'B' ? S.config.teamB.color : '#666';
            // Scoring average for a full 18-hole round
            const roundAvg = stats.holesPlayed >= 9 ? ((stats[totalField] / stats.holesPlayed) * 18).toFixed(1) : '-';

            html += `<tr style="border-bottom:1px solid #eee;">
                <td style="padding:6px;">
                    <span style="color:${teamColor};font-weight:bold;">${stats.playerName}</span>
                </td>
                <td style="padding:6px;text-align:center;">${stats.holesPlayed}</td>
                <td style="padding:6px;text-align:center;font-weight:bold;">${roundAvg}</td>
                <td style="padding:6px;text-align:center;">${stats[eagleField] || '-'}</td>
                <td style="padding:6px;text-align:center;">${stats[birdieField] || '-'}</td>
                <td style="padding:6px;text-align:center;">${stats[parField] || '-'}</td>
                <td style="padding:6px;text-align:center;">${stats[bogeyField] || '-'}</td>
                <td style="padding:6px;text-align:center;">${stats[dblBogeyField] || '-'}</td>
            </tr>`;
        });

        return html + '</tbody></table></div></div>';
    }

    function renderPointLeaders() {
        const leaders = IndividualStats.getPointLeaders();
        if (leaders.length === 0) {
            return `<div class="empty-state"><h3>No Completed Matches</h3><p>Point standings will appear once matches are completed.</p></div>`;
        }
        let html = `<div class="lb-board">
            <div class="lb-section-header">Point Leaders</div>
            <div style="padding:12px;overflow-x:auto;">
                <table style="width:100%;border-collapse:collapse;">
                    <thead><tr style="border-bottom:2px solid #ddd;">
                        <th style="padding:8px 6px;text-align:center;font-weight:600;width:36px;">#</th>
                        <th style="padding:8px;text-align:left;font-weight:600;">Player</th>
                        <th style="padding:8px;text-align:center;font-weight:600;">Record</th>
                        <th style="padding:8px;text-align:center;font-weight:600;">Pts</th>
                    </tr></thead><tbody>`;
        leaders.forEach((r, i) => {
            const tc = r.team === 'A' ? S.config.teamA.color : r.team === 'B' ? S.config.teamB.color : '#666';
            html += `<tr style="border-bottom:1px solid #eee;">
                <td style="padding:8px 6px;text-align:center;color:#999;">${i + 1}</td>
                <td style="padding:8px;"><span style="color:${tc};font-weight:bold;">${r.playerName}</span></td>
                <td style="padding:8px;text-align:center;font-weight:bold;">${r.wins}-${r.losses}-${r.ties}</td>
                <td style="padding:8px;text-align:center;font-size:1.1em;font-weight:bold;">${formatScore(r.totalPoints)}</td>
            </tr>`;
        });
        return html + '</tbody></table></div></div>';
    }

    function renderDailyScoresRelToPar() {
        const { scoringSessions, playerData } = IndividualStats.getDailyScoresData();
        if (playerData.length === 0) {
            return `<div class="empty-state"><h3>No Scores Yet</h3><p>Scores will appear here once matches are played.</p></div>`;
        }
        function fmtRelPar(val) { return val === 0 ? 'E' : val > 0 ? '+' + val : '' + val; }
        function fmtThru(h) { return h === 0 ? '-' : h >= 18 ? 'F' : h; }
        function scoreStyle(val) {
            if (val < 0) return 'color:#d32f2f;font-weight:bold;';
            if (val > 0) return 'color:#666;font-weight:bold;';
            return 'font-weight:bold;';
        }
        const multi = scoringSessions.length > 1;
        let html = `<div class="lb-board">
            <div class="lb-section-header">Daily Scores</div>
            <div style="padding:12px;overflow-x:auto;">
                <table style="width:100%;border-collapse:collapse;font-size:0.85em;">
                    <thead><tr style="border-bottom:2px solid #ddd;">
                        <th style="padding:6px 8px;text-align:left;font-weight:600;">Player</th>`;
        scoringSessions.forEach(s => {
            html += `<th style="padding:6px 4px;text-align:center;font-weight:600;font-size:0.85em;">${s.name}</th>`;
            html += `<th style="padding:6px 4px;text-align:center;font-weight:400;font-size:0.7em;color:#999;">Thru</th>`;
        });
        if (multi) {
            html += `<th style="padding:6px 8px;text-align:center;font-weight:700;">Total</th>`;
            html += `<th style="padding:6px 4px;text-align:center;font-weight:400;font-size:0.7em;color:#999;">Thru</th>`;
        }
        html += '</tr></thead><tbody>';
        playerData.forEach(p => {
            const tc = p.team === 'A' ? S.config.teamA.color : p.team === 'B' ? S.config.teamB.color : '#666';
            html += `<tr style="border-bottom:1px solid #eee;">
                <td style="padding:6px 8px;white-space:nowrap;"><span style="color:${tc};font-weight:bold;">${p.playerName}</span></td>`;
            scoringSessions.forEach(s => {
                const sd = p.sessionScores[s.id];
                if (sd && sd.holesPlayed > 0) {
                    html += `<td style="padding:6px 4px;text-align:center;${scoreStyle(sd.totalRelToPar)}">${fmtRelPar(sd.totalRelToPar)}</td>`;
                    html += `<td style="padding:6px 4px;text-align:center;font-size:0.8em;color:#888;">${fmtThru(sd.holesPlayed)}</td>`;
                } else {
                    html += `<td style="padding:6px 4px;text-align:center;color:#ccc;">-</td><td style="padding:6px 4px;text-align:center;color:#ccc;">-</td>`;
                }
            });
            if (multi) {
                html += `<td style="padding:6px 8px;text-align:center;font-size:1.05em;${scoreStyle(p.overallRelToPar)}">${fmtRelPar(p.overallRelToPar)}</td>`;
                html += `<td style="padding:6px 4px;text-align:center;font-size:0.8em;color:#888;">${fmtThru(p.overallHolesPlayed)}</td>`;
            }
            html += '</tr>';
        });
        return html + '</tbody></table></div></div>';
    }

    // ─────────────────────────────────────────────────────────
    // RENDER: SCORING
    // ─────────────────────────────────────────────────────────
    function renderScoring() {
        const el = document.getElementById('scoring-content');

        try {
            if (Object.keys(S.matches).length === 0) {
                el.innerHTML = `<div class="empty-state"><h3>No Matches Yet</h3><p>Set up matches first in the Matches tab.</p></div>`;
                return;
            }

            // Check if user needs to enable scoring
            if (!LiveSync.isAdmin && !LiveSync.isScorer) {
                el.innerHTML = `
                    <h2 class="section-title">Live Scoring</h2>
                    <div class="empty-state">
                        <h3>Scorer Authentication Required</h3>
                        <p>Enter the scorer code to enable scoring for all matches.</p>
                        <button class="btn btn-primary" onclick="enableScoring()" style="margin-top:16px;">Enable Scoring</button>
                    </div>`;
                return;
            }

            let html = '';

            // Clear invalid activeMatchId if match no longer exists
            if (S.ui.activeMatchId && !S.matches[S.ui.activeMatchId]) {
                console.warn('Clearing invalid activeMatchId:', S.ui.activeMatchId);
                S.ui.activeMatchId = null;
                saveState();
            }

            // In scorer mode with a specific match, only show that match
            // If scorerMatchId is null, show all matches (all-scorer role)
            const allMatches = (LiveSync.isScorer && LiveSync.scorerMatchId !== null)
                ? Object.values(S.matches).filter(m => m.id === LiveSync.scorerMatchId)
                : Object.values(S.matches);

        // Initialize scoring session filter if not set
        if (!S.ui.scoringSessionFilter) {
            S.ui.scoringSessionFilter = S.config.sessions[0]?.id || null;
        }

        // Group matches by session
        const sessions = S.config.sessions.sort((a, b) => a.order - b.order);
        const sessionsWithMatches = sessions.filter(session =>
            allMatches.some(m => m.sessionId === session.id)
        );
        const hasMultipleSessions = sessionsWithMatches.length > 1;

        // Session filter tabs (only show if multiple sessions have matches)
        if (hasMultipleSessions) {
            html += `<div style="display:flex;gap:6px;margin-bottom:12px;flex-wrap:wrap;">`;
            sessionsWithMatches.forEach(session => {
                html += `<button class="btn ${S.ui.scoringSessionFilter === session.id ? 'btn-primary' : 'btn-outline'}"
                        onclick="setScoringSessionFilter('${session.id}')" style="flex:1;padding:6px 12px;font-size:0.85rem;">${session.name}</button>`;
            });
            html += `</div>`;
        }

        // Filter matches based on selected session
        const matchesToShow = hasMultipleSessions
            ? allMatches.filter(m => m.sessionId === S.ui.scoringSessionFilter)
            : allMatches;

        // Match selector - dropdown for better mobile UX
        html += '<div style="margin-bottom:16px;">';
        html += '<label class="form-group"><strong>Select Match:</strong></label>';
        html += '<select class="form-input" onchange="selectScoringMatch(this.value)" style="width:100%;font-size:0.9rem;">';
        html += '<option value="">-- Choose a match --</option>';
        matchesToShow.forEach(m => {
            const teamANames = m.teamA.map(id => getPlayerName(id)).join(' / ');
            const teamBNames = m.teamB.map(id => getPlayerName(id)).join(' / ');
            const status = getMatchPlayStatus(m);
            const isSelected = S.ui.activeMatchId === m.id;
            const canEdit = LiveSync.canScore(m.id);
            const viewLabel = !canEdit && !LiveSync.isAdmin ? '(view) ' : '';
            const statusText = `${viewLabel}${status.text}${status.holesPlayed > 0 ? ' • Thru ' + status.holesPlayed : ''}`;
            html += `<option value="${m.id}" ${isSelected ? 'selected' : ''}>${teamANames} vs ${teamBNames} - ${statusText}</option>`;
        });
        html += '</select>';
        html += '</div>';

            if (S.ui.activeMatchId && S.matches[S.ui.activeMatchId]) {
                html += renderScoringInterface(S.matches[S.ui.activeMatchId]);
            }

    
            el.innerHTML = html;
        } catch (error) {
            console.error('Scoring render error:', error);
            el.innerHTML = `
                <div class="empty-state">
                    <h3>Error Loading Scoring</h3>
                    <p>An error occurred while loading the scoring interface. Please try refreshing the page.</p>
                    <button class="btn btn-primary" onclick="window.location.reload()" style="margin-top:16px;">Refresh Page</button>
                    <p style="margin-top:16px;font-size:0.85rem;color:#666;">Error: ${error.message}</p>
                </div>`;
        }
    }

    function renderScoringInterface(match) {
        try {
            const status = getMatchPlayStatus(match);
            const hole = S.ui.scoringHole || 1;
            const holeInfo = getHoleInfo(hole);
            const holeScores = match.holes[hole] || {};
            const allPlayers = [...match.teamA, ...match.teamB];
            const holeWinner = getHoleWinner(match, hole);

        let statusText = status.text;
        if (status.leader === 'A') statusText = `${S.config.teamA.name} ${status.text}`;
        else if (status.leader === 'B') statusText = `${S.config.teamB.name} ${status.text}`;

        // Build player score entry rows
        let teamARows, teamBRows;
        if (match.type === 'foursomes') {
            // Foursomes: one score per team (stored under first player)
            teamARows = renderFoursomesScoreRow(match, match.teamA, hole, holeScores, holeInfo, 'A');
            teamBRows = renderFoursomesScoreRow(match, match.teamB, hole, holeScores, holeInfo, 'B');
        } else {
            // Four Ball or Singles: individual score rows
            teamARows = match.teamA.map(id => renderScoreEntryRow(match, id, hole, holeScores, holeInfo)).join('');
            teamBRows = match.teamB.map(id => renderScoreEntryRow(match, id, hole, holeScores, holeInfo)).join('');
        }

        // Best ball values for four-ball (inline with team labels)
        let bestBallA = '', bestBallB = '';
        if (match.type === 'fourball') {
            const aNets = match.teamA.map(id => {
                const g = holeScores[id];
                return g != null ? { id, net: getMatchNetScore(match, id, hole, g), gross: g } : null;
            }).filter(Boolean);
            const bNets = match.teamB.map(id => {
                const g = holeScores[id];
                return g != null ? { id, net: getMatchNetScore(match, id, hole, g), gross: g } : null;
            }).filter(Boolean);

            if (aNets.length > 0) {
                const best = aNets.reduce((a, b) => a.net <= b.net ? a : b);
                bestBallA = `<span style="float:right;font-size:0.75rem;font-weight:normal;">Best: <strong>${best.net}</strong>${S.config.useHandicaps && best.net !== best.gross ? ` (${best.gross})` : ''}</span>`;
            }
            if (bNets.length > 0) {
                const best = bNets.reduce((a, b) => a.net <= b.net ? a : b);
                bestBallB = `<span style="float:right;font-size:0.75rem;font-weight:normal;">Best: <strong>${best.net}</strong>${S.config.useHandicaps && best.net !== best.gross ? ` (${best.gross})` : ''}</span>`;
            }
        }

        // Hole result banner
        let bannerClass = 'hole-pending', bannerText = 'Enter scores';
        if (holeWinner === 'A') {
            bannerClass = 'team-a-win';
            bannerText = `${S.config.teamA.name} wins hole`;
        } else if (holeWinner === 'B') {
            bannerClass = 'team-b-win';
            bannerText = `${S.config.teamB.name} wins hole`;
        } else if (holeWinner === 'halved') {
            bannerClass = 'hole-halved';
            bannerText = 'Hole halved';
        }

        // Hole strip
        let holeStrip = '';
        for (let h = 1; h <= 18; h++) {
            const w = getHoleWinner(match, h);
            let cls = '';
            if (h === hole) cls = 'current';
            else if (w === 'A') cls = 'team-a-won';
            else if (w === 'B') cls = 'team-b-won';
            else if (w === 'halved') cls = 'halved-hole';
            holeStrip += `<div class="hole-dot ${cls}" onclick="jumpToHole(${h})">${h}</div>`;
        }

        return `
            <div class="scoring-interface">
                <div class="scoring-header">
                    <div class="match-label">${match.type === 'fourball' ? 'Four Ball' : match.type === 'foursomes' ? 'Foursomes' : 'Singles'} &middot; Day ${match.day}</div>
                    <div class="match-status-lg">${statusText}</div>
                </div>
                <div class="scoring-hole-nav">
                    <button class="hole-nav-btn" onclick="prevHole()" ${hole <= 1 ? 'disabled' : ''}>&larr;</button>
                    <div class="hole-info">
                        <div class="hole-num">Hole ${hole}</div>
                        <div class="hole-details">Par ${holeInfo.par} &middot; HCP ${holeInfo.hcp}</div>
                    </div>
                    <button class="hole-nav-btn" onclick="nextHole()" ${hole >= 18 ? 'disabled' : ''}>&rarr;</button>
                </div>

                <div class="scoring-team-section">
                    <div class="scoring-team-label team-a">${S.config.teamA.name}${bestBallA}</div>
                    ${teamARows}
                </div>

                <div class="scoring-team-section">
                    <div class="scoring-team-label team-b">${S.config.teamB.name}${bestBallB}</div>
                    ${teamBRows}
                </div>

                <div class="hole-result-banner ${bannerClass}">${bannerText}</div>

                <div class="scoring-hole-strip">${holeStrip}</div>

                <button class="scoring-clear-btn" onclick="clearHoleScores(${hole})">Clear Hole ${hole} Scores</button>

                    ${status.isComplete ? '<div style="padding:12px;text-align:center;color:var(--masters-green);font-weight:bold;">Match Complete &mdash; ' + status.text + '</div>' : ''}
                </div>`;
        } catch (error) {
            console.error('Scoring interface render error:', error);
            return `
                <div class="empty-state">
                    <h3>Error Rendering Match</h3>
                    <p>An error occurred while rendering this match. Please try selecting a different match or refreshing the page.</p>
                    <p style="margin-top:12px;font-size:0.85rem;color:#666;">Error: ${error.message}</p>
                </div>`;
        }
    }

    function renderScoreEntryRow(match, playerId, holeNum, holeScores, holeInfo) {
        const player = getPlayer(playerId);
        const name = player?.name || 'Unknown';
        const hcp = getPlayerHcp(playerId);
        const grossScore = holeScores[playerId];
        const hasScore = grossScore !== undefined && grossScore !== null;
        const par = holeInfo.par;

        // Strokes received on this hole (using match play strokes - spinning off the low)
        const matchPlayHcp = getMatchPlayStrokes(match, playerId);
        const strokesReceived = S.config.useHandicaps ? getStrokesOnHole(matchPlayHcp, holeInfo.hcp) : 0;

        // Score display class
        let scoreClass = 'no-score';
        let vsParText = '';
        if (hasScore) {
            const diff = grossScore - par;
            if (diff <= -2) { scoreClass = 'eagle'; vsParText = diff; }
            else if (diff === -1) { scoreClass = 'birdie'; vsParText = '-1'; }
            else if (diff === 0) { scoreClass = ''; vsParText = 'E'; }
            else if (diff === 1) { scoreClass = 'bogey'; vsParText = '+1'; }
            else { scoreClass = 'double-bogey'; vsParText = '+' + diff; }
        }

        const displayScore = hasScore ? grossScore : '-';
        const strokeDots = strokesReceived > 0 ? ' <span style="color:var(--masters-red);font-size:0.7rem;">' + '\u25CF'.repeat(strokesReceived) + '</span>' : '';

        // Show full handicap and match play handicap
        const hcpDisplay = matchPlayHcp !== hcp && matchPlayHcp > 0
            ? `HCP ${hcp} (${matchPlayHcp})`
            : `HCP ${hcp}`;

        return `
            <div class="score-entry-row">
                <div class="score-entry-name">
                    ${name}${strokeDots}
                    <span class="hcp-badge">${hcpDisplay}</span>
                </div>
                <div class="score-entry-controls">
                    <button class="score-adj-btn" onclick="adjustScore('${playerId}', ${holeNum}, -1)">&minus;</button>
                    <div class="score-value-display ${scoreClass}">
                        ${displayScore}
                        ${vsParText ? `<span class="score-vs-par">${vsParText}</span>` : ''}
                    </div>
                    <button class="score-adj-btn" onclick="adjustScore('${playerId}', ${holeNum}, 1)">+</button>
                </div>
            </div>`;
    }

    function selectScoringMatch(matchId) {
        S.ui.activeMatchId = matchId;
        S.ui.scoringHole = findNextUnplayedHole(S.matches[matchId]);
        saveState();
        renderScoring();
    }

    function setScoringSessionFilter(sessionId) {
        S.ui.scoringSessionFilter = sessionId;
        saveState();
        renderScoring();
    }

    function findNextUnplayedHole(match) {
        for (let h = 1; h <= 18; h++) {
            if (!getHoleWinner(match, h)) return h;
        }
        return 18;
    }

    function adjustScore(playerId, holeNum, delta) {
        const match = S.matches[S.ui.activeMatchId];
        if (!match) return;

        // Check permissions
        if (!LiveSync.canScore(S.ui.activeMatchId)) {
            showToast('View only - you cannot edit this match');
            return;
        }

        if (!match.holes[holeNum]) match.holes[holeNum] = {};
        const current = match.holes[holeNum][playerId];
        const par = getHoleInfo(holeNum).par;

        if (current === undefined || current === null) {
            // First tap: set to par, then adjust from there
            match.holes[holeNum][playerId] = par;
        } else {
            const newVal = current + delta;
            if (newVal >= 1 && newVal <= 15) {
                match.holes[holeNum][playerId] = newVal;
            }
        }

        // Update match status
        updateMatchStatus(match);
        saveState();
        renderScoring();
    }

    function clearHoleScores(holeNum) {
        const match = S.matches[S.ui.activeMatchId];
        if (!match) return;
        if (!LiveSync.canScore(S.ui.activeMatchId)) {
            showToast('View only - you cannot edit this match');
            return;
        }
        delete match.holes[holeNum];
        updateMatchStatus(match);
        saveState();
        renderScoring();
    }

    function updateMatchStatus(match) {
        const hasAnyScores = Object.keys(match.holes).length > 0;
        const status = getMatchPlayStatus(match);
        if (status.isComplete) {
            match.status = 'complete';
        } else if (hasAnyScores) {
            match.status = 'active';
        } else {
            match.status = 'pending';
        }
    }

    function prevHole() {
        if (S.ui.scoringHole > 1) { S.ui.scoringHole--; saveState(); renderScoring(); }
    }

    function nextHole() {
        if (S.ui.scoringHole >= 18) return;

        // Check for birdies on current hole before advancing
        const match = S.matches[S.ui.activeMatchId];
        if (match) {
            checkForBirdiesAndCelebrate(match, S.ui.scoringHole);
        }

        S.ui.scoringHole++;
        saveState();
        renderScoring();
    }

    function jumpToHole(h) {
        S.ui.scoringHole = h; saveState(); renderScoring();
    }

    function checkForBirdiesAndCelebrate(match, holeNum) {
        const holeInfo = getHoleInfo(holeNum);
        const par = holeInfo.par;
        const holeScores = match.holes[holeNum] || {};
        const allPlayers = [...match.teamA, ...match.teamB];

        const birdies = [];
        const eagles = [];

        allPlayers.forEach(playerId => {
            const score = holeScores[playerId];
            if (score !== undefined && score !== null) {
                const diff = score - par;
                if (diff === -1) birdies.push(playerId);
                if (diff <= -2) eagles.push(playerId);
            }
        });

        // If we have birdies or eagles, LIGHT IT UP! 🔥
        if (birdies.length > 0 || eagles.length > 0) {
            launchFlames(birdies, eagles);
        }
    }

    function launchFlames(birdies, eagles) {
        // Create flame container if it doesn't exist
        let container = document.getElementById('flameContainer');
        if (!container) {
            container = document.createElement('div');
            container.id = 'flameContainer';
            container.className = 'flame-container';
            document.body.appendChild(container);
        }

        // Calculate number of flames based on scores
        const totalFlames = (birdies.length * 5) + (eagles.length * 10);

        // Launch flames from random positions
        for (let i = 0; i < totalFlames; i++) {
            setTimeout(() => {
                const flame = document.createElement('div');
                flame.className = 'flame';
                flame.textContent = '🔥';

                // Random starting position (bottom half of screen)
                const startX = Math.random() * window.innerWidth;
                const startY = window.innerHeight * 0.5 + (Math.random() * window.innerHeight * 0.3);

                flame.style.left = startX + 'px';
                flame.style.top = startY + 'px';

                container.appendChild(flame);

                // Remove flame after animation
                setTimeout(() => {
                    flame.remove();
                }, 2000);
            }, i * 50); // Stagger the flames
        }

        // Show BIRDIE! or EAGLE! burst text
        if (eagles.length > 0) {
            showBurst('🦅 EAGLE! 🦅');
        } else if (birdies.length > 0) {
            showBurst('🔥 BIRDIE! 🔥');
        }

        // Clean up container after all animations
        setTimeout(() => {
            if (container.children.length === 0) {
                container.remove();
            }
        }, 3000);
    }

    function showBurst(text) {
        const burst = document.createElement('div');
        burst.className = 'birdie-burst';
        burst.textContent = text;
        document.body.appendChild(burst);

        setTimeout(() => {
            burst.remove();
        }, 1500);
    }

    // ─────────────────────────────────────────────────────────
    // RENDER: MATCHES
    // ─────────────────────────────────────────────────────────
    function renderMatches() {
        const el = document.getElementById('matches-content');
        const teamAPlayers = getTeamPlayers('A');
        const teamBPlayers = getTeamPlayers('B');

        if (teamAPlayers.length === 0 && teamBPlayers.length === 0) {
            el.innerHTML = `<div class="empty-state"><h3>No Teams Yet</h3><p>Assign players to teams first using the <strong>Players</strong> or <strong>Draft</strong> tab.</p></div>`;
            return;
        }

        let html = `<div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:16px;">
            <h2 class="section-title" style="margin-bottom:0;">Match Setup</h2>
            <button class="btn btn-outline btn-sm" onclick="ExportManager.generateMatchSchedule(null, 'pdf')">📤 Export Schedule</button>
        </div>`;

        // Loop through sessions dynamically
        const canEdit = S.ui.settingsUnlocked;
        const sessions = S.config.sessions.sort((a, b) => a.order - b.order);
        sessions.forEach((session, index) => {
            const matches = getMatchesBySession(session.id);
            const formatLabel = {
                fourball: 'Four Ball',
                foursomes: 'Foursomes',
                singles: 'Singles',
                other: 'Other'
            }[session.format] || 'Match';

            html += `<div class="match-day-header" ${index > 0 ? 'style="margin-top:20px;"' : ''}>
                <h3>${session.name} &mdash; ${formatLabel}</h3>
                ${canEdit ?
                    `<button class="btn btn-gold btn-sm" onclick="openCreateMatch('${session.id}', '${session.format}')">+ Add Match</button>` :
                    `<button class="btn btn-outline btn-sm" onclick="if(requireAdmin('add matches')) renderMatches()">🔒 Add Match (Admin)</button>`
                }
            </div>`;

            if (matches.length === 0) {
                html += `<div class="empty-state mb-16"><p>No ${formatLabel.toLowerCase()} matches yet.</p></div>`;
            } else {
                html += matches.map(m => renderMatchCard(m)).join('');
            }
        });


        el.innerHTML = html;
    }

    function renderMatchCard(match) {
        const canEdit = S.ui.settingsUnlocked;

        // Build player names with strokes
        let teamANamesWithStrokes, teamBNamesWithStrokes;
        if (match.type === 'foursomes') {
            // Foursomes: show team strokes, not individual
            const teamStrokes = getAlternateShotStrokes(match);
            const teamANames = match.teamA.map(id => getPlayerName(id)).join(' / ');
            const teamBNames = match.teamB.map(id => getPlayerName(id)).join(' / ');
            teamANamesWithStrokes = `${teamANames}${teamStrokes.teamA > 0 ? ` (${teamStrokes.teamA})` : ''}`;
            teamBNamesWithStrokes = `${teamBNames}${teamStrokes.teamB > 0 ? ` (${teamStrokes.teamB})` : ''}`;
        } else {
            // Four Ball or Singles: show individual strokes
            teamANamesWithStrokes = match.teamA.map(id => {
                const strokes = getMatchPlayStrokes(match, id);
                return `${getPlayerName(id)}${strokes > 0 ? ` (${strokes})` : ''}`;
            }).join(' & ');
            teamBNamesWithStrokes = match.teamB.map(id => {
                const strokes = getMatchPlayStrokes(match, id);
                return `${getPlayerName(id)}${strokes > 0 ? ` (${strokes})` : ''}`;
            }).join(' & ');
        }

        const label = {
            fourball: 'Four Ball',
            foursomes: 'Foursomes',
            singles: 'Singles',
            other: 'Other'
        }[match.type] || 'Match';

        return `
            <div class="match-setup-card">
                <div class="match-setup-header" style="display:flex;align-items:center;justify-content:space-between;">
                    <span>Match ${match.order} &middot; ${label}</span>
                    <div style="display:flex;gap:8px;align-items:center;">
                        ${canEdit ? `
                            <input type="time" class="form-input" style="width:130px;padding:4px 6px;font-size:0.85rem;" value="${match.teeTime || ''}"
                                onchange="updateMatchTeeTime('${match.id}', this.value)" placeholder="Tee Time">
                        ` : match.teeTime ? `<span style="font-size:0.85rem;color:#666;">${match.teeTime}</span>` : ''}
                        ${canEdit ? `<button class="btn btn-sm" style="background:var(--masters-red);color:#fff;padding:4px 10px;" onclick="deleteMatch('${match.id}')">Remove</button>` : ''}
                    </div>
                </div>
                <div class="match-setup-body">
                    <div class="match-team-col">
                        <label style="color:${S.config.teamA.color}">${S.config.teamA.name}</label>
                        <strong>${teamANamesWithStrokes || 'TBD'}</strong>
                    </div>
                    <div class="match-vs-col">vs</div>
                    <div class="match-team-col" style="text-align:right">
                        <label style="color:${S.config.teamB.color}">${S.config.teamB.name}</label>
                        <strong>${teamBNamesWithStrokes || 'TBD'}</strong>
                    </div>
                </div>
            </div>`;
    }

    function openCreateMatch(sessionId, format) {
        if (!requireAdmin('create matches')) return;
        const session = S.config.sessions.find(s => s.id === sessionId);
        if (!session) return;

        const teamAPlayers = getTeamPlayers('A');
        const teamBPlayers = getTeamPlayers('B');
        const numPlayers = (format === 'fourball' || format === 'foursomes') ? 2 : 1;
        const formatLabel = {
            fourball: 'Four Ball',
            foursomes: 'Foursomes',
            singles: 'Singles',
            other: 'Other'
        }[format] || 'Match';

        // Get already-assigned players for this session to filter them out
        const assignedPlayerIds = new Set();
        getMatchesBySession(sessionId).forEach(match => {
            match.teamA.forEach(pid => assignedPlayerIds.add(pid));
            match.teamB.forEach(pid => assignedPlayerIds.add(pid));
        });

        // Filter out already-assigned players
        const availableTeamA = teamAPlayers.filter(p => !assignedPlayerIds.has(p.id));
        const availableTeamB = teamBPlayers.filter(p => !assignedPlayerIds.has(p.id));

        let body = `<p class="mb-16">Create a ${session.name} ${formatLabel} match.</p>`;
        body += `<div class="form-group"><label style="color:${S.config.teamA.color}">${S.config.teamA.name} Player${numPlayers > 1 ? 's' : ''}</label>`;
        for (let i = 0; i < numPlayers; i++) {
            body += `<select class="form-input mb-8" id="matchTeamA${i}"><option value="">-- Select Player --</option>
                ${availableTeamA.map(p => `<option value="${p.id}">${p.name} (HCP ${p.handicap || 'N/A'})</option>`).join('')}</select>`;
        }
        body += '</div>';
        body += `<div class="form-group"><label style="color:${S.config.teamB.color}">${S.config.teamB.name} Player${numPlayers > 1 ? 's' : ''}</label>`;
        for (let i = 0; i < numPlayers; i++) {
            body += `<select class="form-input mb-8" id="matchTeamB${i}"><option value="">-- Select Player --</option>
                ${availableTeamB.map(p => `<option value="${p.id}">${p.name} (HCP ${p.handicap || 'N/A'})</option>`).join('')}</select>`;
        }
        body += '</div>';

        const footer = `<button class="btn btn-outline" onclick="closeModal()">Cancel</button>
            <button class="btn btn-primary" onclick="createMatch('${sessionId}', '${format}', ${numPlayers})">Create Match</button>`;
        openModal(`New ${formatLabel} Match`, body, footer);
    }

    function createMatch(sessionId, format, numPlayers) {
        if (!requireAdmin('create match')) return;
        const teamA = [], teamB = [];
        for (let i = 0; i < numPlayers; i++) {
            const aVal = document.getElementById(`matchTeamA${i}`).value;
            const bVal = document.getElementById(`matchTeamB${i}`).value;
            if (aVal) teamA.push(aVal);
            if (bVal) teamB.push(bVal);
        }
        if (teamA.length === 0 || teamB.length === 0) { showToast('Please select at least one player per team'); return; }

        const match = {
            id: genId(),
            sessionId,
            type: format,
            order: getMatchesBySession(sessionId).length + 1,
            teamA, teamB, holes: {}, status: 'pending',
            teeTime: '',
        };
        S.matches[match.id] = match;
        saveState(); closeModal(); renderMatches();
        showToast('Match created');
    }

    function deleteMatch(matchId) {
        if (!requireAdmin('delete match')) return;
        if (!confirm('Remove this match?')) return;
        delete S.matches[matchId];
        saveState(); renderMatches();
        showToast('Match removed');
    }

    // ─────────────────────────────────────────────────────────
    // RENDER: PLAYERS
    // ─────────────────────────────────────────────────────────
    // TODO: Add "Import from Contacts" feature
    // - Requires HTTPS deployment
    // - Use Contact Picker API for iOS/Android
    // - Add button next to "+ Add Player"
    // - Map contact names to player names
    // - Reference: https://developer.mozilla.org/en-US/docs/Web/API/Contact_Picker_API
    function renderPlayers() {
        const el = document.getElementById('players-content');
        const allPlayers = Object.values(S.players);

        const canEdit = S.ui.settingsUnlocked;
        let html = `<div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:16px;">
            <h2 class="section-title" style="margin-bottom:0;">Players</h2>
            <div style="display:flex;gap:8px;">
                ${allPlayers.length > 0 ? '<button class="btn btn-outline btn-sm" onclick="ExportManager.generateTeamRoster(\'pdf\')">📤 Export Roster</button>' : ''}
                ${canEdit ?
                    '<button class="btn btn-primary btn-sm" onclick="openPlayerModal()">+ Add Player</button>' :
                    '<button class="btn btn-outline btn-sm" onclick="unlockPlayers()">🔒 Unlock Editing</button>'
                }
            </div>
        </div>`;

        if (allPlayers.length === 0) {
            html += `<div class="empty-state"><h3>No Players Yet</h3><p>Add players to get started.</p></div>`;
        } else {
            // Sort by handicap (low to high), with 0/null handicaps at the end
            const sortByHandicap = (a, b) => {
                const hcpA = a.handicap || 999;
                const hcpB = b.handicap || 999;
                return hcpA - hcpB;
            };

            const teamA = allPlayers.filter(p => p.team === 'A').sort(sortByHandicap);
            const teamB = allPlayers.filter(p => p.team === 'B').sort(sortByHandicap);
            const unassigned = allPlayers.filter(p => !p.team).sort(sortByHandicap);

            if (teamA.length > 0) {
                html += `<div class="text-sm text-muted mb-8" style="color:${S.config.teamA.color};font-weight:bold;text-transform:uppercase;letter-spacing:1px;">${S.config.teamA.name} (${teamA.length})</div>`;
                html += teamA.map(p => renderPlayerCard(p)).join('');
            }
            if (teamB.length > 0) {
                html += `<div class="text-sm text-muted mb-8 mt-16" style="color:${S.config.teamB.color};font-weight:bold;text-transform:uppercase;letter-spacing:1px;">${S.config.teamB.name} (${teamB.length})</div>`;
                html += teamB.map(p => renderPlayerCard(p)).join('');
            }
            if (unassigned.length > 0) {
                html += `<div class="text-sm text-muted mb-8 mt-16" style="font-weight:bold;text-transform:uppercase;letter-spacing:1px;">Unassigned (${unassigned.length})</div>`;
                html += unassigned.map(p => renderPlayerCard(p)).join('');
            }
        }

        el.innerHTML = html;
    }

    function unlockPlayers() {
        const password = prompt('Enter settings password:');
        if (password !== '1313') {
            showToast('Incorrect password');
            return;
        }
        S.ui.settingsUnlocked = true;
        saveState();
        renderPlayers();
        showToast('Editing unlocked');
    }

    function renderPlayerCard(player) {
        const initials = player.name.split(' ').map(n => n[0]).join('').toUpperCase().slice(0, 2);
        const teamClass = player.team === 'A' ? 'team-a' : player.team === 'B' ? 'team-b' : 'no-team';
        const canEdit = S.ui.settingsUnlocked;
        const handicapText = player.handicap ? `HCP: ${player.handicap}` : 'No handicap';

        return `
            <div class="player-card">
                <div class="player-avatar ${teamClass}">${initials}</div>
                <div class="player-info">
                    <div class="player-name">${player.name}</div>
                    <div class="player-detail">${handicapText}</div>
                </div>
                ${canEdit ? `<div class="player-actions">
                    <button class="btn btn-outline btn-icon btn-sm" onclick="openPlayerModal('${player.id}')" title="Edit">&#9998;</button>
                    <button class="btn btn-danger btn-icon btn-sm" onclick="deletePlayer('${player.id}')" title="Delete">&times;</button>
                </div>` : ''}
            </div>`;
    }

    function openPlayerModal(playerId) {
        if (!requireAdmin('edit players')) return;
        const player = playerId ? S.players[playerId] : null;
        const title = player ? 'Edit Player' : 'Add Player';
        const body = `
            <div class="form-group"><label>Name</label>
                <input class="form-input" id="playerName" value="${player?.name || ''}" placeholder="John Smith"></div>
            <div class="form-row">
                <div class="form-group"><label>Handicap</label>
                    <input class="form-input" id="playerHcp" type="number" value="${player?.handicap || ''}" placeholder="e.g. 12"></div>
                <div class="form-group"><label>Team</label>
                    <select class="form-input" id="playerTeam">
                        <option value="" ${!player?.team ? 'selected' : ''}>Unassigned</option>
                        <option value="A" ${player?.team === 'A' ? 'selected' : ''}>${S.config.teamA.name}</option>
                        <option value="B" ${player?.team === 'B' ? 'selected' : ''}>${S.config.teamB.name}</option>
                    </select></div>
            </div>
            <div class="form-group"><label>Email</label>
                <input class="form-input" id="playerEmail" type="email" value="${player?.email || ''}" placeholder="john@email.com"></div>
            <div class="form-group"><label>Phone</label>
                <input class="form-input" id="playerPhone" type="tel" value="${player?.phone || ''}" placeholder="(555) 123-4567"></div>`;
        const footer = `<button class="btn btn-outline" onclick="closeModal()">Cancel</button>
            <button class="btn btn-primary" onclick="savePlayer('${playerId || ''}')">${player ? 'Save Changes' : 'Add Player'}</button>`;
        openModal(title, body, footer);
        setTimeout(() => document.getElementById('playerName')?.focus(), 100);
    }

    function formatPhoneNumber(input) {
        if (!input) return '';

        // Remove all non-numeric characters
        let digits = input.replace(/\D/g, '');

        // Remove leading 1 if present (US country code)
        if (digits.length === 11 && digits[0] === '1') {
            digits = digits.substring(1);
        }

        // Format as (999) 999-9999
        if (digits.length === 10) {
            return `(${digits.substring(0, 3)}) ${digits.substring(3, 6)}-${digits.substring(6, 10)}`;
        }

        // If not 10 digits, return as-is
        return input;
    }

    function savePlayer(existingId) {
        if (!requireAdmin('save player')) return;
        const name = document.getElementById('playerName').value.trim();
        if (!name) { showToast('Name is required'); return; }
        const id = existingId || genId();
        const phoneInput = document.getElementById('playerPhone').value.trim();
        S.players[id] = {
            id, name,
            handicap: document.getElementById('playerHcp').value || '',
            team: document.getElementById('playerTeam').value || null,
            email: document.getElementById('playerEmail').value.trim(),
            phone: formatPhoneNumber(phoneInput),
        };
        saveState(); closeModal(); renderPlayers();
        showToast(existingId ? 'Player updated' : 'Player added');
    }

    function deletePlayer(playerId) {
        if (!requireAdmin('delete player')) return;
        const player = S.players[playerId];
        if (!confirm(`Remove ${player?.name}?`)) return;
        delete S.players[playerId];
        Object.values(S.matches).forEach(m => {
            m.teamA = m.teamA.filter(id => id !== playerId);
            m.teamB = m.teamB.filter(id => id !== playerId);
        });
        S.draft.picks = S.draft.picks.filter(p => p.playerId !== playerId);
        if (S.draft.captainA === playerId) S.draft.captainA = null;
        if (S.draft.captainB === playerId) S.draft.captainB = null;
        saveState(); renderPlayers();
        showToast('Player removed');
    }

    // ─────────────────────────────────────────────────────────
    // RENDER: DRAFT
    // ─────────────────────────────────────────────────────────
    function renderDraft() {
        const el = document.getElementById('draft-content');
        const allPlayers = Object.values(S.players);

        if (allPlayers.length < 2) {
            el.innerHTML = `<div class="empty-state"><h3>Need More Players</h3><p>Add at least 2 players before starting a draft.</p></div>`;
            return;
        }

        let html = '<h2 class="section-title">Team Draft</h2>';
        if (S.draft.status === 'pending') html += renderDraftSetup();
        else if (S.draft.status === 'active') html += renderDraftActive();
        else html += renderDraftComplete();

        el.innerHTML = html;
    }

    function renderDraftSetup() {
        const canEdit = S.ui.settingsUnlocked;
        const allPlayers = Object.values(S.players);
        return `
            <div class="settings-section">
                <div class="settings-section-header">Draft Setup</div>
                <div class="settings-section-body">
                    <p class="mb-16">Snake draft format: Team A picks first, then alternates (A, B, B, A, A, B, ...).</p>
                    ${canEdit ? `
                    <div class="form-row">
                        <div class="form-group"><label>${S.config.teamA.name} Captain</label>
                            <select class="form-input" id="draftCaptainA"><option value="">-- Select --</option>
                                ${allPlayers.map(p => `<option value="${p.id}" ${S.draft.captainA === p.id ? 'selected' : ''}>${p.name}</option>`).join('')}
                            </select></div>
                        <div class="form-group"><label>${S.config.teamB.name} Captain</label>
                            <select class="form-input" id="draftCaptainB"><option value="">-- Select --</option>
                                ${allPlayers.map(p => `<option value="${p.id}" ${S.draft.captainB === p.id ? 'selected' : ''}>${p.name}</option>`).join('')}
                            </select></div>
                    </div>
                    <button class="btn btn-primary btn-block mt-16" onclick="startDraft()">Start Draft</button>
                    ` : `
                    <div class="text-center" style="padding:20px;">
                        <p class="text-muted mb-16">Admin access required to start draft</p>
                        <button class="btn btn-outline" onclick="if(requireAdmin('start draft')) renderDraft()">🔒 Unlock Draft (Admin)</button>
                    </div>
                    `}
                </div>
            </div>`;
    }

    function renderDraftActive() {
        const canEdit = S.ui.settingsUnlocked;
        const drafted = new Set(S.draft.picks.map(p => p.playerId));
        if (S.draft.captainA) drafted.add(S.draft.captainA);
        if (S.draft.captainB) drafted.add(S.draft.captainB);
        const available = Object.values(S.players)
            .filter(p => !drafted.has(p.id))
            .sort((a, b) => (a.handicap || 999) - (b.handicap || 999));
        const teamAPicks = S.draft.picks.filter(p => p.team === 'A');
        const teamBPicks = S.draft.picks.filter(p => p.team === 'B');
        const ct = S.draft.currentTeam;

        let html = `
            <div class="draft-board">
                <div class="draft-team-col">
                    <div class="draft-team-header team-a">${S.config.teamA.name}</div>
                    <div class="draft-team-list">
                        ${S.draft.captainA ? `<div class="draft-pick-item"><span class="pick-num">C</span><strong>${getPlayerName(S.draft.captainA)}</strong></div>` : ''}
                        ${teamAPicks.map((p, i) => `<div class="draft-pick-item"><span class="pick-num">${i + 1}</span>${getPlayerName(p.playerId)}</div>`).join('')}
                    </div>
                </div>
                <div class="draft-team-col">
                    <div class="draft-team-header team-b">${S.config.teamB.name}</div>
                    <div class="draft-team-list">
                        ${S.draft.captainB ? `<div class="draft-pick-item"><span class="pick-num">C</span><strong>${getPlayerName(S.draft.captainB)}</strong></div>` : ''}
                        ${teamBPicks.map((p, i) => `<div class="draft-pick-item"><span class="pick-num">${i + 1}</span>${getPlayerName(p.playerId)}</div>`).join('')}
                    </div>
                </div>
            </div>`;

        if (available.length === 0) {
            html += `<div class="text-center mt-16"><p style="font-size:1.1rem;color:var(--masters-green);font-weight:bold;margin-bottom:12px;">Draft Complete!</p>
                ${canEdit ? `<button class="btn btn-primary" onclick="finalizeDraft()">Finalize Teams</button>` : ''}</div>`;
        } else {
            html += `<div class="draft-pool"><div class="draft-pool-header">Available Players</div>
                ${canEdit ? `<div class="draft-pool-indicator"><span class="picking-team" style="color:${ct === 'A' ? S.config.teamA.color : S.config.teamB.color}">
                    ${ct === 'A' ? S.config.teamA.name : S.config.teamB.name} picks</span></div>` : ''}
                <div class="draft-pool-list">
                    ${available.map(p => canEdit ?
                        `<button class="draft-player-btn" onclick="makeDraftPick('${p.id}')">${p.name} <span class="player-hcp">${p.handicap ? 'HCP: ' + p.handicap : ''}</span></button>` :
                        `<div style="padding:12px;border:1px solid #ddd;margin-bottom:8px;border-radius:6px;">${p.name} <span class="text-muted">${p.handicap ? 'HCP: ' + p.handicap : ''}</span></div>`
                    ).join('')}
                </div></div>
                ${canEdit ? `<div class="mt-16" style="display:flex;gap:8px;">
                    <button class="btn btn-outline btn-sm" onclick="undoDraftPick()" ${S.draft.picks.length === 0 ? 'disabled' : ''}>Undo Last Pick</button>
                    <button class="btn btn-danger btn-sm" onclick="resetDraft()">Reset Draft</button>
                </div>` : ''}`;
        }
        return html;
    }

    function renderDraftComplete() {
        const canEdit = S.ui.settingsUnlocked;
        const teamA = getTeamPlayers('A');
        const teamB = getTeamPlayers('B');
        return `
            <div class="draft-board">
                <div class="draft-team-col"><div class="draft-team-header team-a">${S.config.teamA.name}</div>
                    <div class="draft-team-list">${teamA.map(p => `<div class="draft-pick-item">${p.name}</div>`).join('')}</div></div>
                <div class="draft-team-col"><div class="draft-team-header team-b">${S.config.teamB.name}</div>
                    <div class="draft-team-list">${teamB.map(p => `<div class="draft-pick-item">${p.name}</div>`).join('')}</div></div>
            </div>
            ${canEdit ? `<div class="mt-16 text-center"><button class="btn btn-danger btn-sm" onclick="resetDraft()">Reset Draft</button></div>` : ''}`;
    }

    function startDraft() {
        if (!requireAdmin('start draft')) return;
        const captainA = document.getElementById('draftCaptainA').value;
        const captainB = document.getElementById('draftCaptainB').value;
        if (!captainA || !captainB) { showToast('Select both captains'); return; }
        if (captainA === captainB) { showToast('Captains must be different players'); return; }

        Object.values(S.players).forEach(p => p.team = null);
        S.draft = { captainA, captainB, status: 'active', picks: [], currentTeam: 'A' };
        S.players[captainA].team = 'A';
        S.players[captainB].team = 'B';
        saveState(); renderDraft();
        showToast('Draft started! ' + S.config.teamA.name + ' picks first');
    }

    function makeDraftPick(playerId) {
        if (!requireAdmin('make draft pick')) return;
        const team = S.draft.currentTeam;
        S.draft.picks.push({ team, playerId, order: S.draft.picks.length + 1 });
        S.players[playerId].team = team;

        // Snake draft logic: A, B, B, A, A, B, B, A, A, B...
        const pickIndex = S.draft.picks.length; // 0-based index of next pick
        const roundNum = Math.floor(pickIndex / 2);
        const isFirstInRound = (pickIndex % 2 === 0);
        S.draft.currentTeam = (roundNum % 2 === 0)
            ? (isFirstInRound ? 'A' : 'B')  // Even rounds: A, B
            : (isFirstInRound ? 'B' : 'A'); // Odd rounds: B, A

        saveState(); renderDraft();
        showToast(`${team === 'A' ? S.config.teamA.name : S.config.teamB.name} selects ${S.players[playerId].name}`);
    }

    function undoDraftPick() {
        if (!requireAdmin('undo draft pick')) return;
        if (S.draft.picks.length === 0) return;
        const last = S.draft.picks.pop();
        S.players[last.playerId].team = null;
        S.draft.currentTeam = last.team;
        saveState(); renderDraft();
    }

    function resetDraft() {
        if (!requireAdmin('reset draft')) return;
        if (!confirm('Reset the entire draft? All team assignments will be cleared.')) return;
        Object.values(S.players).forEach(p => p.team = null);
        S.draft = { status: 'pending', captainA: null, captainB: null, picks: [], currentTeam: 'A' };
        saveState(); renderDraft();
        showToast('Draft reset');
    }

    function finalizeDraft() {
        if (!requireAdmin('finalize draft')) return;
        S.draft.status = 'complete';
        saveState(); renderDraft();
        showToast('Teams finalized!');
    }

    // ─────────────────────────────────────────────────────────
    // RENDER: SCHEDULE
    // ─────────────────────────────────────────────────────────
    function renderSchedule() {
        const el = document.getElementById('schedule-content');
        const sessions = S.config.sessions.sort((a, b) => a.order - b.order);

        let html = `<h2 class="section-title">Tournament Schedule</h2>
            <p class="text-sm text-muted" style="margin-bottom:20px;text-align:center;">
                Edit dates in Settings • Edit tee times in Matches tab
            </p>`;

        // Display schedule by session
        sessions.forEach(session => {
            const matches = getMatchesBySession(session.id);
            const formatLabel = {
                fourball: 'Four Ball',
                foursomes: 'Foursomes',
                singles: 'Singles',
                other: 'Other'
            }[session.format] || 'Match';

            html += `<div class="lb-board" style="margin-bottom:20px;">
                <div class="lb-section-header">
                    ${session.name} - ${formatLabel}
                    ${session.date ? ` - ${formatDate(session.date)}` : ' (Date TBD)'}
                </div>`;

            if (matches.length === 0) {
                html += `<div style="padding:20px;text-align:center;color:#999;">No matches scheduled</div>`;
            } else {
                html += `<div style="padding:12px;overflow-x:auto;">
                    <table style="width:100%;border-collapse:collapse;">
                        <thead>
                            <tr style="border-bottom:2px solid #ddd;">
                                <th style="padding:8px;text-align:left;font-weight:600;">Tee Time</th>
                                <th style="padding:8px;text-align:left;font-weight:600;">Match</th>
                            </tr>
                        </thead>
                        <tbody>`;

                matches.forEach(match => {
                    // Build player names with strokes
                    const teamANamesWithStrokes = match.teamA.map(id => {
                        const strokes = getMatchPlayStrokes(match, id);
                        return `${getPlayerName(id)}${strokes > 0 ? ` (${strokes})` : ''}`;
                    }).join(' & ');
                    const teamBNamesWithStrokes = match.teamB.map(id => {
                        const strokes = getMatchPlayStrokes(match, id);
                        return `${getPlayerName(id)}${strokes > 0 ? ` (${strokes})` : ''}`;
                    }).join(' & ');
                    const teeTimeDisplay = match.teeTime || 'TBD';

                    html += `<tr style="border-bottom:1px solid #eee;">
                        <td style="padding:8px;vertical-align:middle;white-space:nowrap;">
                            <strong>${teeTimeDisplay}</strong>
                        </td>
                        <td style="padding:8px;">
                            <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;">
                                <span style="font-weight:600;color:${S.config.teamA.color};">${teamANamesWithStrokes}</span>
                                <span style="color:#999;">vs</span>
                                <span style="font-weight:600;color:${S.config.teamB.color};">${teamBNamesWithStrokes}</span>
                            </div>
                        </td>
                    </tr>`;
                });

                html += `</tbody></table></div>`;
            }

            html += `</div>`;
        });


        el.innerHTML = html;
    }

    function formatDate(dateStr) {
        if (!dateStr) return '';
        try {
            const date = new Date(dateStr + 'T00:00:00');
            return date.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric', year: 'numeric' });
        } catch (e) {
            return dateStr;
        }
    }

    function updateSessionDate(sessionId, dateValue) {
        if (!requireAdmin('update schedule')) return;
        const session = S.config.sessions.find(s => s.id === sessionId);
        if (session) {
            session.date = dateValue;
            saveState();
            renderSchedule();
            showToast('Date updated');
        }
    }

    function updateMatchTeeTime(matchId, timeValue) {
        if (!requireAdmin('update schedule')) return;
        const match = S.matches[matchId];
        if (match) {
            match.teeTime = timeValue;
            saveState();
            renderSchedule();
            showToast('Tee time updated');
        }
    }

    // ─────────────────────────────────────────────────────────
    // RENDER: SETTINGS
    // ─────────────────────────────────────────────────────────
    function renderSettings() {
        const el = document.getElementById('settings-content');
        const ch = S.config.courseHoles;

        // Course hole table rows
        let courseRows = '';
        for (let i = 0; i < 18; i++) {
            const h = ch[i] || { hole: i + 1, par: 4, hcp: i + 1 };
            courseRows += `<tr>
                <td class="hole-label">${h.hole}</td>
                <td><input type="number" id="par_${i}" value="${h.par}" min="3" max="6"></td>
                <td><input type="number" id="hcp_${i}" value="${h.hcp}" min="1" max="18"></td>
            </tr>`;
        }

        el.innerHTML = `
            <h2 class="section-title">Event Settings</h2>

            <div class="settings-section" style="background:#f0f8f0;border:2px solid var(--masters-green);">
                <div class="settings-section-header" style="background:var(--masters-green);color:#fff;">Access Codes</div>
                <div class="settings-section-body">
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:16px;">
                        <div style="text-align:center;padding:12px;background:#fff;border-radius:8px;">
                            <p style="font-size:0.75rem;color:#666;text-transform:uppercase;letter-spacing:1px;margin-bottom:8px;">Settings Password</p>
                            <p style="font-size:2rem;font-weight:bold;color:var(--masters-green);letter-spacing:3px;">1313</p>
                        </div>
                        <div style="text-align:center;padding:12px;background:#fff;border-radius:8px;">
                            <p style="font-size:0.75rem;color:#666;text-transform:uppercase;letter-spacing:1px;margin-bottom:8px;">Scorer Code</p>
                            <p style="font-size:2rem;font-weight:bold;color:var(--masters-green);letter-spacing:3px;">6969</p>
                        </div>
                    </div>
                    <p class="text-sm text-muted" style="margin-top:12px;text-align:center;">Settings Password: admin access • Scorer Code: score all matches</p>
                </div>
            </div>

            <div class="settings-section">
                <div class="settings-section-header">Communications</div>
                <div class="settings-section-body">
                    <p class="text-sm text-muted mb-16">Send messages to all participants with contact information.</p>
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:16px;">
                        <button class="btn btn-primary" onclick="sendEmailToParticipants()">
                            <span style="font-size:1.2rem;margin-right:8px;">&#9993;</span> Send Email
                        </button>
                        <button class="btn btn-primary" onclick="sendTextToParticipants()">
                            <span style="font-size:1.2rem;margin-right:8px;">&#128172;</span> Send Text
                        </button>
                    </div>
                    <p class="text-sm text-muted" style="margin-top:12px;text-align:center;font-style:italic;">
                        Use for tee times, pairings, round summaries, etc.
                    </p>
                </div>
            </div>

            <div class="settings-section">
                <div class="settings-section-header">Event Info</div>
                <div class="settings-section-body">
                    <div class="form-group"><label>Event Name</label>
                        <input class="form-input" id="cfgEventName" value="${S.config.eventName}"></div>
                    <div class="form-group"><label>Club Name</label>
                        <input class="form-input" id="cfgClubName" value="${S.config.clubName}"></div>
                    <div class="form-row">
                        <div class="form-group"><label>Course</label>
                            <input class="form-input" id="cfgCourse" value="${S.config.courseName}" placeholder="e.g. Augusta National"></div>
                        <div class="form-group"><label>Event Date</label>
                            <input class="form-input" id="cfgDate" type="date" value="${S.config.eventDate}"></div>
                    </div>
                    <div class="form-group"><label>Year</label>
                        <input class="form-input" id="cfgYear" type="number" value="${S.config.year}"></div>
                </div>
            </div>

            <div class="settings-section">
                <div class="settings-section-header">Teams</div>
                <div class="settings-section-body">
                    <div class="form-row">
                        <div class="form-group"><label>Team A Name</label>
                            <input class="form-input" id="cfgTeamAName" value="${S.config.teamA.name}"></div>
                        <div class="form-group"><label>Team A Color</label>
                            <input class="form-input" id="cfgTeamAColor" type="color" value="${S.config.teamA.color}" style="height:42px;padding:4px;"></div>
                    </div>
                    <div class="form-row">
                        <div class="form-group"><label>Team B Name</label>
                            <input class="form-input" id="cfgTeamBName" value="${S.config.teamB.name}"></div>
                        <div class="form-group"><label>Team B Color</label>
                            <input class="form-input" id="cfgTeamBColor" type="color" value="${S.config.teamB.color}" style="height:42px;padding:4px;"></div>
                    </div>
                    <div class="form-group"><label>Players Per Team</label>
                        <input class="form-input" id="cfgTeamSize" type="number" value="${S.config.teamSize}" min="2" max="20"></div>
                </div>
            </div>

            <div class="settings-section">
                <div class="settings-section-header">Sessions / Formats</div>
                <div class="settings-section-body">
                    <p class="text-sm text-muted mb-16">Configure match play sessions (e.g., Day 1, Day 2, bonus events) and their formats.</p>
                    <div id="sessionsListSettings">
                        ${S.config.sessions.sort((a, b) => a.order - b.order).map(session => `
                            <div class="session-config-row" style="display:flex;gap:8px;margin-bottom:8px;align-items:center;">
                                <input class="form-input" value="${session.name}" id="session_name_${session.id}" style="flex:2;" placeholder="Session name">
                                <select class="form-input" id="session_format_${session.id}" style="flex:2;">
                                    <option value="fourball" ${session.format === 'fourball' ? 'selected' : ''}>Four Ball</option>
                                    <option value="foursomes" ${session.format === 'foursomes' ? 'selected' : ''}>Foursomes</option>
                                    <option value="singles" ${session.format === 'singles' ? 'selected' : ''}>Singles</option>
                                    <option value="other" ${session.format === 'other' ? 'selected' : ''}>Other</option>
                                </select>
                                <input class="form-input" type="date" id="session_date_${session.id}" value="${session.date || ''}" style="flex:1.5;" placeholder="Date">
                                <button class="btn btn-sm" onclick="moveSessionUp('${session.id}')" style="padding:4px 8px;" title="Move up">▲</button>
                                <button class="btn btn-sm" onclick="moveSessionDown('${session.id}')" style="padding:4px 8px;" title="Move down">▼</button>
                                <button class="btn btn-sm" onclick="deleteSession('${session.id}')" style="background:var(--masters-red);color:#fff;padding:4px 8px;" title="Delete">×</button>
                            </div>
                        `).join('')}
                    </div>
                    <button class="btn btn-outline btn-sm" onclick="addSession()" style="margin-top:8px;">+ Add Session</button>
                </div>
            </div>

            <div class="settings-section">
                <div class="settings-section-header">Bonus Events</div>
                <div class="settings-section-body">
                    <p class="text-sm text-muted mb-16">Award custom points to teams for side events (e.g., Closest to Pin, Fastest Hole, Skills Challenge).</p>
                    <div id="bonusEventsListSettings">
                        ${Object.values(S.bonusEvents)
                            .sort((a, b) => (a.order || 0) - (b.order || 0))
                            .map(evt => `
                            <div class="session-config-row" style="display:flex;gap:8px;margin-bottom:10px;align-items:flex-start;flex-wrap:wrap;">
                                <input class="form-input" value="${evt.name || ''}" id="bonus_name_${evt.id}"
                                    style="flex:2;min-width:120px;" placeholder="Event name">
                                <select class="form-input" id="bonus_session_${evt.id}" style="flex:1.5;min-width:100px;">
                                    <option value="" ${!evt.sessionId ? 'selected' : ''}>Standalone</option>
                                    ${S.config.sessions.sort((a,b) => a.order - b.order).map(s =>
                                        `<option value="${s.id}" ${evt.sessionId === s.id ? 'selected' : ''}>${s.name}</option>`
                                    ).join('')}
                                </select>
                                <div style="display:flex;align-items:center;gap:4px;">
                                    <label class="text-sm" style="white-space:nowrap;color:${S.config.teamA.color};font-weight:600;">${S.config.teamA.name}:</label>
                                    <input class="form-input" type="number" id="bonus_ptsA_${evt.id}"
                                        value="${evt.pointsA || 0}" min="0" step="0.5" style="width:60px;">
                                </div>
                                <div style="display:flex;align-items:center;gap:4px;">
                                    <label class="text-sm" style="white-space:nowrap;color:${S.config.teamB.color};font-weight:600;">${S.config.teamB.name}:</label>
                                    <input class="form-input" type="number" id="bonus_ptsB_${evt.id}"
                                        value="${evt.pointsB || 0}" min="0" step="0.5" style="width:60px;">
                                </div>
                                <input class="form-input" value="${evt.notesA || evt.notes || ''}" id="bonus_notesA_${evt.id}"
                                    style="flex:1.5;min-width:100px;" placeholder="${S.config.teamA.name} notes">
                                <input class="form-input" value="${evt.notesB || ''}" id="bonus_notesB_${evt.id}"
                                    style="flex:1.5;min-width:100px;" placeholder="${S.config.teamB.name} notes">
                                <button class="btn btn-sm" onclick="deleteBonusEvent('${evt.id}')"
                                    style="background:var(--masters-red);color:#fff;padding:4px 8px;" title="Delete">×</button>
                            </div>
                        `).join('')}
                    </div>
                    ${Object.keys(S.bonusEvents).length === 0 ? '<p class="text-sm text-muted" style="text-align:center;font-style:italic;">No bonus events yet.</p>' : ''}
                    <button class="btn btn-outline btn-sm" onclick="addBonusEvent()" style="margin-top:8px;">+ Add Bonus Event</button>
                </div>
            </div>

            <div class="settings-section">
                <div class="settings-section-header">Scoring</div>
                <div class="settings-section-body">
                    <div class="form-group">
                        <label style="display:flex;align-items:center;gap:8px;cursor:pointer;">
                            <input type="checkbox" id="cfgUseHandicaps" ${S.config.useHandicaps ? 'checked' : ''} style="width:18px;height:18px;">
                            Apply Handicap Strokes
                        </label>
                        <span class="text-sm text-muted">When enabled, players receive strokes based on their handicap and hole difficulty.</span>
                    </div>
                </div>
            </div>

            <div class="settings-section">
                <div class="settings-section-header">Course Setup</div>
                <div class="settings-section-body" style="padding:8px;overflow-x:auto;">
                    <table class="course-table">
                        <thead><tr><th>Hole</th><th>Par</th><th>HCP</th></tr></thead>
                        <tbody>${courseRows}</tbody>
                    </table>
                </div>
            </div>

            <button class="btn btn-primary btn-block" onclick="saveSettings()">Save Settings</button>

            <div class="settings-section" style="margin-top:24px;">
                <div class="settings-section-header" style="background:var(--masters-red);">Danger Zone</div>
                <div class="settings-section-body">
                    <p class="text-sm text-muted mb-16">Reset all event data including players, matches, and scores.</p>
                    <button class="btn btn-danger" onclick="resetAll()">Reset Everything</button>
                </div>
            </div>

            <div style="margin-top:32px;padding:16px;text-align:center;border-top:1px solid #eee;">
                <p style="font-size:0.75rem;color:#999;margin-bottom:4px;">Smashters App</p>
                <p style="font-size:0.85rem;color:var(--masters-green);font-weight:bold;">v${APP_VERSION}</p>
                <p style="font-size:0.7rem;color:#999;margin-top:4px;">Admin Protection • PDF Exports • Individual Stats • Schedule</p>
            </div>`;
    }

    function saveSettings() {
        S.config.eventName = document.getElementById('cfgEventName').value.trim() || 'The Smashters';
        S.config.clubName = document.getElementById('cfgClubName').value.trim();
        S.config.courseName = document.getElementById('cfgCourse').value.trim();
        S.config.eventDate = document.getElementById('cfgDate').value;
        S.config.year = parseInt(document.getElementById('cfgYear').value) || new Date().getFullYear();
        S.config.teamA.name = document.getElementById('cfgTeamAName').value.trim() || 'Team A';
        S.config.teamA.color = document.getElementById('cfgTeamAColor').value;
        S.config.teamB.name = document.getElementById('cfgTeamBName').value.trim() || 'Team B';
        S.config.teamB.color = document.getElementById('cfgTeamBColor').value;
        S.config.teamSize = parseInt(document.getElementById('cfgTeamSize').value) || 6;
        S.config.useHandicaps = document.getElementById('cfgUseHandicaps').checked;

        // Save sessions
        S.config.sessions.forEach(session => {
            const nameInput = document.getElementById(`session_name_${session.id}`);
            const formatInput = document.getElementById(`session_format_${session.id}`);
            const dateInput = document.getElementById(`session_date_${session.id}`);
            if (nameInput) session.name = nameInput.value.trim() || session.name;
            if (formatInput) session.format = formatInput.value;
            if (dateInput) session.date = dateInput.value;
        });

        // Save bonus events
        Object.keys(S.bonusEvents).forEach(id => {
            const nameInput = document.getElementById(`bonus_name_${id}`);
            const sessionInput = document.getElementById(`bonus_session_${id}`);
            const ptsAInput = document.getElementById(`bonus_ptsA_${id}`);
            const ptsBInput = document.getElementById(`bonus_ptsB_${id}`);
            const notesAInput = document.getElementById(`bonus_notesA_${id}`);
            const notesBInput = document.getElementById(`bonus_notesB_${id}`);
            if (nameInput) S.bonusEvents[id].name = nameInput.value.trim() || 'Bonus Event';
            if (sessionInput) S.bonusEvents[id].sessionId = sessionInput.value || null;
            if (ptsAInput) S.bonusEvents[id].pointsA = parseFloat(ptsAInput.value) || 0;
            if (ptsBInput) S.bonusEvents[id].pointsB = parseFloat(ptsBInput.value) || 0;
            if (notesAInput) S.bonusEvents[id].notesA = notesAInput.value.trim();
            if (notesBInput) S.bonusEvents[id].notesB = notesBInput.value.trim();
            delete S.bonusEvents[id].notes;
        });

        // Save course holes
        for (let i = 0; i < 18; i++) {
            S.config.courseHoles[i] = {
                hole: i + 1,
                par: parseInt(document.getElementById(`par_${i}`).value) || 4,
                hcp: parseInt(document.getElementById(`hcp_${i}`).value) || (i + 1),
            };
        }

        document.documentElement.style.setProperty('--team-a-color', S.config.teamA.color);
        document.documentElement.style.setProperty('--team-b-color', S.config.teamB.color);
        saveState();
        showToast('Settings saved');
        document.querySelector('.header-titles h1').textContent = S.config.eventName;
        document.querySelector('.header-titles .subtitle').textContent = S.config.clubName;
    }

    // ─────────────────────────────────────────────────────────
    // COMMUNICATIONS: Email & Text Messaging
    // ─────────────────────────────────────────────────────────
    function sendEmailToParticipants() {
        // Collect all players with email addresses
        const playersWithEmail = Object.values(S.players).filter(p => p.email && p.email.trim());

        if (playersWithEmail.length === 0) {
            showToast('No players have email addresses on file');
            return;
        }

        // Collect all email addresses
        const emails = playersWithEmail.map(p => p.email.trim()).join(',');

        // Create default subject and body
        const subject = encodeURIComponent(`${S.config.eventName} - ${S.config.clubName}`);
        const body = encodeURIComponent(`Hello Smashters,\n\n[Your message here]\n\nEvent: ${S.config.eventName}\nCourse: ${S.config.courseName || 'TBD'}\nDate: ${S.config.eventDate || 'TBD'}\n\nSee you on the course!`);

        // Open email client with BCC (to protect privacy)
        // Note: Using BCC means the emails won't be visible to recipients
        const mailtoLink = `mailto:?bcc=${emails}&subject=${subject}&body=${body}`;

        // Open in new window/tab
        window.location.href = mailtoLink;

        showToast(`Opening email client for ${playersWithEmail.length} participants`);
    }

    function sendTextToParticipants() {
        // Collect all players with phone numbers
        const playersWithPhone = Object.values(S.players).filter(p => p.phone && p.phone.trim());

        if (playersWithPhone.length === 0) {
            showToast('No players have phone numbers on file');
            return;
        }

        // For SMS, we'll show a modal with options since sms: protocol has limited support
        const playerList = playersWithPhone.map(p =>
            `<div style="padding:8px;border-bottom:1px solid #eee;">
                <strong>${p.name}</strong><br>
                <span style="color:#666;font-size:0.9rem;">${p.phone}</span>
            </div>`
        ).join('');

        const body = `
            <p class="mb-16">Text messaging from web browsers has limited support. Choose an option below:</p>

            <div style="margin-bottom:20px;">
                <h4 style="margin-bottom:12px;">Option 1: Copy Phone Numbers</h4>
                <p class="text-sm text-muted mb-8">Copy all phone numbers and paste into your messaging app (recommended for group texts)</p>
                <textarea id="phoneNumberList" readonly style="width:100%;height:80px;padding:8px;border:1px solid #ccc;border-radius:4px;font-family:monospace;font-size:0.9rem;">${playersWithPhone.map(p => p.phone).join(', ')}</textarea>
                <button class="btn btn-outline btn-sm mt-8" onclick="copyPhoneNumbers()">Copy to Clipboard</button>
            </div>

            <div style="margin-bottom:20px;">
                <h4 style="margin-bottom:12px;">Option 2: Individual Texts</h4>
                <p class="text-sm text-muted mb-12">Send texts one-by-one (opens messaging app for each)</p>
                <div style="max-height:200px;overflow-y:auto;border:1px solid #eee;border-radius:4px;">
                    ${playerList}
                </div>
            </div>
        `;

        const footer = `
            <button class="btn btn-outline" onclick="closeModal()">Close</button>
            <button class="btn btn-primary" onclick="sendIndividualTexts()">Send Individual Texts</button>
        `;

        openModal(`Send Text Messages (${playersWithPhone.length} participants)`, body, footer);
    }

    function copyPhoneNumbers() {
        const textarea = document.getElementById('phoneNumberList');
        textarea.select();
        textarea.setSelectionRange(0, 99999); // For mobile devices

        try {
            document.execCommand('copy');
            showToast('Phone numbers copied to clipboard!');
        } catch (err) {
            // Fallback for modern browsers
            navigator.clipboard.writeText(textarea.value).then(() => {
                showToast('Phone numbers copied to clipboard!');
            }).catch(() => {
                showToast('Failed to copy. Please copy manually.');
            });
        }
    }

    function sendIndividualTexts() {
        const playersWithPhone = Object.values(S.players).filter(p => p.phone && p.phone.trim());

        if (playersWithPhone.length === 0) {
            showToast('No players have phone numbers on file');
            closeModal();
            return;
        }

        // Create a default message template
        const defaultMessage = `${S.config.eventName} - ${S.config.clubName}\n\nEvent Date: ${S.config.eventDate || 'TBD'}\nCourse: ${S.config.courseName || 'TBD'}\n\n[Your message here]`;
        const message = encodeURIComponent(defaultMessage);

        // Warning that this will open multiple windows
        if (!confirm(`This will open ${playersWithPhone.length} messaging windows. Continue?`)) {
            return;
        }

        closeModal();

        // Open SMS link for each player with a delay to avoid blocking
        playersWithPhone.forEach((player, index) => {
            setTimeout(() => {
                // Clean phone number (remove special characters)
                const cleanPhone = player.phone.replace(/[^0-9+]/g, '');
                // Note: iOS supports sms: with body, Android may not
                const smsLink = `sms:${cleanPhone}?&body=${message}`;
                window.open(smsLink, '_blank');
            }, index * 1000); // 1 second delay between each
        });

        showToast(`Opening ${playersWithPhone.length} messaging windows...`);
    }

    function renderLiveSettings() {
        if (LiveSync.isAdmin) {
            // Currently live - show status and scorer code
            return `
                <div style="text-align:center;margin-bottom:20px;">
                    <p style="color:var(--masters-green);font-weight:bold;font-size:1rem;margin-bottom:4px;">Event is LIVE</p>
                    <p class="text-sm text-muted">Event Code: <strong style="font-size:1.3rem;color:var(--masters-green);letter-spacing:3px;">${LiveSync.eventCode}</strong></p>
                    <p class="text-sm text-muted mb-4">Share this code with viewers to watch the leaderboard.</p>
                </div>
                <div style="background:#f0f8f0;border:2px solid var(--masters-green);border-radius:8px;padding:16px;margin-bottom:16px;text-align:center;">
                    <p style="font-weight:bold;margin-bottom:8px;font-size:0.8rem;text-transform:uppercase;letter-spacing:1px;color:var(--masters-green);">Scorer Code</p>
                    <p style="font-size:2rem;font-weight:bold;color:var(--masters-green);letter-spacing:4px;margin:8px 0;">${LiveSync.scorerCode}</p>
                    <p class="text-sm text-muted">Give this code to your designated scorers. They can score all matches.</p>
                </div>
                <div style="margin-top:16px;display:flex;gap:8px;flex-wrap:wrap;">
                    <button class="btn btn-danger btn-sm" onclick="LiveSync.stopLive().then(() => renderSettings())">Stop Live Event</button>
                    <button class="btn btn-outline btn-sm" onclick="openAdminResetModal()">Reset Scores</button>
                </div>`;
        } else {
            // Not live - show go live controls
            const hasMatches = Object.keys(S.matches).length > 0;
            return `
                <p class="text-sm text-muted mb-16">Go live to share scores in real-time. You'll get a scorer code to share with designated scorers who can score all matches.</p>
                ${!hasMatches ? '<p style="color:var(--masters-red);font-size:0.85rem;margin-bottom:12px;">Create matches first before going live.</p>' : ''}
                <button class="btn btn-primary btn-block" onclick="handleGoLive()" ${!hasMatches ? 'disabled style="opacity:0.5;"' : ''}>Go Live</button>`;
        }
    }

    function handleGoLive() {
        LiveSync.goLive('1313').then(success => {
            if (success) renderSettings();
        });
    }

    function openAdminResetModal() {
        const body = `
            <p class="mb-16">Enter your admin PIN to reset all match scores. This will clear scores but keep players and match pairings.</p>
            <div class="form-group">
                <label>Admin PIN</label>
                <input class="form-input" id="resetPinInput" type="text" placeholder="Enter PIN" maxlength="6" style="max-width:200px;">
            </div>`;
        const footer = `
            <button class="btn btn-outline" onclick="closeModal()">Cancel</button>
            <button class="btn btn-danger" onclick="handleAdminReset()">Reset All Scores</button>`;
        openModal('Reset Scores', body, footer);
    }

    function handleAdminReset() {
        const pin = document.getElementById('resetPinInput')?.value?.trim();
        if (!pin) { showToast('Enter your admin PIN'); return; }
        LiveSync.adminReset(pin).then(success => {
            if (success) { closeModal(); renderSettings(); }
        });
    }

    function addSession() {
        const newId = `session-${Date.now()}`;
        const maxOrder = Math.max(...S.config.sessions.map(s => s.order), 0);
        S.config.sessions.push({
            id: newId,
            name: `Session ${S.config.sessions.length + 1}`,
            format: 'singles',
            order: maxOrder + 1
        });
        saveState();
        renderSettings();
        showToast('Session added');
    }

    function deleteSession(sessionId) {
        const matchesInSession = Object.values(S.matches).filter(m => m.sessionId === sessionId);
        if (matchesInSession.length > 0) {
            if (!confirm(`This session has ${matchesInSession.length} match(es). Delete anyway?`)) return;
        }
        S.config.sessions = S.config.sessions.filter(s => s.id !== sessionId);
        // Remove matches in this session
        Object.keys(S.matches).forEach(matchId => {
            if (S.matches[matchId].sessionId === sessionId) {
                delete S.matches[matchId];
            }
        });
        // Detach bonus events from deleted session (make standalone)
        Object.values(S.bonusEvents).forEach(evt => {
            if (evt.sessionId === sessionId) evt.sessionId = null;
        });
        saveState();
        renderSettings();
        showToast('Session deleted');
    }

    function moveSessionUp(sessionId) {
        const sessions = S.config.sessions.sort((a, b) => a.order - b.order);
        const index = sessions.findIndex(s => s.id === sessionId);
        if (index > 0) {
            [sessions[index].order, sessions[index - 1].order] = [sessions[index - 1].order, sessions[index].order];
            saveState();
            renderSettings();
        }
    }

    function moveSessionDown(sessionId) {
        const sessions = S.config.sessions.sort((a, b) => a.order - b.order);
        const index = sessions.findIndex(s => s.id === sessionId);
        if (index < sessions.length - 1) {
            [sessions[index].order, sessions[index + 1].order] = [sessions[index + 1].order, sessions[index].order];
            saveState();
            renderSettings();
        }
    }

    function addBonusEvent() {
        const id = 'bonus-' + Date.now();
        const maxOrder = Math.max(...Object.values(S.bonusEvents).map(e => e.order || 0), 0);
        S.bonusEvents[id] = {
            id,
            name: 'New Bonus Event',
            sessionId: null,
            pointsA: 0,
            pointsB: 0,
            notesA: '',
            notesB: '',
            order: maxOrder + 1,
        };
        saveState();
        renderSettings();
        showToast('Bonus event added');
    }

    function deleteBonusEvent(id) {
        const evt = S.bonusEvents[id];
        if (!evt) return;
        if (!confirm(`Delete bonus event "${evt.name}"?`)) return;
        delete S.bonusEvents[id];
        saveState();
        renderSettings();
        showToast('Bonus event deleted');
    }

    function resetAll() {
        if (!confirm('This will delete ALL data - players, matches, scores, everything. Are you sure?')) return;
        if (!confirm('Really? This cannot be undone.')) return;
        localStorage.removeItem(STORAGE_KEY);
        S = defaultState();
        saveState(); renderTab(S.ui.activeTab);
        showToast('All data reset');
    }

    // ─────────────────────────────────────────────────────────
    // ADD TO HOME SCREEN
    // ─────────────────────────────────────────────────────────
    const INSTALL_KEY = 'smashters-install-dismissed';
    let deferredInstallPrompt = null;

    function isStandalone() {
        return window.matchMedia('(display-mode: standalone)').matches
            || window.navigator.standalone === true;
    }

    function isIOS() {
        return /iphone|ipad|ipod/i.test(navigator.userAgent);
    }

    function isAndroid() {
        return /android/i.test(navigator.userAgent);
    }

    function installDismissed() {
        return localStorage.getItem(INSTALL_KEY) === 'true';
    }

    function dismissInstall() {
        localStorage.setItem(INSTALL_KEY, 'true');
        document.getElementById('installBanner').classList.remove('show');
    }

    function confirmInstalled() {
        localStorage.setItem(INSTALL_KEY, 'installed');
        document.getElementById('installBanner').classList.remove('show');
        showToast('Awesome! Launch from your Home Screen anytime.');
    }

    // Share icon SVG for iOS instructions
    const IOS_SHARE_SVG = `<svg class="share-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 3v12M5 10l7-7 7 7"/><path d="M5 17h14v4H5z" fill="none"/></svg>`;

    function showInstallBanner() {
        const banner = document.getElementById('installBanner');
        if (!banner) return;

        if (isIOS()) {
            // iOS: show manual instructions
            banner.innerHTML = `
                <div class="install-banner-top">
                    <img src="assets/images/apple-touch-icon.png" class="install-banner-icon" alt="">
                    <div class="install-banner-text">
                        <strong>Add to Home Screen</strong>
                        <span>Get the full app experience with one tap</span>
                    </div>
                    <button class="install-banner-close" onclick="dismissInstall()" aria-label="Close">&times;</button>
                </div>
                <div class="install-ios-steps">
                    <div><span class="step-num">1</span>Tap the <strong>Share</strong> button ${IOS_SHARE_SVG} at the bottom of Safari</div>
                    <div style="margin-top:6px;"><span class="step-num">2</span>Scroll down and tap <strong>Add to Home Screen</strong></div>
                    <div style="margin-top:6px;"><span class="step-num">3</span>Tap <strong>Add</strong> in the top right</div>
                </div>
                <div class="install-banner-actions">
                    <button class="btn btn-gold" onclick="confirmInstalled()">Done - I Added It</button>
                    <button class="btn btn-outline" style="border-color:rgba(255,255,255,0.3);color:#fff;" onclick="dismissInstall()">Not Now</button>
                </div>`;
        } else if (deferredInstallPrompt) {
            // Android/Chrome: native install prompt available
            banner.innerHTML = `
                <div class="install-banner-top">
                    <img src="assets/images/apple-touch-icon.png" class="install-banner-icon" alt="">
                    <div class="install-banner-text">
                        <strong>Add to Home Screen</strong>
                        <span>Quick access from your Home Screen</span>
                    </div>
                    <button class="install-banner-close" onclick="dismissInstall()" aria-label="Close">&times;</button>
                </div>
                <div class="install-banner-actions">
                    <button class="btn btn-gold" onclick="triggerNativeInstall()">Add to Home Screen</button>
                    <button class="btn btn-outline" style="border-color:rgba(255,255,255,0.3);color:#fff;" onclick="dismissInstall()">Not Now</button>
                </div>`;
        } else {
            // Other mobile browsers: generic instructions
            banner.innerHTML = `
                <div class="install-banner-top">
                    <img src="assets/images/apple-touch-icon.png" class="install-banner-icon" alt="">
                    <div class="install-banner-text">
                        <strong>Add to Home Screen</strong>
                        <span>Use your browser menu to add this app</span>
                    </div>
                    <button class="install-banner-close" onclick="dismissInstall()" aria-label="Close">&times;</button>
                </div>
                <div class="install-banner-actions">
                    <button class="btn btn-gold" onclick="confirmInstalled()">Done - I Added It</button>
                    <button class="btn btn-outline" style="border-color:rgba(255,255,255,0.3);color:#fff;" onclick="dismissInstall()">Not Now</button>
                </div>`;
        }
        banner.classList.add('show');
    }

    async function triggerNativeInstall() {
        if (!deferredInstallPrompt) return;
        deferredInstallPrompt.prompt();
        const result = await deferredInstallPrompt.userChoice;
        if (result.outcome === 'accepted') {
            confirmInstalled();
        }
        deferredInstallPrompt = null;
    }

    // Capture the Chrome/Edge install prompt before it auto-fires
    window.addEventListener('beforeinstallprompt', (e) => {
        e.preventDefault();
        deferredInstallPrompt = e;
        // If banner check hasn't run yet, it will pick this up in init
        // If it already ran, show banner now
        if (!isStandalone() && !installDismissed()) {
            showInstallBanner();
        }
    });

    // Detect when app is successfully installed
    window.addEventListener('appinstalled', () => {
        deferredInstallPrompt = null;
        confirmInstalled();
    });

    function checkInstallBanner() {
        // Already running as installed app
        if (isStandalone()) return;
        // User already dismissed or confirmed
        if (installDismissed()) return;
        // Only show on mobile-ish devices
        if (!isIOS() && !isAndroid() && !deferredInstallPrompt) return;
        // Small delay so it doesn't compete with splash screen
        setTimeout(() => showInstallBanner(), 3500);
    }

    // ─────────────────────────────────────────────────────────
    // FIREBASE & LIVE SYNC
    // ─────────────────────────────────────────────────────────
    const FIREBASE_CONFIG = {
        apiKey: "AIzaSyDZlbkZMkfmFk1CS1i51JQ1NuknlNae0zo",
        authDomain: "bunchbets.firebaseapp.com",
        databaseURL: "https://bunchbets-default-rtdb.firebaseio.com",
        projectId: "bunchbets",
        storageBucket: "bunchbets.firebasestorage.app",
        messagingSenderId: "267555779116",
        appId: "1:267555779116:web:af1e05bacb82f0d4fe5789"
    };

    const LiveSync = {
        db: null,
        eventRef: null,
        eventCode: null,
        scorerCode: null,
        matchCodes: {},
        isAdmin: false,
        isScorer: false,
        isViewer: false,
        scorerMatchId: null,
        adminPin: null,
        listeners: [],
        _suppressListener: false,

        init() {
            if (this.db) return true;
            try {
                if (typeof firebase === 'undefined') {
                    console.warn('Firebase SDK not loaded');
                    return false;
                }
                if (!firebase.apps?.length) firebase.initializeApp(FIREBASE_CONFIG);
                this.db = firebase.database();
                return true;
            } catch (e) {
                console.error('Firebase init failed:', e);
                return false;
            }
        },

        generateCode(len) {
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
            let code = '';
            for (let i = 0; i < len; i++) code += chars[Math.floor(Math.random() * chars.length)];
            return code;
        },

        // Auto-start: Always live with hardcoded event
        async autoStart() {
            if (!this.init()) return false;

            this.eventCode = 'smashsters-live'; // Hardcoded event ID
            this.scorerCode = '6969';
            this.adminPin = '1313';
            this.isAdmin = true;
            this.isViewer = false;
            this.isScorer = false;
            this.eventRef = this.db.ref('smashters/' + this.eventCode);

            try {
                // FIRST: Check if Firebase already has data
                const snapshot = await this.eventRef.once('value');
                const firebaseData = snapshot.val();

                if (firebaseData && firebaseData.updatedAt) {
                    // Firebase has data - compare with local
                    const localPlayerCount = Object.keys(S.players || {}).length;
                    const firebasePlayerCount = Object.keys(firebaseData.players || {}).length;
                    const localTimestamp = S._lastSync || 0;
                    const firebaseTimestamp = firebaseData.updatedAt || 0;

                    console.log('Firebase sync: Found existing data', {
                        firebaseTimestamp,
                        localTimestamp,
                        firebasePlayerCount,
                        localPlayerCount
                    });

                    // PRIORITY 1: If Firebase has more players, always pull from Firebase
                    if (firebasePlayerCount > localPlayerCount) {
                        console.log('Pulling from Firebase (has more players)...');
                        this.applyState(firebaseData);
                        renderTab(S.ui.activeTab);
                        showToast('Synced from cloud');
                    }
                    // PRIORITY 2: If local has more players, push to Firebase
                    else if (localPlayerCount > firebasePlayerCount) {
                        // Validate local data before pushing
                        const localValidation = this.validateState(S, 'Local');
                        if (localValidation.valid) {
                            console.log('Pushing to Firebase (local has more players)...');
                            await this.eventRef.set({
                                config: S.config,
                                players: S.players,
                                matches: S.matches,
                                bonusEvents: S.bonusEvents,
                                scorerCode: this.scorerCode,
                                adminPin: this.adminPin,
                                updatedAt: firebase.database.ServerValue.TIMESTAMP,
                            });
                        } else {
                            console.error(`🛑 BLOCKED pushing corrupted local data: ${localValidation.reason}`);
                            console.log('Pulling from Firebase instead...');
                            this.applyState(firebaseData);
                            renderTab(S.ui.activeTab);
                            showToast('Local data corrupted - restored from cloud');
                        }
                    }
                    // PRIORITY 3: Same player count - use timestamp
                    else if (firebaseTimestamp > localTimestamp) {
                        console.log('Pulling from Firebase (newer timestamp)...');
                        this.applyState(firebaseData);
                        renderTab(S.ui.activeTab);
                        showToast('Synced from cloud');
                    } else {
                        // Validate local data before pushing
                        const localValidation = this.validateState(S, 'Local');
                        if (localValidation.valid) {
                            console.log('Pushing to Firebase (local is newer)...');
                            await this.eventRef.set({
                                config: S.config,
                                players: S.players,
                                matches: S.matches,
                                bonusEvents: S.bonusEvents,
                                scorerCode: this.scorerCode,
                                adminPin: this.adminPin,
                                updatedAt: firebase.database.ServerValue.TIMESTAMP,
                            });
                        } else {
                            console.error(`🛑 BLOCKED pushing corrupted local data: ${localValidation.reason}`);
                            console.log('Pulling from Firebase instead...');
                            this.applyState(firebaseData);
                            renderTab(S.ui.activeTab);
                            showToast('Local data corrupted - restored from cloud');
                        }
                    }
                } else {
                    // No Firebase data yet - push current state
                    console.log('No Firebase data found, pushing local data...');
                    await this.eventRef.set({
                        config: S.config,
                        players: S.players,
                        matches: S.matches,
                        bonusEvents: S.bonusEvents,
                        scorerCode: this.scorerCode,
                        adminPin: this.adminPin,
                        updatedAt: firebase.database.ServerValue.TIMESTAMP,
                    });
                }

                // Store scorer code lookup
                await this.db.ref('smashters-scorer-codes/6969').set({
                    eventCode: this.eventCode,
                    isAllScorer: true,
                });

                // Listen for updates from other devices
                const listener = this.eventRef.on('value', (snap) => {
                    if (this._suppressListener) return;
                    const val = snap.val();
                    if (val && val.updatedAt !== S._lastSync) {
                        console.log('Received update from Firebase');
                        this.applyState(val);
                        renderTab(S.ui.activeTab);
                    }
                });
                this.listeners.push({ ref: this.eventRef, event: 'value', callback: listener });

                return true;
            } catch (e) {
                console.error('Auto-start failed:', e);
                return false;
            }
        },

        // Admin: Go Live
        async goLive(pin) {
            if (!this.init()) { showToast('Firebase not available'); return false; }

            this.eventCode = this.generateCode(5);
            this.scorerCode = '6969'; // Hardcoded scorer code
            this.adminPin = pin || '1234';
            this.isAdmin = true;
            this.isViewer = false;
            this.isScorer = false;
            this.eventRef = this.db.ref('smashters/' + this.eventCode);

            // Generate match codes (kept for backward compatibility, but scorer code is preferred)
            this.matchCodes = {};
            const codeToMatch = {};
            Object.keys(S.matches).forEach(matchId => {
                const code = this.generateCode(4);
                this.matchCodes[matchId] = code;
                codeToMatch[code] = matchId;
            });

            try {
                await this.eventRef.set({
                    config: S.config,
                    players: S.players,
                    matches: S.matches,
                    bonusEvents: S.bonusEvents,
                    matchCodes: codeToMatch,
                    scorerCode: this.scorerCode,
                    adminPin: this.adminPin,
                    updatedAt: firebase.database.ServerValue.TIMESTAMP,
                });

                // Store match code lookups at top level for scorer access
                const updates = {};
                Object.entries(codeToMatch).forEach(([code, matchId]) => {
                    updates['smashters-codes/' + code] = {
                        eventCode: this.eventCode,
                        matchId: matchId,
                    };
                });
                // Store scorer code lookup (grants access to all matches)
                updates['smashters-scorer-codes/' + this.scorerCode] = {
                    eventCode: this.eventCode,
                    isAllScorer: true,
                };
                if (Object.keys(updates).length > 0) {
                    await this.db.ref().update(updates);
                }

                // Save live state locally
                localStorage.setItem('smashters-live', JSON.stringify({
                    eventCode: this.eventCode,
                    adminPin: this.adminPin,
                    scorerCode: this.scorerCode,
                    matchCodes: this.matchCodes,
                    isAdmin: true,
                }));

                this.updateBanner();
                showToast('Event is LIVE! Code: ' + this.eventCode);
                renderTab(S.ui.activeTab);
                return true;
            } catch (e) {
                console.error('Go live failed:', e);
                showToast('Failed to go live: ' + e.message);
                this.isAdmin = false;
                return false;
            }
        },

        // Sync local state to Firebase
        syncToFirebase() {
            if (!this.eventRef) return;

            // SAFETY: Validate local data before pushing to Firebase
            const validation = this.validateState(S, 'Local (pre-sync)');
            if (!validation.valid) {
                console.error(`🛑 Sync blocked: ${validation.reason} - not pushing to Firebase`);
                showToast(`Sync blocked: ${validation.reason}`);
                return;
            }

            if (this.isAdmin) {
                this._suppressListener = true;
                this.eventRef.update({
                    config: S.config,
                    players: S.players,
                    matches: S.matches,
                    bonusEvents: S.bonusEvents,
                    updatedAt: firebase.database.ServerValue.TIMESTAMP,
                }).then(() => {
                    setTimeout(() => { this._suppressListener = false; }, 500);
                }).catch(e => {
                    this._suppressListener = false;
                    console.error('Sync failed:', e);
                });
            } else if (this.isScorer) {
                if (this.scorerMatchId === null) {
                    // All-scorer: sync all matches
                    this._suppressListener = true;
                    this.eventRef.update({
                        matches: S.matches,
                        updatedAt: firebase.database.ServerValue.TIMESTAMP,
                    }).then(() => {
                        setTimeout(() => { this._suppressListener = false; }, 500);
                    }).catch(e => {
                        this._suppressListener = false;
                        console.error('Score sync failed:', e);
                    });
                } else {
                    // Single-match scorer: sync only their match
                    const match = S.matches[this.scorerMatchId];
                    if (match) {
                        this._suppressListener = true;
                        Promise.all([
                            this.eventRef.child('matches/' + this.scorerMatchId).set(match),
                            this.eventRef.child('updatedAt').set(firebase.database.ServerValue.TIMESTAMP),
                        ]).then(() => {
                            setTimeout(() => { this._suppressListener = false; }, 500);
                        }).catch(e => {
                            this._suppressListener = false;
                            console.error('Score sync failed:', e);
                        });
                    }
                }
            }
        },

        // Validate state data to detect corruption
        validateState(state, source = 'unknown') {
            if (!state) return { valid: false, reason: 'No state data' };

            const playerCount = Object.keys(state.players || {}).length;
            const matchCount = Object.keys(state.matches || {}).length;

            // Check if we have players
            if (playerCount === 0) {
                console.warn(`${source} validation: No players found`);
                return { valid: false, reason: 'No players' };
            }

            // Check for corrupted handicaps (all zeros or all null)
            const players = Object.values(state.players || {});
            const handicaps = players.map(p => parseInt(p.handicap) || 0);
            const nonZeroHandicaps = handicaps.filter(h => h > 0).length;

            // If we have more than 2 players and ALL handicaps are 0, it's likely corrupted
            if (playerCount > 2 && nonZeroHandicaps === 0) {
                console.error(`${source} validation FAILED: All handicaps are 0 (likely corrupted)`);
                return { valid: false, reason: 'All handicaps are 0' };
            }

            // Check config
            if (!state.config || !state.config.teamA || !state.config.teamB) {
                console.warn(`${source} validation: Missing config data`);
                return { valid: false, reason: 'Missing config' };
            }

            console.log(`${source} validation PASSED: ${playerCount} players, ${matchCount} matches, ${nonZeroHandicaps}/${playerCount} with handicaps`);
            return { valid: true };
        },

        // Apply remote state to local
        applyState(val) {
            if (!val) return;

            // CRITICAL: Validate incoming data before applying
            const validation = this.validateState(val, 'Firebase');
            if (!validation.valid) {
                console.error(`🛑 BLOCKED corrupted Firebase data: ${validation.reason}`);
                showToast(`Blocked corrupted sync: ${validation.reason}`);
                return; // Don't apply corrupted data!
            }

            const base = defaultState();
            if (val.config) {
                S.config = {
                    ...base.config, ...val.config,
                    teamA: { ...base.config.teamA, ...(val.config?.teamA || {}) },
                    teamB: { ...base.config.teamB, ...(val.config?.teamB || {}) },
                    courseHoles: val.config?.courseHoles || base.config.courseHoles,
                };
            }
            S.players = val.players || {};
            S.matches = val.matches || {};
            S.bonusEvents = val.bonusEvents || {};

            // Ensure all matches have holes property initialized
            Object.values(S.matches).forEach(match => {
                if (!match.holes) {
                    match.holes = {};
                }
            });

            // Store the timestamp of this sync
            S._lastSync = val.updatedAt || Date.now();
            saveState(true); // Save to localStorage, skip Firebase sync (we're already pulling FROM Firebase)
            document.documentElement.style.setProperty('--team-a-color', S.config.teamA.color);
            document.documentElement.style.setProperty('--team-b-color', S.config.teamB.color);
            document.querySelector('.header-titles h1').textContent = S.config.eventName;
            document.querySelector('.header-titles .subtitle').textContent = S.config.clubName;
        },

        // Join as viewer (leaderboard only)
        async joinAsViewer(code) {
            if (!this.init()) { showToast('Firebase not available'); return false; }

            code = code.toUpperCase().trim();
            if (!code) { showToast('Enter an event code'); return false; }

            const ref = this.db.ref('smashters/' + code);
            try {
                const snap = await ref.once('value');
                if (!snap.exists()) { showToast('Event not found. Check the code.'); return false; }

                this.eventCode = code;
                this.eventRef = ref;
                this.isViewer = true;
                this.isAdmin = false;
                this.isScorer = false;

                this.applyState(snap.val());

                // Listen for live updates
                const listener = ref.on('value', (s) => {
                    if (this._suppressListener) return;
                    const val = s.val();
                    if (val) {
                        this.applyState(val);
                        renderTab(S.ui.activeTab);
                    }
                });
                this.listeners.push({ ref, event: 'value', callback: listener });

                document.body.classList.add('viewer-mode');
                this.updateBanner();
                switchTab('leaderboard');
                showToast('Connected! Viewing live scores.');
                return true;
            } catch (e) {
                showToast('Connection failed: ' + e.message);
                return false;
            }
        },

        // Join as scorer with scorer code (all matches) or match code (single match)
        async joinAsScorer(code) {
            if (!this.init()) { showToast('Firebase not available'); return false; }

            code = code.toUpperCase().trim();
            if (!code) { showToast('Enter a scorer code'); return false; }

            try {
                // First check if this is an all-scorer code
                const scorerCodeSnap = await this.db.ref('smashters-scorer-codes/' + code).once('value');
                let eventCode, matchId = null;

                if (scorerCodeSnap.exists()) {
                    // All-scorer code - can score any match
                    eventCode = scorerCodeSnap.val().eventCode;
                } else {
                    // Check if it's a match-specific code (backward compatibility)
                    const matchCodeSnap = await this.db.ref('smashters-codes/' + code).once('value');
                    if (!matchCodeSnap.exists()) {
                        showToast('Invalid scorer code.');
                        return false;
                    }
                    const data = matchCodeSnap.val();
                    eventCode = data.eventCode;
                    matchId = data.matchId;
                }

                const ref = this.db.ref('smashters/' + eventCode);
                const snap = await ref.once('value');
                if (!snap.exists()) { showToast('Event not found.'); return false; }

                this.eventCode = eventCode;
                this.eventRef = ref;
                this.isScorer = true;
                this.isAdmin = false;
                this.isViewer = false;
                this.scorerMatchId = matchId; // null = can score all matches

                this.applyState(snap.val());

                // Listen for updates
                const listener = ref.on('value', (s) => {
                    if (this._suppressListener) return;
                    const val = s.val();
                    if (val) {
                        this.applyState(val);
                        renderTab(S.ui.activeTab);
                    }
                });
                this.listeners.push({ ref, event: 'value', callback: listener });

                if (matchId) {
                    // Single match scorer
                    S.ui.activeMatchId = matchId;
                    if (S.matches[matchId]) {
                        S.ui.scoringHole = findNextUnplayedHole(S.matches[matchId]);
                    }
                    const match = S.matches[matchId];
                    if (match) {
                        const names = [...match.teamA, ...match.teamB].map(id => getPlayerName(id)).join(', ');
                        showToast('Scoring: ' + names);
                    }
                } else {
                    // All-match scorer
                    showToast('Connected as scorer - you can score all matches!');
                }

                document.body.classList.add('scorer-mode');
                this.updateBanner();
                switchTab('scoring');
                return true;
            } catch (e) {
                showToast('Connection failed: ' + e.message);
                return false;
            }
        },

        // Disconnect from live event
        disconnect() {
            this.listeners.forEach(l => l.ref.off(l.event, l.callback));
            this.listeners = [];
            this.eventRef = null;
            this.eventCode = null;
            this.scorerCode = null;
            this.isAdmin = false;
            this.isViewer = false;
            this.isScorer = false;
            this.scorerMatchId = null;
            this.matchCodes = {};
            this.adminPin = null;
            localStorage.removeItem('smashters-live');
            document.body.classList.remove('viewer-mode', 'scorer-mode');
            this.updateBanner();
            showToast('Disconnected');
            S = loadState();
            renderTab(S.ui.activeTab);
        },

        // Admin: Stop the live event and clean up Firebase
        async stopLive() {
            if (!this.isAdmin || !this.eventRef) return;

            try {
                // Clean up code lookups
                const codeUpdates = {};
                Object.values(this.matchCodes).forEach(code => {
                    codeUpdates['smashters-codes/' + code] = null;
                });
                if (this.scorerCode) {
                    codeUpdates['smashters-scorer-codes/' + this.scorerCode] = null;
                }
                if (Object.keys(codeUpdates).length > 0) {
                    await this.db.ref().update(codeUpdates);
                }
                await this.eventRef.remove();
            } catch (e) {
                console.error('Cleanup error:', e);
            }

            this.disconnect();
            showToast('Live event stopped');
        },

        // Admin: Reset all scores in the live event
        async adminReset(pin) {
            if (!this.eventRef) { showToast('Not connected'); return false; }

            try {
                const snap = await this.eventRef.child('adminPin').once('value');
                if (snap.val() !== pin) { showToast('Incorrect PIN'); return false; }

                // Reset all match scores
                Object.values(S.matches).forEach(m => {
                    m.holes = {};
                    m.status = 'pending';
                });

                await this.eventRef.update({
                    matches: S.matches,
                    updatedAt: firebase.database.ServerValue.TIMESTAMP,
                });

                saveState();
                renderTab(S.ui.activeTab);
                showToast('All scores have been reset');
                return true;
            } catch (e) {
                showToast('Reset failed: ' + e.message);
                return false;
            }
        },

        // Restore admin session from localStorage
        restoreSession() {
            try {
                const saved = localStorage.getItem('smashters-live');
                if (!saved) return;
                const session = JSON.parse(saved);
                if (session.isAdmin && session.eventCode) {
                    if (!this.init()) return;
                    this.eventCode = session.eventCode;
                    this.scorerCode = session.scorerCode || null;
                    this.adminPin = session.adminPin;
                    this.matchCodes = session.matchCodes || {};
                    this.isAdmin = true;
                    this.eventRef = this.db.ref('smashters/' + this.eventCode);
                    this.updateBanner();
                }
            } catch (e) {
                console.error('Restore session error:', e);
            }
        },

        // Update the banner display
        updateBanner() {
            const banner = document.getElementById('liveBanner');
            if (!banner) return;

            if (this.isScorer) {
                banner.className = 'live-banner active';
                banner.style.background = 'var(--masters-green)';
                banner.innerHTML = `
                    <span class="live-dot"></span>
                    SCORING MODE — All Matches
                    <button class="live-banner-btn" onclick="LiveSync.disableScoring()">Exit Scoring</button>`;
            } else {
                banner.className = 'live-banner';
                banner.innerHTML = '';
            }
        },

        // Disable scoring mode
        disableScoring() {
            this.isScorer = false;
            this.scorerMatchId = null;
            this.updateBanner();
            showToast('Scoring disabled');
            switchTab('leaderboard');
        },

        // Check if user can edit scores for a given match
        canScore(matchId) {
            if (this.isViewer) return false;
            if (this.isScorer) {
                // If scorerMatchId is null, can score all matches
                if (this.scorerMatchId === null) return true;
                // Otherwise, can only score the assigned match
                return this.scorerMatchId === matchId;
            }
            return true; // Admin or local mode
        },
    };

    // ─────────────────────────────────────────────────────────
    // INIT
    // ─────────────────────────────────────────────────────────
    // ─────────────────────────────────────────────────────────
    // SPLASH SCREEN
    // ─────────────────────────────────────────────────────────
    const SPLASH_SESSION_KEY = 'smashters-splash-shown';

    function shouldShowSplash() {
        // Show splash on every fresh launch, but not when returning
        // from background (tab switch, app switcher, etc.)
        return !sessionStorage.getItem(SPLASH_SESSION_KEY);
    }

    // ─────────────────────────────────────────────────────────
    // SPLASH AUDIO (Web Audio API — no lock screen controls)
    // ─────────────────────────────────────────────────────────
    const SplashAudio = {
        _ctx: null,
        _source: null,
        _gain: null,
        _stopped: false,
        _fadeRAF: null,

        // Call from user gesture (opt-in tap) — fetches, decodes, and plays
        play() {
            this._stopped = false;
            try {
                this._ctx = new (window.AudioContext || window.webkitAudioContext)();
            } catch(e) { return; }

            this._gain = this._ctx.createGain();
            this._gain.gain.value = 1;
            this._gain.connect(this._ctx.destination);

            fetch('assets/audio/splash_audio.mp3')
                .then(r => r.arrayBuffer())
                .then(buf => this._ctx.decodeAudioData(buf))
                .then(decoded => {
                    if (this._stopped) return;
                    this._source = this._ctx.createBufferSource();
                    this._source.buffer = decoded;
                    this._source.connect(this._gain);
                    this._source.start(0);
                })
                .catch(() => {});
        },

        fadeOut(duration) {
            duration = duration || 2000;
            if (!this._gain || this._stopped) return;

            const fadeStart = performance.now();
            const startVol = this._gain.gain.value;

            const fade = (now) => {
                if (this._stopped) return;
                const progress = Math.min((now - fadeStart) / duration, 1);
                if (this._gain) this._gain.gain.value = Math.max(0, startVol * (1 - progress));
                if (progress < 1) {
                    this._fadeRAF = requestAnimationFrame(fade);
                } else {
                    this.stop();
                }
            };
            this._fadeRAF = requestAnimationFrame(fade);
        },

        stop() {
            this._stopped = true;
            if (this._fadeRAF) { cancelAnimationFrame(this._fadeRAF); this._fadeRAF = null; }
            try { if (this._source) this._source.stop(); } catch(e) {}
            if (this._gain) this._gain.disconnect();
            if (this._ctx) this._ctx.close().catch(() => {});
            this._source = null;
            this._gain = null;
            this._ctx = null;
        },
    };

    // ─────────────────────────────────────────────────────────
    // MOBILE GATE & OPT-IN LOGIC
    // ─────────────────────────────────────────────────────────
    function showMobileGate() {
        const gate = document.getElementById('mobileGate');
        const instructions = document.getElementById('gateInstructions');

        if (isIOS()) {
            instructions.innerHTML = `
                <h3>How to Install</h3>
                <div class="gate-step">
                    <span class="gate-step-num">1</span>
                    <span>Tap the <strong>Share</strong> button <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align:middle;margin:0 2px"><path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"/><polyline points="16 6 12 2 8 6"/><line x1="12" y1="2" x2="12" y2="15"/></svg> at the bottom of Safari</span>
                </div>
                <div class="gate-step">
                    <span class="gate-step-num">2</span>
                    <span>Scroll down and tap <strong>"Add to Home Screen"</strong></span>
                </div>
                <div class="gate-step">
                    <span class="gate-step-num">3</span>
                    <span>Tap <strong>"Add"</strong> in the top right</span>
                </div>
                <div class="gate-step">
                    <span class="gate-step-num">4</span>
                    <span>Open the app from your home screen</span>
                </div>`;
        } else {
            instructions.innerHTML = `
                <h3>How to Install</h3>
                <div class="gate-step">
                    <span class="gate-step-num">1</span>
                    <span>Tap the <strong>menu (&#8942;)</strong> in your browser</span>
                </div>
                <div class="gate-step">
                    <span class="gate-step-num">2</span>
                    <span>Tap <strong>"Add to Home Screen"</strong> or <strong>"Install App"</strong></span>
                </div>
                <div class="gate-step">
                    <span class="gate-step-num">3</span>
                    <span>Open the app from your home screen</span>
                </div>`;
        }

        gate.classList.add('active');
    }

    function showOptIn() {
        document.getElementById('optInPage').classList.add('active');
    }

    function hideOptIn() {
        const optIn = document.getElementById('optInPage');
        optIn.classList.remove('active');
    }

    function isMobile() {
        return isIOS() || isAndroid() ||
            /mobile|phone/i.test(navigator.userAgent);
    }

    // ─────────────────────────────────────────────────────────
    // SPLASH FLOW
    // ─────────────────────────────────────────────────────────
    function showSplash() {
        const phase1 = document.getElementById('splashPhase1');
        const videoPhase = document.getElementById('splashVideo');
        const videoEl = document.getElementById('splashVideoEl');
        const phase2 = document.getElementById('splashPhase2');
        const themeMeta = document.querySelector('meta[name="theme-color"]');
        document.getElementById('splashYear').textContent = S.config.year;

        sessionStorage.setItem(SPLASH_SESSION_KEY, '1');

        if (themeMeta) themeMeta.content = '#ffffff';

        phase1.classList.remove('hidden', 'fade-out');
        videoPhase.classList.remove('fade-out');
        videoPhase.classList.add('hidden');
        phase2.classList.remove('fade-out', 'active');
        phase2.classList.add('hidden');

        // Audio starts immediately — already unlocked by opt-in tap
        SplashAudio.play();

        // === PHASE 1: DFGC Presents (3.75s) ===
        setTimeout(() => {
            if (themeMeta) themeMeta.content = '#000000';

            // Fade out phase 1, reveal video (already baked at 0.75x, 30fps)
            phase1.classList.add('fade-out');
            videoPhase.classList.remove('hidden');
            videoEl.currentTime = 0;
            videoEl.play().catch(() => {});

            setTimeout(() => { phase1.classList.add('hidden'); }, 1000);

            // === VIDEO PHASE: ~12.7s at 0.6x, 2s fade-to-black baked in ===
            // Start crossfade at 10s — 3s overlap for smooth dissolve
            setTimeout(() => {
                if (themeMeta) themeMeta.content = '#00432e';

                // Crossfade: video dissolves (3s CSS) while phase 2 fades in
                phase2.classList.remove('hidden');
                phase2.classList.add('active');
                videoPhase.classList.add('fade-out');

                setTimeout(() => { videoPhase.classList.add('hidden'); }, 3500);

                // === PHASE 2: The Smashters (4.5s then burn) ===
                setTimeout(() => {
                    startBurnEffect(phase2);
                }, 4500);
            }, 10000);
        }, 3750);
    }

    function hideSplash() {
        document.getElementById('splashPhase1').classList.add('hidden');
        document.getElementById('splashVideo').classList.add('hidden');
        document.getElementById('splashPhase2').classList.add('hidden');
        const vid = document.getElementById('splashVideoEl');
        if (vid) { vid.pause(); vid.currentTime = 0; }
    }

    function startBurnEffect(phase2El) {
        const canvas = document.getElementById('burnCanvas');
        const ctx = canvas.getContext('2d');
        const W = window.innerWidth;
        const H = window.innerHeight;
        canvas.width = W;
        canvas.height = H;

        // No html2canvas! Real DOM stays visible, clipped via CSS clip-path.
        // Canvas only draws fire/glow/ember effects on top.

        // Smooth noise: generate wide control points and interpolate
        const NUM_POINTS = 20;
        const controlPoints = [];
        for (let i = 0; i <= NUM_POINTS; i++) {
            controlPoints.push(Math.random() * 60 - 30);
        }
        function smoothNoise(x, t) {
            const nx = (x / W) * NUM_POINTS + t * 4;
            const idx = Math.floor(nx);
            const frac = nx - idx;
            const a = controlPoints[((idx % NUM_POINTS) + NUM_POINTS) % NUM_POINTS];
            const b = controlPoints[(((idx + 1) % NUM_POINTS) + NUM_POINTS) % NUM_POINTS];
            const smooth = frac * frac * (3 - 2 * frac);
            return a + (b - a) * smooth
                + Math.sin(x * 0.015 + t * 5) * 18
                + Math.sin(x * 0.04 + t * 3) * 10;
        }

        function buildBurnPath(baseY, t) {
            const points = [];
            const step = 4;
            for (let x = 0; x <= W; x += step) {
                points.push({ x, y: baseY + smoothNoise(x, t) });
            }
            return points;
        }

        const BURN_DURATION = 3200;
        const embers = [];
        const flames = [];
        let audioFading = false;
        const startTime = performance.now();

        function animate(now) {
            const elapsed = now - startTime;
            const progress = Math.min(elapsed / BURN_DURATION, 1);
            const eased = progress < 0.5
                ? 2 * progress * progress
                : 1 - Math.pow(-2 * progress + 2, 2) / 2;
            const baseY = H + 40 - eased * (H + 120);

            ctx.clearRect(0, 0, W, H);

            const burnPath = buildBurnPath(baseY, progress);

            // === 1. Clip the real DOM — show only ABOVE the burn edge ===
            // polygon: top-left, top-right, trace burn edge right→left, close
            let clipPoints = `0px 0px,${W}px 0px,`;
            // Trace burn edge from right to left
            for (let i = burnPath.length - 1; i >= 0; i -= 2) {
                const p = burnPath[i];
                clipPoints += `${p.x}px ${p.y}px,`;
            }
            // Remove trailing comma
            clipPoints = clipPoints.slice(0, -1);
            phase2El.style.clipPath = `polygon(${clipPoints})`;

            // === 2. Draw charring glow along burn edge ===
            ctx.save();

            // Wide outer orange glow
            ctx.beginPath();
            for (let i = 0; i < burnPath.length; i++) {
                const p = burnPath[i];
                if (i === 0) ctx.moveTo(p.x, p.y - 6);
                else ctx.lineTo(p.x, p.y - 6);
            }
            ctx.lineWidth = 24;
            ctx.strokeStyle = 'rgba(255, 120, 0, 0.4)';
            ctx.shadowBlur = 40;
            ctx.shadowColor = 'rgba(255, 100, 0, 0.8)';
            ctx.stroke();

            // Mid orange-red line
            ctx.beginPath();
            for (let i = 0; i < burnPath.length; i++) {
                const p = burnPath[i];
                if (i === 0) ctx.moveTo(p.x, p.y - 4);
                else ctx.lineTo(p.x, p.y - 4);
            }
            ctx.lineWidth = 12;
            ctx.strokeStyle = 'rgba(255, 140, 20, 0.7)';
            ctx.shadowBlur = 25;
            ctx.shadowColor = 'rgba(255, 160, 0, 0.9)';
            ctx.stroke();

            // Hot bright core
            ctx.beginPath();
            for (let i = 0; i < burnPath.length; i++) {
                const p = burnPath[i];
                if (i === 0) ctx.moveTo(p.x, p.y);
                else ctx.lineTo(p.x, p.y);
            }
            ctx.lineWidth = 4;
            ctx.strokeStyle = 'rgba(255, 230, 140, 0.95)';
            ctx.shadowBlur = 15;
            ctx.shadowColor = 'rgba(255, 200, 50, 1)';
            ctx.stroke();
            ctx.restore();

            // === 3. Draw flame tongues rising from the burn edge ===
            if (progress < 1) {
                if (Math.random() < 0.6) {
                    const px = Math.floor(Math.random() * burnPath.length);
                    const bp = burnPath[px];
                    flames.push({
                        x: bp.x,
                        baseY: bp.y,
                        width: Math.random() * 25 + 15,
                        height: Math.random() * 50 + 30,
                        life: 1,
                        decay: Math.random() * 0.03 + 0.02,
                        sway: (Math.random() - 0.5) * 2,
                        phase: Math.random() * Math.PI * 2,
                    });
                }
            }

            for (let i = flames.length - 1; i >= 0; i--) {
                const f = flames[i];
                f.life -= f.decay;
                if (f.life <= 0) { flames.splice(i, 1); continue; }

                const flicker = Math.sin(now * 0.01 + f.phase) * 5;
                const tipX = f.x + f.sway * (1 - f.life) * 10 + flicker;
                const tipY = f.baseY - f.height * f.life;
                const halfW = f.width * f.life * 0.5;

                const outerGrad = ctx.createLinearGradient(tipX, tipY, tipX, f.baseY);
                outerGrad.addColorStop(0, `rgba(200, 50, 0, 0)`);
                outerGrad.addColorStop(0.3, `rgba(220, 80, 0, ${f.life * 0.5})`);
                outerGrad.addColorStop(0.7, `rgba(255, 130, 0, ${f.life * 0.7})`);
                outerGrad.addColorStop(1, `rgba(255, 80, 0, ${f.life * 0.3})`);

                ctx.beginPath();
                ctx.moveTo(tipX, tipY);
                ctx.quadraticCurveTo(tipX + halfW * 1.2, tipY + f.height * f.life * 0.5, f.x + halfW, f.baseY);
                ctx.lineTo(f.x - halfW, f.baseY);
                ctx.quadraticCurveTo(tipX - halfW * 1.2, tipY + f.height * f.life * 0.5, tipX, tipY);
                ctx.fillStyle = outerGrad;
                ctx.fill();

                const innerGrad = ctx.createLinearGradient(tipX, tipY + f.height * 0.3, tipX, f.baseY);
                innerGrad.addColorStop(0, `rgba(255, 255, 200, 0)`);
                innerGrad.addColorStop(0.4, `rgba(255, 230, 100, ${f.life * 0.6})`);
                innerGrad.addColorStop(1, `rgba(255, 200, 50, ${f.life * 0.3})`);

                const innerW = halfW * 0.5;
                ctx.beginPath();
                ctx.moveTo(tipX, tipY + f.height * 0.2);
                ctx.quadraticCurveTo(tipX + innerW, tipY + f.height * f.life * 0.6, f.x + innerW, f.baseY);
                ctx.lineTo(f.x - innerW, f.baseY);
                ctx.quadraticCurveTo(tipX - innerW, tipY + f.height * f.life * 0.6, tipX, tipY + f.height * 0.2);
                ctx.fillStyle = innerGrad;
                ctx.fill();
            }

            // === 4. Ember particles ===
            if (progress < 1) {
                const spawnCount = Math.floor(Math.random() * 5) + 2;
                for (let i = 0; i < spawnCount; i++) {
                    const px = Math.floor(Math.random() * burnPath.length);
                    const bp = burnPath[px];
                    embers.push({
                        x: bp.x,
                        y: bp.y - Math.random() * 10,
                        vx: (Math.random() - 0.5) * 2,
                        vy: -(Math.random() * 3 + 1.5),
                        size: Math.random() * 3 + 1.5,
                        life: 1,
                        decay: Math.random() * 0.012 + 0.006,
                        r: Math.floor(200 + Math.random() * 55),
                        g: Math.floor(80 + Math.random() * 140),
                        b: Math.floor(Math.random() * 30),
                    });
                }
            }

            ctx.save();
            for (let i = embers.length - 1; i >= 0; i--) {
                const e = embers[i];
                e.x += e.vx + (Math.random() - 0.5) * 0.8;
                e.y += e.vy;
                e.vy -= 0.02;
                e.life -= e.decay;
                e.size *= 0.998;

                if (e.life <= 0) { embers.splice(i, 1); continue; }

                ctx.globalAlpha = e.life;
                ctx.fillStyle = `rgb(${e.r},${e.g},${e.b})`;
                ctx.shadowBlur = e.size * 5;
                ctx.shadowColor = `rgba(${e.r},${e.g},${e.b},0.8)`;
                ctx.beginPath();
                ctx.arc(e.x, e.y, e.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();

            // Start fading audio as burn nears completion
            if (progress >= 0.8 && !audioFading) {
                audioFading = true;
                SplashAudio.fadeOut(2000);
            }

            if (progress < 1 || embers.length > 0 || flames.length > 0) {
                requestAnimationFrame(animate);
            } else {
                phase2El.classList.add('hidden');
                phase2El.style.clipPath = '';
                ctx.clearRect(0, 0, W, H);
                canvas.width = 0;
                SplashAudio.stop();
                canvas.height = 0;
            }
        }

        requestAnimationFrame(animate);
    }

    // ─────────────────────────────────────────────────────────
    // EXPORT MANAGER
    // ─────────────────────────────────────────────────────────
    const ExportManager = {
        async htmlToImage(htmlString, filename) {
            const container = document.createElement('div');
            container.innerHTML = htmlString;
            container.style.cssText = 'position:absolute;left:-9999px;top:0;background:white;padding:40px;width:800px;';
            document.body.appendChild(container);

            try {
                const canvas = await html2canvas(container, {
                    backgroundColor: '#ffffff',
                    scale: 2,
                    logging: false,
                    useCORS: true
                });

                document.body.removeChild(container);

                return new Promise((resolve) => {
                    canvas.toBlob(blob => {
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = filename;
                        a.click();
                        URL.revokeObjectURL(url);
                        showToast('Image downloaded!');
                        resolve(blob);
                    });
                });
            } catch (e) {
                document.body.removeChild(container);
                showToast('Export failed');
                console.error('Export error:', e);
            }
        },

        async htmlToPDF(htmlString, filename) {
            const container = document.createElement('div');
            container.innerHTML = htmlString;
            container.style.cssText = 'position:absolute;left:-9999px;top:0;background:white;padding:40px;width:800px;';
            document.body.appendChild(container);

            try {
                const canvas = await html2canvas(container, {
                    backgroundColor: '#ffffff',
                    scale: 2,
                    logging: false,
                    useCORS: true
                });

                document.body.removeChild(container);

                const imgData = canvas.toDataURL('image/png');
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF({
                    orientation: canvas.width > canvas.height ? 'landscape' : 'portrait',
                    unit: 'px',
                    format: [canvas.width / 2, canvas.height / 2]
                });

                pdf.addImage(imgData, 'PNG', 0, 0, canvas.width / 2, canvas.height / 2);
                pdf.save(filename);
                showToast('PDF downloaded!');
            } catch (e) {
                document.body.removeChild(container);
                showToast('Export failed');
                console.error('Export error:', e);
            }
        },

        buildTeamRosterHTML() {
            const teamA = getTeamPlayers('A');
            const teamB = getTeamPlayers('B');

            return `
                <style>
                    @font-face {
                        font-family: 'Azalea';
                        src: url('assets/fonts/Azalea.otf') format('opentype');
                    }
                </style>
                <div style="font-family:Georgia,serif;max-width:750px;">
                    <div style="text-align:center;margin-bottom:30px;">
                        <img src="assets/images/smashters-logo-green.png" alt="Smashters Logo" style="width:120px;height:auto;margin-bottom:20px;">
                        <h1 style="color:#006747;margin-bottom:8px;font-size:2.5rem;font-family:'Azalea',Georgia,serif;">${S.config.eventName}</h1>
                        <h2 style="color:#666;font-size:1.5rem;font-weight:normal;font-family:'Trebuchet MS','Helvetica Neue',Arial,sans-serif;">${S.config.clubName} • ${S.config.year}</h2>
                    </div>
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:40px;margin-top:30px;">
                        <div>
                            <h3 style="color:${S.config.teamA.color};font-size:1.8rem;margin-bottom:20px;border-bottom:3px solid ${S.config.teamA.color};padding-bottom:8px;font-family:'Trebuchet MS','Helvetica Neue',Arial,sans-serif;">${S.config.teamA.name}</h3>
                            ${teamA.map((p, i) => `<div style="padding:12px 8px;border-bottom:1px solid #eee;font-size:1.1rem;">
                                <strong>${i + 1}. ${p.name}</strong> ${p.handicap ? `<span style="color:#666;">(HCP: ${p.handicap})</span>` : ''}
                            </div>`).join('')}
                        </div>
                        <div>
                            <h3 style="color:${S.config.teamB.color};font-size:1.8rem;margin-bottom:20px;border-bottom:3px solid ${S.config.teamB.color};padding-bottom:8px;font-family:'Trebuchet MS','Helvetica Neue',Arial,sans-serif;">${S.config.teamB.name}</h3>
                            ${teamB.map((p, i) => `<div style="padding:12px 8px;border-bottom:1px solid #eee;font-size:1.1rem;">
                                <strong>${i + 1}. ${p.name}</strong> ${p.handicap ? `<span style="color:#666;">(HCP: ${p.handicap})</span>` : ''}
                            </div>`).join('')}
                        </div>
                    </div>
                </div>`;
        },

        buildMatchScheduleHTML(sessionId = null) {
            const sessions = sessionId ?
                [S.config.sessions.find(s => s.id === sessionId)].filter(Boolean) :
                S.config.sessions.sort((a, b) => a.order - b.order);

            let html = `
                <style>
                    @font-face {
                        font-family: 'Azalea';
                        src: url('assets/fonts/Azalea.otf') format('opentype');
                    }
                </style>
                <div style="font-family:Georgia,serif;max-width:750px;">
                <div style="text-align:center;margin-bottom:30px;">
                    <img src="assets/images/smashters-logo-green.png" alt="Smashters Logo" style="width:120px;height:auto;margin-bottom:20px;">
                    <h1 style="color:#006747;margin-bottom:8px;font-size:2.5rem;font-family:'Azalea',Georgia,serif;">${S.config.eventName}</h1>
                    <h2 style="color:#666;font-size:1.5rem;font-weight:normal;font-family:'Trebuchet MS','Helvetica Neue',Arial,sans-serif;">Match Schedule</h2>
                </div>`;

            sessions.forEach(session => {
                const matches = getMatchesBySession(session.id);
                const sessionDate = session.date ? new Date(session.date + 'T00:00:00').toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric', year: 'numeric' }) : 'TBD';
                const formatLabel = {
                    fourball: 'Four Ball',
                    foursomes: 'Foursomes',
                    singles: 'Singles',
                    other: 'Other'
                }[session.format] || 'Match';

                html += `<div style="margin-top:30px;">
                    <h3 style="color:#006747;font-size:1.5rem;margin-bottom:12px;font-family:'Trebuchet MS','Helvetica Neue',Arial,sans-serif;">${session.name} • ${formatLabel}</h3>
                    <p style="color:#666;margin-bottom:16px;">${sessionDate}</p>
                    <table style="width:100%;border-collapse:collapse;margin-top:10px;font-size:1rem;">
                        <thead>
                            <tr style="background:#f5f5f5;border-bottom:2px solid #006747;">
                                <th style="padding:10px;text-align:left;font-weight:600;">Tee Time</th>
                                <th style="padding:10px;text-align:left;font-weight:600;">${S.config.teamA.name}</th>
                                <th style="padding:10px;text-align:center;">vs</th>
                                <th style="padding:10px;text-align:left;font-weight:600;">${S.config.teamB.name}</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${matches.length > 0 ? matches.map(m => {
                                const teeTime = m.teeTime || 'TBD';
                                const teamANames = m.teamA.map(id => getPlayerName(id)).join(' & ');
                                const teamBNames = m.teamB.map(id => getPlayerName(id)).join(' & ');
                                return `<tr style="border-bottom:1px solid #eee;">
                                    <td style="padding:10px;font-weight:600;">${teeTime}</td>
                                    <td style="padding:10px;">${teamANames}</td>
                                    <td style="padding:10px;text-align:center;color:#999;">vs</td>
                                    <td style="padding:10px;">${teamBNames}</td>
                                </tr>`;
                            }).join('') : '<tr><td colspan="4" style="padding:20px;text-align:center;color:#999;">No matches scheduled</td></tr>'}
                        </tbody>
                    </table>
                </div>`;
            });

            return html + '</div>';
        },

        buildDailySummaryHTML(sessionId) {
            const session = S.config.sessions.find(s => s.id === sessionId);
            if (!session) return '<div>Session not found</div>';

            const matches = getMatchesBySession(sessionId);
            const sessionScores = getSessionScores(sessionId);

            let html = `
                <style>
                    @font-face {
                        font-family: 'Azalea';
                        src: url('assets/fonts/Azalea.otf') format('opentype');
                    }
                </style>
                <div style="font-family:Georgia,serif;max-width:750px;">
                <div style="text-align:center;margin-bottom:30px;">
                    <img src="assets/images/smashters-logo-green.png" alt="Smashters Logo" style="width:120px;height:auto;margin-bottom:20px;">
                    <h1 style="color:#006747;margin-bottom:8px;font-size:2.5rem;font-family:'Azalea',Georgia,serif;">${S.config.eventName}</h1>
                    <h2 style="color:#666;font-size:1.5rem;font-weight:normal;font-family:'Trebuchet MS','Helvetica Neue',Arial,sans-serif;">${session.name} Summary</h2>
                </div>
                <div style="text-align:center;font-size:2rem;margin:30px 0;padding:20px;background:#f5f5f5;border-radius:8px;">
                    <span style="color:${S.config.teamA.color};font-weight:bold;">${S.config.teamA.name}: ${formatScore(sessionScores.A)}</span>
                    <span style="margin:0 20px;color:#999;">-</span>
                    <span style="color:${S.config.teamB.color};font-weight:bold;">${S.config.teamB.name}: ${formatScore(sessionScores.B)}</span>
                </div>
                <table style="width:100%;border-collapse:collapse;margin-top:20px;font-size:1rem;">
                    <thead>
                        <tr style="background:#f5f5f5;">
                            <th style="padding:10px;text-align:left;font-weight:600;">Match</th>
                            <th style="padding:10px;text-align:center;font-weight:600;">Result</th>
                        </tr>
                    </thead>
                    <tbody>`;

            matches.forEach(m => {
                const status = getMatchPlayStatus(m);
                const teamANames = m.teamA.map(id => getPlayerName(id)).join(' & ');
                const teamBNames = m.teamB.map(id => getPlayerName(id)).join(' & ');

                html += `<tr style="border-bottom:1px solid #eee;">
                    <td style="padding:12px;">
                        <div style="font-weight:600;color:${S.config.teamA.color};">${teamANames}</div>
                        <div style="font-size:0.9rem;color:#666;">vs ${teamBNames}</div>
                    </td>
                    <td style="padding:12px;text-align:center;font-weight:bold;font-size:1.1rem;">${status.text}</td>
                </tr>`;
            });

            return html + '</tbody></table></div>';
        },

        buildFinalResultsHTML() {
            const teamScores = getTeamScores();
            const sessions = S.config.sessions.sort((a, b) => a.order - b.order);

            let html = `
                <style>
                    @font-face {
                        font-family: 'Azalea';
                        src: url('assets/fonts/Azalea.otf') format('opentype');
                    }
                </style>
                <div style="font-family:Georgia,serif;max-width:750px;">
                <div style="text-align:center;margin-bottom:30px;">
                    <img src="assets/images/smashters-logo-green.png" alt="Smashters Logo" style="width:120px;height:auto;margin-bottom:20px;">
                    <h1 style="color:#006747;margin-bottom:8px;font-size:2.5rem;font-family:'Azalea',Georgia,serif;">${S.config.eventName}</h1>
                    <h2 style="color:#666;font-size:1.5rem;font-weight:normal;font-family:'Trebuchet MS','Helvetica Neue',Arial,sans-serif;">Final Results • ${S.config.year}</h2>
                </div>
                <div style="text-align:center;font-size:2.5rem;margin:40px 0;padding:30px;background:#006747;color:white;border-radius:12px;font-family:'Trebuchet MS','Helvetica Neue',Arial,sans-serif;">
                    <div style="margin-bottom:10px;font-size:1rem;opacity:0.9;text-transform:uppercase;letter-spacing:2px;">Final Score</div>
                    <div>
                        <span style="font-weight:bold;">${S.config.teamA.name}: ${formatScore(teamScores.A)}</span>
                        <span style="margin:0 30px;opacity:0.7;">-</span>
                        <span style="font-weight:bold;">${S.config.teamB.name}: ${formatScore(teamScores.B)}</span>
                    </div>
                </div>`;

            html += '<div style="margin-top:40px;">';
            sessions.forEach(session => {
                const sessionScores = getSessionScores(session.id);
                html += `<div style="padding:16px;border-bottom:1px solid #ddd;">
                    <h3 style="color:#006747;font-size:1.2rem;margin-bottom:8px;font-family:'Trebuchet MS','Helvetica Neue',Arial,sans-serif;">${session.name}</h3>
                    <p style="font-size:1.1rem;">${S.config.teamA.name}: <strong>${formatScore(sessionScores.A)}</strong> • ${S.config.teamB.name}: <strong>${formatScore(sessionScores.B)}</strong></p>
                </div>`;
            });
            html += '</div>';

            return html + '</div>';
        },

        async generateTeamRoster(format = 'pdf') {
            const html = this.buildTeamRosterHTML();
            if (format === 'pdf') {
                await this.htmlToPDF(html, 'team-roster.pdf');
            } else {
                await this.htmlToImage(html, 'team-roster.png');
            }
        },

        async generateMatchSchedule(sessionId = null, format = 'pdf') {
            const html = this.buildMatchScheduleHTML(sessionId);
            const filename = sessionId ? `${sessionId}-schedule.pdf` : 'match-schedule.pdf';
            if (format === 'pdf') {
                await this.htmlToPDF(html, filename);
            } else {
                await this.htmlToImage(html, filename.replace('.pdf', '.png'));
            }
        },

        async generateDailySummary(sessionId, format = 'pdf') {
            const html = this.buildDailySummaryHTML(sessionId);
            if (format === 'pdf') {
                await this.htmlToPDF(html, `${sessionId}-summary.pdf`);
            } else {
                await this.htmlToImage(html, `${sessionId}-summary.png`);
            }
        },

        async generateFinalResults(format = 'pdf') {
            const html = this.buildFinalResultsHTML();
            if (format === 'pdf') {
                await this.htmlToPDF(html, 'final-results.pdf');
            } else {
                await this.htmlToImage(html, 'final-results.png');
            }
        }
    };

    function openExportMenu() {
        const sessions = S.config.sessions.sort((a, b) => a.order - b.order);

        let body = `<div style="display:grid;gap:12px;">
            <button class="btn btn-primary" onclick="ExportManager.generateTeamRoster('pdf');closeModal()">📤 Team Roster (PDF)</button>
            <button class="btn btn-primary" onclick="ExportManager.generateMatchSchedule(null, 'pdf');closeModal()">📤 Full Schedule (PDF)</button>`;

        sessions.forEach(s => {
            body += `<button class="btn btn-outline" onclick="ExportManager.generateDailySummary('${s.id}', 'pdf');closeModal()">📊 ${s.name} Summary (PDF)</button>`;
        });

        body += `<button class="btn btn-gold" onclick="ExportManager.generateFinalResults('pdf');closeModal()">🏆 Final Results (PDF)</button>
        </div>`;

        openModal('Export & Share', body, '');
    }

    // ─────────────────────────────────────────────────────────
    // DATA RECOVERY
    // ─────────────────────────────────────────────────────────
    // Manual recovery function - call from console if data is lost
    window.recoverFromBackup = function() {
        try {
            const backup = localStorage.getItem(STORAGE_KEY + '-backup');
            const backupTime = localStorage.getItem(STORAGE_KEY + '-backup-time');
            if (!backup) {
                console.error('No backup found');
                alert('No backup available');
                return false;
            }
            const parsed = JSON.parse(backup);
            const playerCount = Object.keys(parsed.players || {}).length;
            const matchCount = Object.keys(parsed.matches || {}).length;
            const backupDate = backupTime ? new Date(parseInt(backupTime)).toLocaleString() : 'Unknown';

            if (confirm(`Restore backup from ${backupDate}?\n${playerCount} players, ${matchCount} matches`)) {
                localStorage.setItem(STORAGE_KEY, backup);
                console.log('Backup restored successfully');
                alert('Backup restored! Reloading page...');
                window.location.reload();
                return true;
            }
        } catch (e) {
            console.error('Recovery failed:', e);
            alert('Recovery failed: ' + e.message);
            return false;
        }
    };

    // ─────────────────────────────────────────────────────────
    // INIT
    // ─────────────────────────────────────────────────────────
    function init() {
        // Version check - force reload if cached old version
        const savedVersion = localStorage.getItem(VERSION_KEY);
        if (savedVersion && savedVersion !== APP_VERSION) {
            console.log(`Version mismatch: ${savedVersion} → ${APP_VERSION}. Reloading...`);
            localStorage.setItem(VERSION_KEY, APP_VERSION);
            window.location.reload(true); // Hard reload to bypass cache
            return;
        }
        localStorage.setItem(VERSION_KEY, APP_VERSION);
        console.log(`Smashters App v${APP_VERSION}`);

        document.documentElement.style.setProperty('--team-a-color', S.config.teamA.color);
        document.documentElement.style.setProperty('--team-b-color', S.config.teamB.color);
        document.querySelector('.header-titles h1').textContent = S.config.eventName;
        document.querySelector('.header-titles .subtitle').textContent = S.config.clubName;

        // Auto-start Firebase sync (always live)
        LiveSync.autoStart();

        // ── Launch flow: gate → opt-in → splash ──
        if (isMobile() && !isStandalone()) {
            // Mobile browser: show "Add to Home Screen" gate
            hideSplash();
            showMobileGate();
        } else if (shouldShowSplash()) {
            // Standalone PWA or desktop: show opt-in, then splash on tap
            hideSplash();
            showOptIn();
            document.getElementById('optInBtn').addEventListener('click', () => {
                hideOptIn();
                showSplash();
            }, { once: true });
        } else {
            hideSplash();
        }

        switchTab(S.ui.activeTab || 'schedule');

        // Check if we should show Add to Home Screen banner
        // (skip if gate is already showing)
        if (!(isMobile() && !isStandalone())) {
            checkInstallBanner();
        }
    }

    document.getElementById('modalOverlay').addEventListener('click', e => {
        if (e.target === e.currentTarget) closeModal();
    });
    document.addEventListener('keydown', e => { if (e.key === 'Escape') closeModal(); });

    init();
    </script>
</body>
</html>
