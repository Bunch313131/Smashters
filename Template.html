<!doctype html>

<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="icon" type="image/png" sizes="32x32" href="https://raw.githubusercontent.com/Bunch313131/nassau-app/main/favicon-32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://raw.githubusercontent.com/Bunch313131/nassau-app/main/favicon-16.png">
<link rel="icon" href="https://raw.githubusercontent.com/Bunch313131/nassau-app/main/favicon.ico">
<link rel="apple-touch-icon" sizes="180x180" href="https://raw.githubusercontent.com/Bunch313131/nassau-app/main/BunchBets180.png">
<link rel="mask-icon" href="https://raw.githubusercontent.com/Bunch313131/nassau-app/main/safari-pinned-tab.svg" color="#2563eb">
<link rel="manifest" href="https://raw.githubusercontent.com/Bunch313131/nassau-app/main/manifest.webmanifest" crossorigin="anonymous">
<title>Bunch Bets V6.0 Final - Nassau + Vegas</title>
<!-- Firebase SDK -->
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
<style>
:root { --bg:#0b0e13; --card:#0f1420; --txt:#ecf0f6; --muted:#a3a9b6; --border:#1e2633; --acc:#3b82f6; --success:#16a34a; --danger:#dc2626; --warning:#d97706; color-scheme: dark; }
:root.light-mode { --bg:#f5f5f7; --card:#ffffff; --txt:#1d1d1f; --muted:#6e6e73; --border:#d2d2d7; --acc:#3b82f6; --success:#16a34a; --danger:#dc2626; --warning:#d97706; color-scheme: light; }
:root.light-mode input[type="text"], :root.light-mode input[type="tel"], :root.light-mode input[type="number"], :root.light-mode select { background:rgba(0,0,0,0.04); }
:root.light-mode .menu-item:hover { background:rgba(0,0,0,0.05); }
.theme-switch { position:relative; width:50px; height:26px; display:inline-block; }
.theme-switch input { opacity:0; width:0; height:0; }
.theme-slider { position:absolute; cursor:pointer; inset:0; background:var(--border); border-radius:26px; transition:0.3s; }
.theme-slider:before { position:absolute; content:""; height:20px; width:20px; left:3px; bottom:3px; background:var(--card); border-radius:50%; transition:0.3s; }
.theme-switch input:checked + .theme-slider { background:var(--acc); }
.theme-switch input:checked + .theme-slider:before { transform:translateX(24px); }
.theme-icons { position:absolute; inset:0; display:flex; align-items:center; justify-content:space-between; padding:0 5px; font-size:12px; pointer-events:none; }
* { box-sizing:border-box; }
body { margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; color:var(--txt); background:var(--bg); }
header { background:var(--card); border-bottom:1px solid var(--border); padding:10px 12px; position:sticky; top:0; z-index:10; }
h1 { font-size:18px; margin:0; }
main { padding:12px; }
.row { display:flex; flex-wrap:wrap; gap:12px; align-items:flex-start; }
.card { background:var(--card); border:1px solid var(--border); border-radius:14px; padding:12px; }
.btn { background:var(--card); border:1px solid var(--border); border-radius:999px; padding:8px 12px; cursor:pointer; color:var(--txt); transition:all 0.2s; }
.btn:hover:not(:disabled) { transform:translateY(-1px); }
.btn:disabled { opacity:0.5; cursor:not-allowed; }
.btn.primary { background:var(--acc); color:#fff; border-color:var(--acc); }
.btn.danger { background:var(--danger); color:#fff; border-color:var(--danger); }
.btn.share { background:var(--success); color:#fff; font-weight:600; }
.btn.small { padding:6px 10px; font-size:14px; }
.pill { border:1px solid var(--border); padding:6px 10px; border-radius:999px; display:inline-block; background:rgba(255,255,255,0.02); }
.grid { display:grid; gap:8px; }
.grid-2 { grid-template-columns:repeat(2,minmax(0,1fr)); }
.grid-3 { grid-template-columns:repeat(3,minmax(0,1fr)); }
.muted { color:var(--muted); }
.nowrap { white-space:nowrap; }
input[type="text"], input[type="tel"], input[type="number"], select { border:1px solid var(--border); border-radius:10px; padding:10px 12px; width:100%; font-size:16px; min-height:44px; color:var(--txt); background:rgba(255,255,255,0.06); }
input:focus, select:focus { outline:2px solid var(--acc); outline-offset:1px; }
::placeholder { color:var(--muted); opacity:0.9; }
table { border-collapse:collapse; width:100%; font-size:14px; }
th, td { border:1px solid var(--border); padding:6px; text-align:center; vertical-align:middle; }
th.sticky, td.sticky { position:sticky; left:0; background:var(--card); z-index:10; text-align:left; transform:translateZ(0); backface-visibility:hidden; box-shadow:2px 0 4px rgba(0,0,0,0.15); clip-path:inset(0 -5px 0 0); }
.tabs { display:flex; flex-wrap:wrap; gap:6px; margin:6px 0 10px; }
.tabs .btn.active { background:var(--acc); color:#fff; border-color:var(--acc); }
.scroll { overflow:auto; isolation:isolate; }
.note { font-size:12px; color:var(--muted); }
.error { position:fixed; bottom:8px; left:8px; right:8px; background:#fee2e2; color:#991b1b; border:1px solid #fecaca; border-radius:12px; padding:8px 12px; font-size:12px; display:none; z-index:9999; white-space:pre-wrap; }
.success-toast { position:fixed; top:70px; right:8px; background:var(--success); color:#fff; border-radius:12px; padding:12px 16px; z-index:9999; animation:slideIn 0.3s; box-shadow:0 4px 12px rgba(0,0,0,0.3); }
@keyframes slideIn { from { transform:translateX(400px); opacity:0; } to { transform:translateX(0); opacity:1; } }
.theme-g1 .card { outline:1px solid rgba(22,163,74,.45); background:linear-gradient(0deg,rgba(22,163,74,.08),rgba(22,163,74,.08)) var(--card); }
.theme-g2 .card { outline:1px solid rgba(220,38,38,.45); background:linear-gradient(0deg,rgba(220,38,38,.08),rgba(220,38,38,.08)) var(--card); }
.theme-g3 .card { outline:1px solid rgba(217,119,6,.45); background:linear-gradient(0deg,rgba(217,119,6,.08),rgba(217,119,6,.08)) var(--card); }
.theme-g4 .card { outline:1px solid rgba(99,102,241,.45); background:linear-gradient(0deg,rgba(99,102,241,.08),rgba(99,102,241,.08)) var(--card); }
.theme-g5 .card { outline:1px solid rgba(20,184,166,.45); background:linear-gradient(0deg,rgba(20,184,166,.08),rgba(20,184,166,.08)) var(--card); }
.theme-g6 .card { outline:1px solid rgba(219,39,119,.45); background:linear-gradient(0deg,rgba(219,39,119,.08),rgba(219,39,119,.08)) var(--card); }
.cellWrap { position:relative; }
.cellWrap input { width:54px; text-align:center; padding-right:14px; }
.cellWrap .dots { position:absolute; right:2px; top:4px; display:flex; flex-direction:column; gap:2px; pointer-events:none; z-index:1; }
.cellWrap .dot { width:6px; height:6px; border-radius:50%; }
.cellWrap .dot.g1 { background-color:#16a34a; }
.cellWrap .dot.g2 { background-color:#dc2626; }
.cellWrap .dot.g3 { background-color:#d97706; }
.cellWrap .dot.g4 { background-color:#6366f1; }
.cellWrap .dot.g5 { background-color:#14b8a6; }
.cellWrap .dot.g6 { background-color:#db2777; }
/* Score indicators - circles for under par, squares for over par */
.cellWrap .score-indicator { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none; }
.cellWrap .score-indicator::before { content:''; position:absolute; width:28px; height:28px; border:2px solid transparent; }
.cellWrap .score-indicator::after { content:''; position:absolute; width:36px; height:36px; border:2px solid transparent; }
.cellWrap.birdie .score-indicator::before { border-color:#16a34a; border-radius:50%; }
.cellWrap.eagle .score-indicator::before { border-color:#16a34a; border-radius:50%; }
.cellWrap.eagle .score-indicator::after { border-color:#16a34a; border-radius:50%; }
.cellWrap.bogey .score-indicator::before { border-color:#dc2626; border-radius:4px; }
.cellWrap.double-bogey .score-indicator::before { border-color:#dc2626; border-radius:4px; }
.cellWrap.double-bogey .score-indicator::after { border-color:#dc2626; border-radius:4px; }
.junkWrap { position:relative; display:inline-block; }
.junkBox { width:48px; height:36px; text-align:center; font-size:20px; padding:6px; background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.22); position:relative; z-index:2; border-radius:6px; }
.junkVal { position:absolute; top:8px; right:6px; font-size:12px; pointer-events:none; z-index:1; }
.junkWrap .junkBox:not(:placeholder-shown) + .junkVal { display:none; }
.junkWrap:focus-within .junkVal { display:none; }
.game-options-row { display:grid; grid-template-columns:minmax(0,1.2fr) minmax(0,0.8fr); gap:16px 20px; align-items:start; }
@media (max-width: 360px) { .game-options-row { grid-template-columns:1fr; } }
@media (prefers-color-scheme: light) {
  :root { --bg:#f6f7fb; --card:#fff; --txt:#111; --muted:#666; --border:#e5e7eb; --acc:#2563eb; }
  .theme-g1 .card { outline:1px solid rgba(22,163,74,.35); background:linear-gradient(0deg,rgba(22,163,74,.10),rgba(22,163,74,.10)) var(--card); }
  .theme-g2 .card { outline:1px solid rgba(220,38,38,.35); background:linear-gradient(0deg,rgba(220,38,38,.10),rgba(220,38,38,.10)) var(--card); }
  .theme-g3 .card { outline:1px solid rgba(217,119,6,.35); background:linear-gradient(0deg,rgba(217,119,6,.10),rgba(217,119,6,.10)) var(--card); }
  .theme-g4 .card { outline:1px solid rgba(99,102,241,.35); background:linear-gradient(0deg,rgba(99,102,241,.10),rgba(99,102,241,.10)) var(--card); }
  .theme-g5 .card { outline:1px solid rgba(20,184,166,.35); background:linear-gradient(0deg,rgba(20,184,166,.10),rgba(20,184,166,.10)) var(--card); }
  .theme-g6 .card { outline:1px solid rgba(219,39,119,.35); background:linear-gradient(0deg,rgba(219,39,119,.10),rgba(219,39,119,.10)) var(--card); }
  input, .junkBox { background:#f3f4f6; border-color:#d1d5db; }
  .press-row { background:rgba(0,0,0,0.02); }
}
.ios .junkWrap .junkBox { color:transparent; -webkit-text-fill-color:transparent; caret-color:var(--txt); z-index:1; }
.ios .junkWrap .junkVal { position:absolute; inset:0; display:flex !important; align-items:center; justify-content:center; z-index:2; color:var(--txt); -webkit-text-fill-color:var(--txt); transform:translateZ(0); }
select.press-select { min-height:36px; padding:6px 8px; font-size:14px; }
.press-row { background:rgba(255,255,255,0.02); }
.press-row.theme-g1 { background:rgba(22,163,74,0.15); }
.press-row.theme-g2 { background:rgba(220,38,38,0.15); }
.press-row.theme-g3 { background:rgba(217,119,6,0.15); }
.press-row.theme-g4 { background:rgba(99,102,241,0.15); }
.press-row.theme-g5 { background:rgba(20,184,166,0.15); }
.press-row.theme-g6 { background:rgba(219,39,119,0.15); }
/* Scores/Junk Toggle Bar */
.scoring-toggle { display:flex; background:var(--card); border:1px solid var(--border); border-radius:10px; overflow:hidden; margin-bottom:12px; }
.scoring-toggle-btn { flex:1; padding:10px 16px; text-align:center; font-size:14px; font-weight:500; cursor:pointer; transition:all 0.2s; border:none; background:transparent; color:var(--muted); }
.scoring-toggle-btn.active { background:var(--acc); color:#fff; }
.scoring-toggle-btn:not(.active):hover { background:rgba(255,255,255,0.05); }
.press-label { font-weight:600; font-size:12px; }
.digits-display { font-size:20px; font-weight:700; font-family:monospace; color:var(--acc); }
.points-positive { color:var(--success); font-weight:600; }
.points-negative { color:var(--danger); font-weight:600; }
/* Live Sharing Styles */
.live-banner { background:linear-gradient(135deg,var(--acc),#6366f1); color:#fff; padding:8px 12px; text-align:center; font-weight:600; font-size:14px; }
.live-banner.viewer { background:linear-gradient(135deg,#d97706,#dc2626); }
.share-code { font-family:monospace; font-size:24px; font-weight:700; letter-spacing:2px; background:rgba(255,255,255,0.1); padding:8px 16px; border-radius:8px; display:inline-block; }
.modal-overlay { position:fixed; inset:0; background:rgba(0,0,0,0.7); z-index:1000; display:flex; align-items:center; justify-content:center; padding:16px; }
.modal { background:var(--card); border:1px solid var(--border); border-radius:16px; padding:20px; max-width:400px; width:100%; max-height:90vh; overflow-y:auto; }
.modal h2 { margin:0 0 16px 0; font-size:18px; }
.modal-actions { display:flex; gap:8px; margin-top:16px; justify-content:flex-end; }
.copy-btn { background:var(--acc); color:#fff; border:none; padding:8px 16px; border-radius:8px; cursor:pointer; font-weight:600; }
.copy-btn:hover { opacity:0.9; }
.join-input { font-family:monospace; font-size:20px; letter-spacing:2px; text-transform:uppercase; text-align:center; }
.sync-indicator { display:inline-block; width:8px; height:8px; border-radius:50%; background:#16a34a; margin-right:6px; animation:pulse 2s infinite; }
@keyframes pulse { 0%,100% { opacity:1; } 50% { opacity:0.5; } }
/* Viewer mode - disable all inputs */
.viewer-mode input, .viewer-mode select, .viewer-mode button:not(.btn) { pointer-events:none; opacity:0.7; }
.viewer-mode .tabs .btn { pointer-events:auto; opacity:1; }
.viewer-mode #joinBtn { display:none; }

/* Hamburger Menu Styles */
.header-brand { display:flex; align-items:center; gap:10px; }
.header-brand img { width:36px; height:36px; border-radius:8px; }
.header-brand h1 { font-size:18px; margin:0; }
.hamburger { background:none; border:none; color:var(--txt); font-size:28px; cursor:pointer; padding:4px 8px; line-height:1; }
.hamburger:hover { color:var(--acc); }
.menu-overlay { position:fixed; inset:0; background:rgba(0,0,0,0.5); z-index:100; opacity:0; visibility:hidden; transition:opacity 0.3s, visibility 0.3s; }
.menu-overlay.open { opacity:1; visibility:visible; }
.slide-menu { position:fixed; top:0; right:-280px; width:280px; height:100%; background:var(--card); border-left:1px solid var(--border); z-index:101; transition:right 0.3s ease; overflow-x:hidden; overflow-y:auto; overscroll-behavior:contain; display:flex; flex-direction:column; }
.slide-menu.open { right:0; }
.menu-header { padding:16px; border-bottom:1px solid var(--border); display:flex; align-items:center; justify-content:space-between; }
.menu-header h2 { margin:0; font-size:16px; }
.menu-close { background:none; border:none; color:var(--txt); font-size:24px; cursor:pointer; padding:4px; line-height:1; }
.menu-close:hover { color:var(--danger); }
.menu-section { padding:12px 0; border-bottom:1px solid var(--border); }
.menu-section:last-child { border-bottom:none; }
.menu-section-title { padding:8px 16px; font-size:11px; text-transform:uppercase; color:var(--muted); letter-spacing:0.5px; }
.menu-item { display:block; width:100%; padding:12px 16px; background:none; border:none; color:var(--txt); font-size:15px; text-align:left; cursor:pointer; transition:background 0.2s; }
.menu-item:hover { background:rgba(255,255,255,0.05); }
.menu-item.active { color:var(--acc); background:rgba(59,130,246,0.1); }
.menu-item.danger { color:var(--danger); }
.menu-item.primary { color:var(--acc); font-weight:600; }

/* Wizard Styles */
.wizard-overlay { position:fixed; inset:0; z-index:200; display:flex; flex-direction:column; overflow:hidden; }
body:has(.wizard-overlay) { overflow:hidden; }
.wizard-splash {
  background: linear-gradient(135deg, #16a34a 0%, #15803d 50%, #166534 100%);
  flex:1;
  display:flex;
  align-items:center;
  justify-content:center;
}
.wizard-splash img { width:45%; max-width:280px; height:auto; border-radius:24px; box-shadow:0 8px 32px rgba(0,0,0,0.3); opacity:0; animation: wizardFadeIn 1.5s ease-out forwards; }
@keyframes wizardFadeIn { from { opacity:0; } to { opacity:1; } }
.wizard-screen { background:var(--bg); flex:1; display:flex; flex-direction:column; overflow:hidden; }
.wizard-header { padding:20px 16px 12px; text-align:center; }
.wizard-header h2 { margin:0 0 4px 0; font-size:22px; }
.wizard-header p { margin:0; color:var(--muted); font-size:14px; }
.wizard-content { flex:1; overflow-x:hidden; overflow-y:auto; overscroll-behavior:contain; padding:12px 16px; -webkit-overflow-scrolling:touch; scrollbar-width:none; -ms-overflow-style:none; }
.wizard-content::-webkit-scrollbar { display:none; }
.wizard-footer { padding:12px 16px; border-top:1px solid var(--border); background:var(--card); display:flex; flex-wrap:wrap; gap:8px; }
.wizard-footer .btn { flex:1; min-width:120px; padding:10px 12px; font-size:14px; }
.wizard-footer .btn.secondary { flex:0 0 auto; min-width:80px; background:var(--card); }
.wizard-skip { width:100%; text-align:center; margin-top:4px; }
.wizard-skip a { color:var(--muted); font-size:13px; text-decoration:underline; cursor:pointer; }
.wizard-skip a:hover { color:var(--acc); }
.wizard-player-row { display:grid; grid-template-columns:1fr 80px 40px; gap:8px; align-items:center; margin-bottom:12px; }
.wizard-player-row.header { font-size:12px; color:var(--muted); margin-bottom:8px; }
.wizard-player-row input { min-height:44px; }
.wizard-player-row .delete-btn { background:none; border:none; color:var(--danger); font-size:20px; cursor:pointer; padding:8px; }
.wizard-player-row .delete-btn:hover { opacity:0.7; }
.wizard-add-btn { background:rgba(59,130,246,0.1); border:1px dashed var(--acc); color:var(--acc); padding:12px; border-radius:10px; width:100%; cursor:pointer; font-size:14px; margin-top:8px; }
.wizard-add-btn:hover { background:rgba(59,130,246,0.2); }
.wizard-course-card { background:var(--card); border:1px solid var(--border); border-radius:12px; padding:14px; margin-bottom:10px; cursor:pointer; transition:all 0.2s; }
.wizard-course-card:hover { border-color:var(--acc); }
.wizard-course-card.selected { border-color:var(--acc); background:rgba(59,130,246,0.1); }
.wizard-course-card h3 { margin:0 0 4px 0; font-size:15px; }
.wizard-course-card p { margin:0; font-size:12px; color:var(--muted); }
.wizard-section { margin-bottom:20px; }
.wizard-section-title { font-size:13px; color:var(--muted); margin-bottom:8px; text-transform:uppercase; letter-spacing:0.5px; }
.wizard-option { display:flex; align-items:center; gap:10px; padding:12px; background:var(--card); border:1px solid var(--border); border-radius:10px; margin-bottom:8px; cursor:pointer; }
.wizard-option:hover { border-color:var(--acc); }
.wizard-option.selected { border-color:var(--acc); background:rgba(59,130,246,0.1); }
.wizard-option input[type="radio"] { width:18px; height:18px; }
.wizard-team-zone { background:var(--card); border:1px solid var(--border); border-radius:12px; padding:12px; min-height:100px; text-align:center; }
.wizard-team-zone h4 { margin:0 0 8px 0; font-size:13px; color:var(--muted); text-align:center; }
.wizard-player-chip { display:inline-block; background:rgba(59,130,246,0.2); border:1px solid var(--acc); border-radius:20px; padding:6px 12px; margin:4px; font-size:13px; cursor:pointer; }
.wizard-player-chip:hover { background:rgba(59,130,246,0.3); }
.wizard-player-chip.team-a { background:rgba(22,163,74,0.2); border-color:#16a34a; }
.wizard-player-chip.team-b { background:rgba(220,38,38,0.2); border-color:#dc2626; }
.wizard-player-chip.skins-selected { background:#16a34a; border-color:#16a34a; color:#fff; font-weight:600; }
.wizard-player-chip.skins-selected::before { content:'‚úì '; }
.wizard-player-chip.skins-unselected { background:rgba(100,100,100,0.15); border-color:rgba(100,100,100,0.3); color:var(--muted); }
.wizard-game-tabs { display:flex; gap:8px; justify-content:center; margin-top:8px; flex-wrap:wrap; }
.wizard-game-tab { padding:6px 14px; border-radius:20px; font-size:13px; cursor:pointer; border:1px solid var(--border); background:var(--card); transition:all 0.2s; }
.wizard-game-tab:hover { border-color:var(--acc); }
.wizard-game-tab.active { background:var(--acc); color:#fff; border-color:var(--acc); }
.wizard-game-tab .delete-game { margin-left:6px; opacity:0.7; }
.wizard-game-tab .delete-game:hover { opacity:1; }
.wizard-holes-grid { display:grid; grid-template-columns:repeat(9, 1fr); gap:4px; margin-bottom:12px; }
.wizard-hole-col { display:flex; flex-direction:column; align-items:center; gap:2px; }
.wizard-hole-num { font-size:11px; font-weight:600; color:var(--muted); }
.wizard-hole-input { width:100%; min-width:0; padding:6px 2px; text-align:center; font-size:13px; border:1px solid var(--border); border-radius:6px; background:var(--card); }
.wizard-hole-input:focus { border-color:var(--acc); outline:none; }
/* Currency input styling for stakes/points */
.currency-input-wrap { position:relative; display:flex; align-items:center; }
.currency-input-wrap::before { content:'$'; position:absolute; left:10px; color:var(--muted); font-size:14px; pointer-events:none; z-index:1; }
.currency-input { width:80px; padding:8px 8px 8px 22px; font-size:14px; min-height:40px; text-align:right; }
/* Help button for game explanations */
.help-btn { width:28px; height:28px; border-radius:50%; border:1px solid var(--border); background:var(--card); color:var(--acc); font-weight:700; font-size:14px; cursor:pointer; flex-shrink:0; }
.help-btn:hover { background:var(--acc); color:#fff; }
</style>
</head>
<body>
<header>
  <div class="row" style="align-items:center; justify-content:space-between;">
    <div class="header-brand">
      <img src="https://raw.githubusercontent.com/Bunch313131/nassau-app/main/BunchBets180.png" alt="Bunch Bets">
      <h1>Bunch Bets</h1>
    </div>
    <button class="hamburger" id="menuToggle" aria-label="Menu">&#9776;</button>
  </div>
</header>

<!-- Slide-out Menu -->
<div class="menu-overlay" id="menuOverlay"></div>
<div class="slide-menu" id="slideMenu">
  <div class="menu-header">
    <h2>Menu</h2>
    <div style="display:flex;align-items:center;gap:12px;">
      <label class="theme-switch">
        <input type="checkbox" id="themeToggle">
        <span class="theme-slider"></span>
        <span class="theme-icons"><span>‚òÄÔ∏è</span><span>üåô</span></span>
      </label>
      <button class="menu-close" id="menuClose">&times;</button>
    </div>
  </div>
  <div class="menu-section">
    <button class="menu-item primary" id="startWizardBtn" style="background:var(--success);color:#fff;font-weight:600;text-align:center;border-radius:8px;margin:0 12px;">Start New Game</button>
  </div>
  <div class="menu-section">
    <div class="menu-section-title">Navigate</div>
    <div id="menuNav"></div>
  </div>
  <div class="menu-section">
    <div class="menu-section-title">Live Sharing</div>
    <button class="menu-item primary" id="hostBtn">Host Live Game</button>
    <button class="menu-item" id="joinBtn">Join Game</button>
  </div>
  <div class="menu-section">
    <div class="menu-section-title">Actions</div>
    <button class="menu-item" id="resetBtn">New Round</button>
    <button class="menu-item" id="clearBtn">Clear Scores</button>
    <button class="menu-item danger" id="factoryBtn">Factory Reset</button>
  </div>
</div>
<div id="liveBanner" class="live-banner" style="display:none;"></div>
<main>
  <div id="tabs"></div>
  <div id="app"></div>
</main>
<div id="err" class="error"></div>

<script>

(function(){
'use strict';

// === CONSTANTS ===
const STORAGE_KEY = 'nassauV28_complete';
const MIN_SCORE = 1, MAX_SCORE = 15, HOLES = 18;

// === FIREBASE CONFIG ===
// Live sharing enabled! Project: bunchbets.firebaseapp.com
const FIREBASE_CONFIG = {
  apiKey: "AIzaSyDZlbkZMkfmFk1CS1i51JQ1NuknlNae0zo",
  authDomain: "bunchbets.firebaseapp.com",
  databaseURL: "https://bunchbets-default-rtdb.firebaseio.com",
  projectId: "bunchbets",
  storageBucket: "bunchbets.firebasestorage.app",
  messagingSenderId: "267555779116",
  appId: "1:267555779116:web:af1e05bacb82f0d4fe5789"
};

// === LIVE SYNC MODULE ===
window.LiveSync = {
  db: null,
  gameRef: null,
  shareCode: null,
  isHost: false,
  isViewer: false,
  unsubscribe: null,

  init() {
    if (FIREBASE_CONFIG.apiKey === "YOUR_API_KEY") {
      console.log('Firebase not configured - live sharing disabled');
      return false;
    }
    try {
      firebase.initializeApp(FIREBASE_CONFIG);
      this.db = firebase.database();
      return true;
    } catch (e) {
      console.error('Firebase init failed:', e);
      return false;
    }
  },

  generateCode() {
    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
    let code = '';
    for (let i = 0; i < 6; i++) code += chars[Math.floor(Math.random() * chars.length)];
    return code;
  },

  async hostGame() {
    if (!this.init()) {
      Err.show('Firebase not configured. See instructions in index.html to enable live sharing.');
      return null;
    }

    this.shareCode = this.generateCode();
    this.isHost = true;
    this.isViewer = false;
    this.gameRef = this.db.ref('games/' + this.shareCode);

    try {
      await this.gameRef.set({
        data: State.data,
        presets: State.presets,
        updatedAt: firebase.database.ServerValue.TIMESTAMP
      });

      this.showBanner(`Hosting: ${this.shareCode}`, false);
      Err.toast('Game hosted! Share code: ' + this.shareCode);
      return this.shareCode;
    } catch (e) {
      Err.show('Failed to host game: ' + e.message);
      this.isHost = false;
      return null;
    }
  },

  async joinGame(code) {
    if (!this.init()) {
      Err.show('Firebase not configured. See instructions in index.html to enable live sharing.');
      return false;
    }

    code = code.toUpperCase().trim();
    if (!/^[A-Z0-9]{6}$/.test(code)) {
      Err.show('Invalid code. Should be 6 characters.');
      return false;
    }

    this.gameRef = this.db.ref('games/' + code);

    try {
      const snapshot = await this.gameRef.once('value');
      if (!snapshot.exists()) {
        Err.show('Game not found. Check the code and try again.');
        return false;
      }

      this.shareCode = code;
      this.isViewer = true;
      this.isHost = false;

      // Subscribe to updates
      this.unsubscribe = this.gameRef.on('value', (snap) => {
        const val = snap.val();
        if (val && val.data) {
          State.data = val.data;
          State.presets = val.presets || [];
          // Sanitize games to ensure all player entries exist
          if (State.data.games && Array.isArray(State.data.games)) {
            State.data.games = State.data.games.map(g => Game.sanitize(g));
          }
          State.scheduleRender();
        }
      });

      this.showBanner(`Viewing: ${code} (read-only)`, true);
      this.disableEditing();
      State.data.tab = 'scores';
      State.scheduleRender();
      Err.toast('Connected to game ' + code);
      return true;
    } catch (e) {
      Err.show('Failed to join game: ' + e.message);
      return false;
    }
  },

  syncToFirebase() {
    if (!this.isHost || !this.gameRef) return;

    this.gameRef.update({
      data: State.data,
      presets: State.presets,
      updatedAt: firebase.database.ServerValue.TIMESTAMP
    }).catch(e => console.error('Sync failed:', e));
  },

  stopSharing() {
    if (this.unsubscribe && this.gameRef) {
      this.gameRef.off('value', this.unsubscribe);
    }
    this.shareCode = null;
    this.isHost = false;
    this.isViewer = false;
    this.gameRef = null;
    this.hideBanner();
    this.enableEditing();
    Err.toast('Disconnected from live game');
  },

  showBanner(text, isViewer) {
    const banner = document.getElementById('liveBanner');
    banner.innerHTML = `<span class="sync-indicator"></span>${text} <button class="btn small" style="margin-left:12px;padding:4px 8px;" onclick="LiveSync.stopSharing()">Disconnect</button>`;
    banner.className = 'live-banner' + (isViewer ? ' viewer' : '');
    banner.style.display = 'block';
  },

  hideBanner() {
    document.getElementById('liveBanner').style.display = 'none';
  },

  disableEditing() {
    document.body.classList.add('viewer-mode');
    // Hide edit buttons
    ['resetBtn', 'clearBtn', 'factoryBtn', 'hostBtn'].forEach(id => {
      const el = document.getElementById(id);
      if (el) el.style.display = 'none';
    });
  },

  enableEditing() {
    document.body.classList.remove('viewer-mode');
    ['resetBtn', 'clearBtn', 'factoryBtn', 'hostBtn'].forEach(id => {
      const el = document.getElementById(id);
      if (el) el.style.display = '';
    });
  },

  showHostModal() {
    if (this.isHost) {
      // Already hosting - show current code
      this.showShareModal(this.shareCode);
      return;
    }

    const overlay = document.createElement('div');
    overlay.className = 'modal-overlay';
    overlay.innerHTML = `
      <div class="modal">
        <h2>Host Live Game</h2>
        <p class="muted">Share your game in real-time. Others can view scores as you enter them.</p>
        <div class="modal-actions">
          <button class="btn" onclick="this.closest('.modal-overlay').remove()">Cancel</button>
          <button class="btn primary" id="startHostBtn">Start Hosting</button>
        </div>
      </div>
    `;
    document.body.appendChild(overlay);

    document.getElementById('startHostBtn').onclick = async () => {
      const code = await this.hostGame();
      overlay.remove();
      if (code) this.showShareModal(code);
    };

    overlay.onclick = (e) => { if (e.target === overlay) overlay.remove(); };
  },

  showShareModal(code) {
    const url = window.location.origin + window.location.pathname + '?join=' + code;
    const overlay = document.createElement('div');
    overlay.className = 'modal-overlay';
    overlay.innerHTML = `
      <div class="modal">
        <h2>Share This Code</h2>
        <p class="muted" style="margin-bottom:16px;">Others can join with this code to view live scores:</p>
        <div style="text-align:center;margin:20px 0;">
          <div class="share-code">${code}</div>
        </div>
        <p class="muted" style="font-size:12px;">Or share this link:</p>
        <input type="text" value="${url}" readonly style="font-size:12px;margin-bottom:8px;" onclick="this.select()">
        <div class="modal-actions">
          <button class="btn" onclick="this.closest('.modal-overlay').remove()">Close</button>
          <button class="copy-btn" onclick="navigator.clipboard.writeText('${code}');Err.toast('Code copied!');">Copy Code</button>
          <button class="copy-btn" onclick="navigator.clipboard.writeText('${url}');Err.toast('Link copied!');">Copy Link</button>
        </div>
      </div>
    `;
    document.body.appendChild(overlay);
    overlay.onclick = (e) => { if (e.target === overlay) overlay.remove(); };
  },

  showJoinModal() {
    if (this.isViewer) {
      Err.toast('Already viewing a game. Disconnect first.');
      return;
    }

    const overlay = document.createElement('div');
    overlay.className = 'modal-overlay';
    overlay.innerHTML = `
      <div class="modal">
        <h2>Join Live Game</h2>
        <p class="muted">Enter the 6-character code to view a live game:</p>
        <input type="text" id="joinCodeInput" class="join-input" maxlength="6" placeholder="ABC123" style="margin:16px 0;">
        <div class="modal-actions">
          <button class="btn" onclick="this.closest('.modal-overlay').remove()">Cancel</button>
          <button class="btn primary" id="joinGameBtn">Join</button>
        </div>
      </div>
    `;
    document.body.appendChild(overlay);

    const input = document.getElementById('joinCodeInput');
    input.focus();
    input.oninput = () => { input.value = input.value.toUpperCase(); };
    input.onkeydown = (e) => { if (e.key === 'Enter') document.getElementById('joinGameBtn').click(); };

    document.getElementById('joinGameBtn').onclick = async () => {
      const code = input.value;
      const success = await this.joinGame(code);
      if (success) overlay.remove();
    };

    overlay.onclick = (e) => { if (e.target === overlay) overlay.remove(); };
  }
};

// === UTILITIES ===
const Utils = {
  fmt: n => isFinite(n) ? (n<0?'-':'') + '$' + Math.abs(n).toFixed(2) : '$0.00',
  make18: fill => Array(HOLES).fill(fill),
  uid: () => Math.random().toString(36).slice(2) + Date.now().toString(36),
  sanitize: v => String(v).replace(/[^0-9]/g, ''),
  sumRange(arr, start, end) {
    let total = 0, has = false;
    for (let i = start; i <= end && i < arr.length; i++) {
      const v = arr[i];
      if (v != null && isFinite(+v)) { total += +v; has = true; }
    }
    return has ? total : null;
  },
  clone: obj => JSON.parse(JSON.stringify(obj))
};

// === ERROR HANDLER ===
window.Err = {
  box: document.getElementById('err'),
  show(msg) { 
    console.error(msg);
    this.box.textContent = msg; 
    this.box.style.display = 'block'; 
    setTimeout(() => this.box.style.display = 'none', 5000); 
  },
  toast(msg) { 
    const t = document.createElement('div'); 
    t.className = 'success-toast'; 
    t.textContent = msg; 
    document.body.appendChild(t); 
    setTimeout(() => { t.style.opacity = '0'; setTimeout(() => t.remove(), 300); }, 2000); 
  }
};

window.addEventListener('error', ev => Err.show(`Error: ${ev.message}`));

// === STATE MANAGER ===
const State = {
  data: {
    tab: 'setup',
    players: [{id:'p1',name:'P1'},{id:'p2',name:'P2'},{id:'p3',name:'P3'},{id:'p4',name:'P4'},{id:'p5',name:'P5'}],
    games: [],
    course: {
      name: 'El Macero',
      hcp: [7,15,9,1,11,3,17,13,5,4,2,10,8,12,14,18,6,16],
      par: [4,5,3,4,5,4,3,4,4,4,4,3,4,4,5,3,4,5]
    },
    settings: { thTop: 12, thMin: 5 },
    debugStatus: false,
    lastActiveDate: null,
    roundCompleteShown: false
  },
  presets: {
    'El Macero': { hcp:[7,15,9,1,11,3,17,13,5,4,2,10,8,12,14,18,6,16], par:[4,5,3,4,5,4,3,4,4,4,4,3,4,4,5,3,4,5] },
    'Del Paso': { hcp:[11,17,1,7,15,9,3,5,13,12,10,18,8,16,6,2,14,4], par:[5,3,4,5,3,4,4,4,4,4,4,3,5,3,5,4,3,4] }
  },
  locks: 0,
  saveTimer: null,
  renderTimer: null,

  begin() { this.locks++; },
  end() {
    this.locks = Math.max(0, this.locks - 1);
    if (!this.locks) {
      this.scheduleSave();
      this.scheduleRender();
      // Check if round just completed
      if (!this.data.roundCompleteShown && this.isRoundComplete()) {
        this.data.roundCompleteShown = true;
        this.scheduleSave();
        setTimeout(() => UI.showRoundCompleteModal(), 300);
      }
    }
  },

  isRoundComplete() {
    // Check if all players have scores for all 18 holes
    const g = this.data.games[0];
    if (!g) return false;
    for (const p of this.data.players) {
      const scores = g.gross[p.id];
      if (!scores) return false;
      for (let i = 0; i < 18; i++) {
        if (scores[i] === null || scores[i] === undefined) return false;
      }
    }
    return true;
  },
  
  scheduleSave() {
    clearTimeout(this.saveTimer);
    this.saveTimer = setTimeout(() => {
      try {
        // Update lastActiveDate to today
        this.data.lastActiveDate = new Date().toDateString();
        const saveData = {...this.data, presets: this.presets};
        localStorage.setItem(STORAGE_KEY, JSON.stringify(saveData));
        // Sync to Firebase if hosting
        if (LiveSync.isHost) LiveSync.syncToFirebase();
      } catch(e) {
        Err.show('Save failed: ' + e.message);
      }
    }, 200);
  },

  scheduleRender() {
    if (this.locks > 0) return;
    clearTimeout(this.renderTimer);
    this.renderTimer = setTimeout(() => {
      try { UI.render(); }
      catch(e) { Err.show('Render failed: ' + e.message); }
    }, 120);
  },

  load() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return false;
      const obj = JSON.parse(raw);
      if (obj.players && Array.isArray(obj.players)) this.data.players = obj.players;
      if (obj.games && Array.isArray(obj.games)) this.data.games = obj.games.map(Game.sanitize);
      if (obj.course) this.data.course = obj.course;
      if (obj.presets) this.presets = obj.presets;
      if (obj.settings) this.data.settings = obj.settings;
      if (obj.lastActiveDate) this.data.lastActiveDate = obj.lastActiveDate;
      this.data.roundCompleteShown = !!obj.roundCompleteShown;
      // Validate tab value - only allow known tabs
      const validTabs = ['setup','scores','junk','status','game','transactions','highlights','rules','live'];
      this.data.tab = validTabs.includes(obj.tab) ? obj.tab : 'scores';
      this.data.debugStatus = !!obj.debugStatus;
      return true;
    } catch(e) { 
      Err.show('Load failed: ' + e.message);
      return false; 
    }
  }
};

// === GAME LOGIC ===
const Game = {
  create(clone = false) {
    const g = {
      id: Utils.uid(),
      gameType: 'nassau',
      teamA: ['p1','p2'],
      teamB: ['p3','p4'],
      teamSize: 2,
      scoringMode: 'hi_low',
      stakes: {front:2, back:5, overall:2},
      autoPress: {front:true, back:true, overall:false},
      withJunk: true,
      junkValue: {front:1, back:2},
      pointValue: {front:1, back:1},
      presses: Utils.make18(''),
      skinsPlayers: [],
      skinsMode: 'net',
      wolfPlayers: [],
      wolfTeeOrder: [],
      wolfPointValue: 1,
      wolfSelections: Utils.make18(''),
      // 9-Point specific
      ninePointPlayers: [],
      ninePointValue: 1,
      ninePointMode: 'net',
      ninePointWinBy2: true,
      ninePointBirdieDouble: false,
      gross: {},
      junkCounts: {},
      strokesCount: {}
    };
    State.data.players.forEach(p => {
      g.junkCounts[p.id] = Utils.make18(0);
      g.strokesCount[p.id] = 0;
      g.gross[p.id] = clone && State.data.games[0] ? [...State.data.games[0].gross[p.id]] : Utils.make18(null);
    });
    return g;
  },

  sanitize(g) {
    if (!g) return this.create();
    g.id = g.id || Utils.uid();
    g.gameType = ['nassau','vegas','skins','wolf','ninepoint'].includes(g.gameType) ? g.gameType : 'nassau';

    const maxTeamSize = g.gameType === 'vegas' ? 2 : (g.teamSize || 2);
    g.teamSize = [1,2].includes(g.teamSize) ? g.teamSize : 2;
    g.scoringMode = ['hi_low','low_net'].includes(g.scoringMode) ? g.scoringMode : 'hi_low';
    g.teamA = (g.teamA || []).slice(0, maxTeamSize);
    g.teamB = (g.teamB || []).slice(0, maxTeamSize);
    g.stakes = g.stakes || {front:2,back:5,overall:2};
    ['front','back','overall'].forEach(k => g.stakes[k] = Math.max(0, parseInt(g.stakes[k])||0));
    g.autoPress = g.autoPress || {front:true,back:true,overall:false};
    g.junkValue = g.junkValue || {front:1,back:2};
    ['front','back'].forEach(k => g.junkValue[k] = Math.max(0, parseInt(g.junkValue[k])||0));
    g.pointValue = g.pointValue || {front:1,back:1};
    ['front','back'].forEach(k => g.pointValue[k] = Math.max(0, parseFloat(g.pointValue[k])||1));
    // Skins-specific
    g.skinsMode = ['net','gross','both'].includes(g.skinsMode) ? g.skinsMode : 'net';
    g.skinsPlayers = Array.isArray(g.skinsPlayers) ? g.skinsPlayers : [];
    // Wolf-specific
    g.wolfPlayers = Array.isArray(g.wolfPlayers) ? g.wolfPlayers : [];
    g.wolfTeeOrder = Array.isArray(g.wolfTeeOrder) ? g.wolfTeeOrder : [];
    g.wolfPointValue = g.wolfPointValue || 1;
    g.wolfSelections = Array.isArray(g.wolfSelections) ? g.wolfSelections.slice(0,18) : Utils.make18('');
    while ((g.wolfSelections || []).length < 18) g.wolfSelections.push('');
    // 9-Point specific
    g.ninePointPlayers = Array.isArray(g.ninePointPlayers) ? g.ninePointPlayers : [];
    g.ninePointValue = g.ninePointValue || 1;
    g.ninePointMode = ['net','gross'].includes(g.ninePointMode) ? g.ninePointMode : 'net';
    g.ninePointWinBy2 = g.ninePointWinBy2 !== false;
    g.ninePointBirdieDouble = g.ninePointBirdieDouble === true;
    
    let pa = Array.isArray(g.presses) ? g.presses.slice(0,18) : Utils.make18('');
    while (pa.length < 18) pa.push('');
    g.presses = pa.map(v => ['','press','blind'].includes(v) ? v : '');
    
    g.gross = g.gross || {};
    g.junkCounts = g.junkCounts || {};
    g.strokesCount = g.strokesCount || {};
    
    State.data.players.forEach(p => {
      let ga = Array.isArray(g.gross[p.id]) ? g.gross[p.id].slice(0,18) : Utils.make18(null);
      while (ga.length < 18) ga.push(null);
      ga = ga.map(v => {
        if (v === '' || v == null) return null;
        const n = parseInt(v);
        return (n >= MIN_SCORE && n <= MAX_SCORE) ? n : null;
      });
      g.gross[p.id] = ga;
      
      let ja = Array.isArray(g.junkCounts[p.id]) ? g.junkCounts[p.id].slice(0,18) : Utils.make18(0);
      while (ja.length < 18) ja.push(0);
      g.junkCounts[p.id] = ja.map(v => Math.max(0, parseInt(v)||0));
      
      g.strokesCount[p.id] = Math.max(0, parseInt(g.strokesCount[p.id])||0);
    });
    return g;
  },

  strokes(g, pid, hole) {
    const total = g.strokesCount[pid] || 0;
    if (!total) return 0;
    const base = Math.floor(total / 18);
    const rem = total % 18;
    const rank = State.data.course.hcp[hole] || 0;
    return base + (rank > 0 && rank <= rem ? 1 : 0);
  },

  net(gross, strokes) {
    return (gross != null && isFinite(gross)) ? gross - (strokes||0) : null;
  },

  holeDiff(g, hole) {
    const A = g.teamA || [], B = g.teamB || [];
    const bestNet = (team) => {
      let best = Infinity, has = false;
      team.forEach(pid => {
        const gr = g.gross[pid] && g.gross[pid][hole];
        const n = this.net(gr, this.strokes(g, pid, hole));
        if (n != null) { best = Math.min(best, n); has = true; }
      });
      return has ? best : null;
    };

    if (g.scoringMode === 'low_net' || A.length < 2 || B.length < 2) {
      const aL = bestNet(A), bL = bestNet(B);
      if (aL == null || bL == null) return null;
      return aL < bL ? 1 : (bL < aL ? -1 : 0);
    }

    const a0 = g.gross[A[0]] && g.gross[A[0]][hole];
    const a1 = g.gross[A[1]] && g.gross[A[1]][hole];
    const b0 = g.gross[B[0]] && g.gross[B[0]][hole];
    const b1 = g.gross[B[1]] && g.gross[B[1]][hole];
    if (a0 == null || a1 == null || b0 == null || b1 == null) return null;

    const aN0 = this.net(a0, this.strokes(g,A[0],hole));
    const aN1 = this.net(a1, this.strokes(g,A[1],hole));
    const bN0 = this.net(b0, this.strokes(g,B[0],hole));
    const bN1 = this.net(b1, this.strokes(g,B[1],hole));

    const aLow = Math.min(aN0,aN1), bLow = Math.min(bN0,bN1);
    const aHi = Math.max(aN0,aN1), bHi = Math.max(bN0,bN1);
    
    let d = 0;
    if (aLow < bLow) d++; else if (bLow < aLow) d--;
    if (aHi < bHi) d++; else if (bHi < aHi) d--;
    return d;
  },

  buildSegment(g, start, end, stake, autoPress) {
    const diffs = [];
    for (let i = 0; i < 18; i++) diffs.push(this.holeDiff(g, i));
    
    const lines = [{start, end, stake, pressesTriggered:0}];
    
    if (autoPress) {
      for (let h = start; h <= end; h++) {
        let pressed = false;
        lines.forEach(line => {
          if (line.start > h || h >= end) return;
          let cum = 0, ok = true;
          for (let i = line.start; i <= h; i++) {
            if (diffs[i] == null) { ok = false; break; }
            cum += diffs[i];
          }
          if (!ok) return;
          const k = Math.floor(Math.abs(cum) / 2);
          if (k > line.pressesTriggered) {
            if (!pressed) {
              const next = h + 1;
              if (!lines.some(l => l.start === next)) {
                lines.push({start:next, end, stake, pressedBy:cum<0?'A':'B', pressesTriggered:0});
                pressed = true;
              }
            }
            line.pressesTriggered = k;
          }
        });
      }
    }

    const winners = [];
    let payA = 0, teamPayA = 0;
    const szA = (g.teamA||[]).length || 1;
    const szB = (g.teamB||[]).length || 1;

    lines.forEach(line => {
      let cum = 0, hasAnyScore = false;
      for (let i = line.start; i <= line.end; i++) {
        if (diffs[i] != null) {
          cum += diffs[i];
          hasAnyScore = true;
        }
      }
      
      if (!hasAnyScore) {
        winners.push('‚Äî');
        return;
      }
      
      // Show current standing even if incomplete (always from Team A perspective)
      if (cum > 0) { winners.push(`+${cum}`); payA += line.stake; teamPayA += line.stake * szB; }
      else if (cum < 0) { winners.push(`${cum}`); payA -= line.stake; teamPayA -= line.stake * szA; }
      else winners.push('E');
    });

    return {lines, winners, payA, teamPayA};
  },

  hasAnyScores(g) {
    return State.data.players.some(p => {
      const arr = g.gross[p.id] || [];
      return arr.some(score => score != null);
    });
  },

  computeJunk(g) {
    const sumTeam = (team, s, e) => {
      let tot = 0;
      team.forEach(pid => {
        const arr = g.junkCounts[pid] || [];
        for (let h = s; h <= e; h++) tot += (arr[h] || 0);
      });
      return tot;
    };
    const aF = sumTeam(g.teamA||[], 0, 8);
    const aB = sumTeam(g.teamA||[], 9, 17);
    const bF = sumTeam(g.teamB||[], 0, 8);
    const bB = sumTeam(g.teamB||[], 9, 17);
    const aVal = aF * (g.junkValue.front||0) + aB * (g.junkValue.back||0);
    const bVal = bF * (g.junkValue.front||0) + bB * (g.junkValue.back||0);
    // Front/back point differentials and values
    const frontNetPts = aF - bF;
    const backNetPts = aB - bB;
    const frontNetVal = frontNetPts * (g.junkValue.front||0);
    const backNetVal = backNetPts * (g.junkValue.back||0);
    return {aVal, bVal, netA: aVal - bVal, frontNetPts, backNetPts, frontNetVal, backNetVal};
  },

  computeResult(g) {
    const front = this.buildSegment(g, 0, 8, g.stakes.front, g.autoPress.front);
    const back = this.buildSegment(g, 9, 17, g.stakes.back, g.autoPress.back);
    const overall = this.buildSegment(g, 0, 17, g.stakes.overall, g.autoPress.overall);
    const junk = this.computeJunk(g);
    
    const szA = (g.teamA||[]).length || 1;
    const szB = (g.teamB||[]).length || 1;
    let junkTeam = 0;
    if (junk.netA > 0) junkTeam = junk.netA * szB;
    else if (junk.netA < 0) junkTeam = junk.netA * szA;
    
    const total = front.teamPayA + back.teamPayA + overall.teamPayA + junkTeam;
    
    return {
      segments: {front, back, overall},
      junk,
      teamTotals: {
        front: front.teamPayA,
        back: back.teamPayA,
        overall: overall.teamPayA,
        junk: junkTeam,
        total
      }
    };
  },

  computeVegasHole(g, hole) {
    const par = State.data.course.par[hole] || 4;
    const maxNet = par + 3; // Triple bogey max for Vegas

    const getTeamScores = (team) => {
      if (team.length < 2) return null;
      const p1gross = g.gross[team[0]] && g.gross[team[0]][hole];
      const p2gross = g.gross[team[1]] && g.gross[team[1]][hole];
      if (p1gross == null || p2gross == null) return null;

      // Calculate net scores, capped at triple bogey
      const p1net = Math.min(this.net(p1gross, this.strokes(g, team[0], hole)), maxNet);
      const p2net = Math.min(this.net(p2gross, this.strokes(g, team[1], hole)), maxNet);

      return {
        p1gross, p2gross, p1net, p2net,
        scores: [p1net, p2net].sort((a,b) => a-b)
      };
    };
    
    const teamA = getTeamScores(g.teamA || []);
    const teamB = getTeamScores(g.teamB || []);
    
    if (!teamA || !teamB) return null;
    
    const hasBirdie = (team) => team.p1gross < par || team.p2gross < par;
    const hasNetParOrBetter = (team) => team.p1net <= par || team.p2net <= par;

    // Flip conditions:
    // - Opponent birdie (gross) always flips your number
    // - Your own bogey flips your number, BUT only if no one on your team has net par or better
    //   (net par or better "protects" your team from self-inflicted flip)
    const aFlip = hasBirdie(teamB) || !hasNetParOrBetter(teamA);
    const bFlip = hasBirdie(teamA) || !hasNetParOrBetter(teamB);
    
    const formNumber = (data, flip) => {
      const [low, high] = data.scores;
      return flip ? (high * 10 + low) : (low * 10 + high);
    };
    
    const numA = formNumber(teamA, aFlip);
    const numB = formNumber(teamB, bFlip);
    const diff = Math.abs(numA - numB);
    
    const basePoints = numA < numB ? diff : (numA > numB ? -diff : 0);
    
    const press = g.presses[hole] || '';
    let multiplier = 1;
    if (press === 'press') multiplier = 2;
    else if (press === 'blind') multiplier = 4;
    
    return {
      numA,
      numB,
      aFlip,
      bFlip,
      aHasBirdie: hasBirdie(teamA),
      bHasBirdie: hasBirdie(teamB),
      basePoints,
      multiplier,
      pointsToA: basePoints * multiplier
    };
  },

  computeVegasResult(g) {
    let frontPoints = 0, backPoints = 0;
    const holeDetails = [];
    
    for (let h = 0; h < 18; h++) {
      const result = this.computeVegasHole(g, h);
      holeDetails.push(result);
      
      if (result) {
        if (h <= 8) frontPoints += result.pointsToA;
        else backPoints += result.pointsToA;
      }
    }
    
    const frontValue = frontPoints * (g.pointValue.front || 0) * 2;
    const backValue = backPoints * (g.pointValue.back || 0) * 2;
    
    const junk = this.computeJunk(g);
    const szA = (g.teamA||[]).length || 1;
    const szB = (g.teamB||[]).length || 1;
    let junkTeam = 0;
    if (junk.netA > 0) junkTeam = junk.netA * szB;
    else if (junk.netA < 0) junkTeam = junk.netA * szA;
    
    return {
      holeDetails,
      frontPoints,
      backPoints,
      frontValue,
      backValue,
      junkValue: junkTeam,
      totalValue: frontValue + backValue + junkTeam
    };
  },

  computeSkinsResult(g) {
    const players = (g.skinsPlayers || []);
    const mode = g.skinsMode || 'net';
    const buyIn = g.stakes.front || 20;
    const totalPot = buyIn * players.length;

    // Initialize result tracking
    const grossSkins = {}; // pid -> count
    const netSkins = {};   // pid -> count
    players.forEach(pid => { grossSkins[pid] = 0; netSkins[pid] = 0; });

    let grossCarry = 0, netCarry = 0;
    const holeDetails = [];

    for (let h = 0; h < 18; h++) {
      const detail = { hole: h + 1, grossWinner: null, netWinner: null, grossCarry: 0, netCarry: 0, grossSkins: 0, netSkins: 0 };

      // Get scores for this hole
      const scores = [];
      let allScored = true;
      players.forEach(pid => {
        const gross = g.gross[pid] && g.gross[pid][h];
        if (gross == null || gross === '') {
          allScored = false;
        } else {
          const strokes = g.strokesCount[pid] || 0;
          const hdcpHoles = State.data.course.hdcp || [];
          const getsStroke = hdcpHoles[h] <= strokes;
          const net = gross - (getsStroke ? 1 : 0);
          scores.push({ pid, gross, net });
        }
      });

      if (!allScored || scores.length === 0) {
        detail.grossCarry = grossCarry;
        detail.netCarry = netCarry;
        holeDetails.push(detail);
        continue;
      }

      // Check for gross winner (lowest gross, no ties)
      if (mode === 'gross' || mode === 'both') {
        const minGross = Math.min(...scores.map(s => s.gross));
        const grossLeaders = scores.filter(s => s.gross === minGross);
        grossCarry++;

        if (grossLeaders.length === 1) {
          // Outright winner
          const winner = grossLeaders[0].pid;
          grossSkins[winner] += grossCarry;
          detail.grossWinner = winner;
          detail.grossSkins = grossCarry;
          grossCarry = 0;
        } else if (h === 17 && grossCarry > 0) {
          // Final hole tie with carryovers - split among tied
          const split = grossCarry / grossLeaders.length;
          grossLeaders.forEach(s => { grossSkins[s.pid] += split; });
          detail.grossWinner = 'split';
          detail.grossSkins = grossCarry;
          grossCarry = 0;
        }
      }

      // Check for net winner (lowest net, no ties)
      if (mode === 'net' || mode === 'both') {
        const minNet = Math.min(...scores.map(s => s.net));
        const netLeaders = scores.filter(s => s.net === minNet);
        netCarry++;

        if (netLeaders.length === 1) {
          // Outright winner
          const winner = netLeaders[0].pid;
          netSkins[winner] += netCarry;
          detail.netWinner = winner;
          detail.netSkins = netCarry;
          netCarry = 0;
        } else if (h === 17 && netCarry > 0) {
          // Final hole tie with carryovers - split among tied
          const split = netCarry / netLeaders.length;
          netLeaders.forEach(s => { netSkins[s.pid] += split; });
          detail.netWinner = 'split';
          detail.netSkins = netCarry;
          netCarry = 0;
        }
      }

      detail.grossCarry = grossCarry;
      detail.netCarry = netCarry;
      holeDetails.push(detail);
    }

    // Calculate totals and pot distribution
    const totalGrossSkins = Object.values(grossSkins).reduce((a, b) => a + b, 0);
    const totalNetSkins = Object.values(netSkins).reduce((a, b) => a + b, 0);

    // Pot division depends on mode
    let grossPot = 0, netPot = 0;
    if (mode === 'gross') {
      grossPot = totalPot;
    } else if (mode === 'net') {
      netPot = totalPot;
    } else if (mode === 'both') {
      // Split pot, but if no skins in one category, all goes to other
      if (totalGrossSkins === 0 && totalNetSkins === 0) {
        grossPot = totalPot / 2;
        netPot = totalPot / 2;
      } else if (totalGrossSkins === 0) {
        netPot = totalPot;
      } else if (totalNetSkins === 0) {
        grossPot = totalPot;
      } else {
        grossPot = totalPot / 2;
        netPot = totalPot / 2;
      }
    }

    // Calculate per-skin value
    const grossSkinValue = totalGrossSkins > 0 ? grossPot / totalGrossSkins : 0;
    const netSkinValue = totalNetSkins > 0 ? netPot / totalNetSkins : 0;

    // Calculate player winnings
    const playerResults = {};
    players.forEach(pid => {
      const grossWin = grossSkins[pid] * grossSkinValue;
      const netWin = netSkins[pid] * netSkinValue;
      const totalWin = grossWin + netWin;
      const profit = totalWin - buyIn;
      playerResults[pid] = {
        grossSkins: grossSkins[pid],
        netSkins: netSkins[pid],
        grossWin,
        netWin,
        totalWin,
        profit
      };
    });

    return {
      holeDetails,
      grossSkins,
      netSkins,
      totalGrossSkins,
      totalNetSkins,
      grossPot,
      netPot,
      grossSkinValue,
      netSkinValue,
      grossCarry,
      netCarry,
      totalPot,
      buyIn,
      playerResults
    };
  },

  computeWolfResult(g) {
    const players = (g.wolfPlayers || []);
    const teeOrder = g.wolfTeeOrder.length ? g.wolfTeeOrder : players;
    const pointValue = g.wolfPointValue || 1;
    const selections = g.wolfSelections || [];

    // Initialize player dollars (not points - dollars account for multipliers)
    const playerDollars = {};
    players.forEach(pid => { playerDollars[pid] = 0; });

    // Catch-up start: 4 players = hole 17 (index 16), 5 players = hole 16 (index 15)
    const catchUpStart = players.length === 4 ? 16 : 15;

    let carryover = 0;
    let carryMultiplier = 1;
    const holeDetails = [];

    for (let h = 0; h < 18; h++) {
      const detail = {
        hole: h + 1,
        wolf: null,
        selection: null,
        multiplier: 1,
        wolfTeam: [],
        otherTeam: [],
        wolfBest: null,
        otherBest: null,
        winner: null,
        points: 0,
        carryover: 0
      };

      // Determine who is wolf this hole
      // Catch-up rule: player with lowest dollars becomes Wolf
      let wolfPid;
      if (h >= catchUpStart) {
        // Find player with lowest dollars
        let lowestDollars = Infinity;
        let lowestPid = teeOrder[h % teeOrder.length]; // fallback to rotation
        players.forEach(pid => {
          if (playerDollars[pid] < lowestDollars) {
            lowestDollars = playerDollars[pid];
            lowestPid = pid;
          }
        });
        wolfPid = lowestPid;
        detail.catchUp = true;
      } else {
        // Normal rotation through tee order
        const wolfIdx = h % teeOrder.length;
        wolfPid = teeOrder[wolfIdx];
      }
      detail.wolf = wolfPid;

      // Get wolf's selection for this hole
      const sel = selections[h] || '';
      detail.selection = sel;

      // Determine multiplier and teams based on selection
      let wolfTeam = [wolfPid];
      let otherTeam = players.filter(p => p !== wolfPid);
      let mult = 1;

      if (sel === 'blind') {
        mult = 4;
        // Wolf goes alone
      } else if (sel === 'wolf') {
        mult = 2;
        // Wolf goes alone
      } else if (sel && players.includes(sel)) {
        // Wolf picked a partner
        mult = 1;
        wolfTeam = [wolfPid, sel];
        otherTeam = players.filter(p => p !== wolfPid && p !== sel);
      }

      detail.multiplier = mult;
      detail.wolfTeam = wolfTeam;
      detail.otherTeam = otherTeam;

      // Get scores for this hole
      let allScored = true;
      const scores = {};
      players.forEach(pid => {
        const gross = g.gross[pid] && g.gross[pid][h];
        if (gross == null || gross === '') {
          allScored = false;
        } else {
          const strokes = g.strokesCount[pid] || 0;
          const hdcpHoles = State.data.course.hdcp || [];
          const getsStroke = hdcpHoles[h] <= strokes;
          scores[pid] = { gross, net: gross - (getsStroke ? 1 : 0) };
        }
      });

      if (!allScored || !sel) {
        detail.carryover = carryover;
        holeDetails.push(detail);
        continue;
      }

      // Calculate best ball for each team
      const wolfScores = wolfTeam.map(p => scores[p] ? scores[p].net : 99).filter(s => s !== 99);
      const otherScores = otherTeam.map(p => scores[p] ? scores[p].net : 99).filter(s => s !== 99);

      if (wolfScores.length === 0 || otherScores.length === 0) {
        detail.carryover = carryover;
        holeDetails.push(detail);
        continue;
      }

      const wolfBest = Math.min(...wolfScores);
      const otherBest = Math.min(...otherScores);
      detail.wolfBest = wolfBest;
      detail.otherBest = otherBest;

      // Calculate points for this hole
      const basePoints = 1;
      const holePoints = basePoints * mult * carryMultiplier;
      const totalPoints = holePoints + carryover;
      const holeDollars = totalPoints * pointValue;

      if (wolfBest < otherBest) {
        // Wolf team wins - each winner gets full points, each loser loses full points
        detail.winner = 'wolf';
        detail.points = totalPoints;
        wolfTeam.forEach(p => { playerDollars[p] += holeDollars; });
        otherTeam.forEach(p => { playerDollars[p] -= holeDollars; });
        carryover = 0;
        carryMultiplier = 1;
      } else if (otherBest < wolfBest) {
        // Other team wins - each winner gets full points, each loser loses full points
        detail.winner = 'others';
        detail.points = totalPoints;
        otherTeam.forEach(p => { playerDollars[p] += holeDollars; });
        wolfTeam.forEach(p => { playerDollars[p] -= holeDollars; });
        carryover = 0;
        carryMultiplier = 1;
      } else {
        // Tie - carry over
        detail.winner = 'tie';
        carryover += holePoints;
        carryMultiplier *= mult > 1 ? mult : 1; // Stack multipliers on ties
      }

      detail.carryover = carryover;
      holeDetails.push(detail);
    }

    // Calculate final standings (pay up the ladder) - using dollars
    const standings = players.map(pid => ({
      pid,
      dollars: playerDollars[pid]
    })).sort((a, b) => b.dollars - a.dollars);

    // Calculate transactions (pay up the ladder)
    // Divide diff by 2 because each player's dollars include their side of each bet
    // e.g., A at +$1 and C at -$1 means diff of $2, but actual bet was $1
    const transactions = [];
    for (let i = 0; i < standings.length; i++) {
      for (let j = i + 1; j < standings.length; j++) {
        const diff = standings[i].dollars - standings[j].dollars;
        if (diff > 0) {
          const amount = diff / 2;
          transactions.push({
            from: standings[j].pid,
            to: standings[i].pid,
            amount: amount
          });
        }
      }
    }

    // Calculate per-player net from transactions (pay-up-the-ladder)
    const playerNet = {};
    players.forEach(pid => { playerNet[pid] = 0; });
    transactions.forEach(t => {
      playerNet[t.to] += t.amount;
      playerNet[t.from] -= t.amount;
    });

    return {
      holeDetails,
      playerDollars,
      playerNet,
      standings,
      transactions,
      pointValue,
      carryover,
      totalMoney: transactions.reduce((sum, t) => sum + t.amount, 0)
    };
  },

  computeNinePointResult(g) {
    const players = (g.ninePointPlayers || []);
    const pointValue = g.ninePointValue || 1;
    const mode = g.ninePointMode || 'net';
    const winBy2 = g.ninePointWinBy2 !== false;
    const birdieDouble = g.ninePointBirdieDouble === true;

    // Initialize player points
    const playerPoints = {};
    players.forEach(pid => { playerPoints[pid] = 0; });

    const holeDetails = [];

    for (let h = 0; h < 18; h++) {
      const detail = {
        hole: h + 1,
        scores: {},
        points: {},
        winner: null,
        winBy2Applied: false,
        birdieDoubleApplied: false
      };

      // Get scores for this hole
      let allScored = true;
      const scores = [];
      players.forEach(pid => {
        const gross = g.gross[pid] && g.gross[pid][h];
        if (gross == null || gross === '') {
          allScored = false;
        } else {
          let score = gross;
          if (mode === 'net') {
            const strokes = g.strokesCount[pid] || 0;
            const hdcpHoles = State.data.course.hdcp || [];
            const getsStroke = hdcpHoles[h] <= strokes;
            score = gross - (getsStroke ? 1 : 0);
          }
          scores.push({ pid, gross, net: score, score });
          detail.scores[pid] = { gross, net: score };
        }
      });

      if (!allScored || scores.length !== 3) {
        players.forEach(pid => { detail.points[pid] = 0; });
        holeDetails.push(detail);
        continue;
      }

      // Sort by score (lowest first)
      scores.sort((a, b) => a.score - b.score);
      const par = State.data.course.par[h] || 4;

      // Determine points based on ties
      const s1 = scores[0].score, s2 = scores[1].score, s3 = scores[2].score;
      let pts = {};

      if (s1 === s2 && s2 === s3) {
        // Three-way tie: 3/3/3
        pts[scores[0].pid] = 3;
        pts[scores[1].pid] = 3;
        pts[scores[2].pid] = 3;
      } else if (s1 === s2) {
        // Two tied for best: 4/4/1
        pts[scores[0].pid] = 4;
        pts[scores[1].pid] = 4;
        pts[scores[2].pid] = 1;
      } else if (s2 === s3) {
        // Two tied for worst: 5/2/2
        pts[scores[0].pid] = 5;
        pts[scores[1].pid] = 2;
        pts[scores[2].pid] = 2;
        detail.winner = scores[0].pid;
      } else {
        // All different: 5/3/1
        pts[scores[0].pid] = 5;
        pts[scores[1].pid] = 3;
        pts[scores[2].pid] = 1;
        detail.winner = scores[0].pid;
      }

      // Win by 2 rule: if winner won by 2+ strokes, they get all 9 points
      if (winBy2 && detail.winner && (s2 - s1) >= 2) {
        detail.winBy2Applied = true;
        const winnerGross = scores[0].gross;
        const isBirdie = winnerGross <= par - 1;

        if (birdieDouble && isBirdie) {
          // Birdie doubles: 18/0/0
          detail.birdieDoubleApplied = true;
          pts[scores[0].pid] = 18;
          pts[scores[1].pid] = 0;
          pts[scores[2].pid] = 0;
        } else {
          // Win by 2: 9/0/0
          pts[scores[0].pid] = 9;
          pts[scores[1].pid] = 0;
          pts[scores[2].pid] = 0;
        }
      }

      detail.points = pts;
      players.forEach(pid => { playerPoints[pid] += pts[pid] || 0; });
      holeDetails.push(detail);
    }

    // Calculate final standings
    const standings = players.map(pid => ({
      pid,
      points: playerPoints[pid],
      dollars: playerPoints[pid] * pointValue
    })).sort((a, b) => b.points - a.points);

    // Calculate transactions (compare each pair)
    const transactions = [];
    for (let i = 0; i < standings.length; i++) {
      for (let j = i + 1; j < standings.length; j++) {
        const diff = standings[i].points - standings[j].points;
        if (diff > 0) {
          transactions.push({
            from: standings[j].pid,
            to: standings[i].pid,
            points: diff,
            amount: diff * pointValue
          });
        }
      }
    }

    // Calculate per-player net
    const playerNet = {};
    players.forEach(pid => { playerNet[pid] = 0; });
    transactions.forEach(t => {
      playerNet[t.to] += t.amount;
      playerNet[t.from] -= t.amount;
    });

    return {
      holeDetails,
      playerPoints,
      playerNet,
      standings,
      transactions,
      pointValue,
      totalMoney: transactions.reduce((sum, t) => sum + t.amount, 0)
    };
  },

  getLastScored() {
    const g = State.data.games[0];
    if (!g || !g.gross) return -1;
    let last = -1;
    for (let h = 0; h < 18; h++) {
      for (const p of State.data.players) {
        const v = g.gross[p.id] && g.gross[p.id][h];
        if (v != null && v !== '') { last = h; break; }
      }
    }
    return last;
  }
};

// === DOM HELPER ===
const h = (tag, attrs = {}, children = []) => {
  const el = document.createElement(tag);
  Object.entries(attrs).forEach(([k,v]) => {
    if (k === 'class') el.className = v;
    else if (k === 'style') el.setAttribute('style', v);
    else if (k.startsWith('on') && typeof v === 'function') el.addEventListener(k.slice(2).toLowerCase(), v);
    else if (k === 'value') el.value = v ?? '';
    else if (k === 'checked') el.checked = !!v;
    else if (k === 'disabled') el.disabled = !!v;
    else if (k === 'selected') el.selected = !!v;
    else el.setAttribute(k, v);
  });
  (Array.isArray(children) ? children : [children]).forEach(ch => {
    if (ch == null) return;
    el.appendChild(typeof ch === 'string' ? document.createTextNode(ch) : ch);
  });
  return el;
};

// === WIZARD ===
const Wizard = {
  active: false,
  step: 'splash', // splash, course, players, game, done
  data: {
    players: [{name:'', handicap:0}, {name:'', handicap:0}],
    selectedCourse: null,
    games: []
  },
  currentGameIndex: 0,

  start() {
    this.active = true;
    this.step = 'splash';
    this.data = {
      players: [{name:'', handicap:0}, {name:'', handicap:0}],
      selectedCourse: null,
      games: []
    };
    this.currentGameIndex = 0;
    this.data.games.push(this.createGameData());
    this.render();
    // Auto-advance from splash after 4 seconds
    setTimeout(() => {
      if (this.step === 'splash') {
        this.step = 'course';
        this.render();
      }
    }, 4000);
  },

  getCurrentGame() {
    return this.data.games[this.currentGameIndex];
  },

  switchToGame(index) {
    if (index >= 0 && index < this.data.games.length) {
      this.currentGameIndex = index;
      this.render();
    }
  },

  addNewGame() {
    const lastGame = this.getCurrentGame();
    const newGame = this.createGameData();
    // Copy team assignments from last game
    newGame.teamA = [...lastGame.teamA];
    newGame.teamB = [...lastGame.teamB];
    this.data.games.push(newGame);
    this.currentGameIndex = this.data.games.length - 1;
    this.render();
  },

  deleteGame(index) {
    if (this.data.games.length <= 1) return;
    this.data.games.splice(index, 1);
    if (this.currentGameIndex >= this.data.games.length) {
      this.currentGameIndex = this.data.games.length - 1;
    }
    this.render();
  },

  createGameData() {
    return {
      gameType: 'nassau',
      teamA: [],
      teamB: [],
      withJunk: true,
      handicapMode: 'full', // full, off_low, team_delta
      stakes: {front:2, back:5, overall:2},
      junkValue: {front:1, back:2},
      pointValue: {front:1, back:1}
    };
  },

  skip() {
    this.active = false;
    this.removeOverlay();
    State.data.tab = 'setup';
    State.scheduleRender();
  },

  finish() {
    // Apply wizard data to State
    // Players
    State.data.players = this.data.players.filter(p => p.name.trim()).map((p, i) => ({
      id: 'p' + (i+1),
      name: p.name.trim()
    }));

    // Course (if new one was selected/created, it's already in State.data.course)

    // Games
    State.data.games = this.data.games.map((wg, idx) => {
      const g = Game.create();
      g.gameType = wg.gameType;
      g.teamA = wg.teamA;
      g.teamB = wg.teamB;
      g.stakes = {...wg.stakes};
      g.withJunk = wg.withJunk;
      g.junkValue = wg.withJunk ? {...wg.junkValue} : {front:0, back:0};
      g.pointValue = {...wg.pointValue};
      // Skins-specific
      g.skinsMode = wg.skinsMode || 'net';
      g.skinsPlayers = wg.skinsPlayers || [];
      // Wolf-specific
      g.wolfPlayers = wg.wolfPlayers || [];
      g.wolfTeeOrder = (wg.wolfTeeOrder || []).length ? [...wg.wolfTeeOrder] : [...(wg.wolfPlayers || [])];
      g.wolfPointValue = wg.wolfPointValue || 1;
      // 9-Point-specific
      g.ninePointPlayers = wg.ninePointPlayers || [];
      g.ninePointMode = wg.ninePointMode || 'net';
      g.ninePointValue = wg.ninePointValue || 1;
      g.ninePointWinBy2 = wg.ninePointWinBy2 !== false;
      g.ninePointBirdieDouble = wg.ninePointBirdieDouble === true;

      // Apply handicap strokes based on mode
      const playerHandicaps = {};
      this.data.players.forEach((p, i) => {
        if (p.name.trim()) playerHandicaps['p'+(i+1)] = p.handicap || 0;
      });

      if (wg.handicapMode === 'full') {
        // Everyone gets full strokes
        Object.keys(playerHandicaps).forEach(pid => {
          g.strokesCount[pid] = playerHandicaps[pid];
        });
      } else if (wg.handicapMode === 'off_low') {
        // Reduce by lowest
        const min = Math.min(...Object.values(playerHandicaps));
        Object.keys(playerHandicaps).forEach(pid => {
          g.strokesCount[pid] = playerHandicaps[pid] - min;
        });
      } else if (wg.handicapMode === 'team_delta') {
        // High player on high team gets delta
        const teamATotal = wg.teamA.reduce((s, pid) => s + (playerHandicaps[pid]||0), 0);
        const teamBTotal = wg.teamB.reduce((s, pid) => s + (playerHandicaps[pid]||0), 0);
        Object.keys(playerHandicaps).forEach(pid => g.strokesCount[pid] = 0);

        if (teamATotal > teamBTotal) {
          // Team A is high, find high player on Team A
          let highPid = wg.teamA[0], highVal = playerHandicaps[wg.teamA[0]] || 0;
          wg.teamA.forEach(pid => {
            if ((playerHandicaps[pid]||0) > highVal) { highPid = pid; highVal = playerHandicaps[pid]||0; }
          });
          g.strokesCount[highPid] = teamATotal - teamBTotal;
        } else if (teamBTotal > teamATotal) {
          // Team B is high
          let highPid = wg.teamB[0], highVal = playerHandicaps[wg.teamB[0]] || 0;
          wg.teamB.forEach(pid => {
            if ((playerHandicaps[pid]||0) > highVal) { highPid = pid; highVal = playerHandicaps[pid]||0; }
          });
          g.strokesCount[highPid] = teamBTotal - teamATotal;
        }
      }

      return Game.sanitize(g);
    });

    this.active = false;
    this.removeOverlay();
    State.data.tab = 'scores';
    State.data.roundCompleteShown = false;
    State.scheduleSave();
    State.scheduleRender();
    Err.toast('Game ready! Enter scores.');
  },

  removeOverlay() {
    const overlay = document.getElementById('wizardOverlay');
    if (overlay) overlay.remove();
  },

  updateWolfUI() {
    const g = this.data.games[this.currentGameIndex];
    if (!g || g.gameType !== 'wolf') return;

    // Update player chip classes
    document.querySelectorAll('[data-wolf-pid]').forEach(chip => {
      const pid = chip.dataset.wolfPid;
      const inGame = (g.wolfPlayers || []).includes(pid);
      chip.classList.toggle('skins-selected', inGame);
      chip.classList.toggle('skins-unselected', !inGame);
    });

    // Update player count text
    const countEl = document.getElementById('wolfPlayerCount');
    if (countEl) {
      const count = (g.wolfPlayers || []).length;
      countEl.textContent = `${count} player${count !== 1 ? 's' : ''} selected`;
    }

    // Show/hide tee order section
    const teeSection = document.getElementById('wolfTeeOrderSection');
    if (teeSection) {
      teeSection.style.display = (g.wolfPlayers || []).length >= 4 ? '' : 'none';
    }

    // Update tee order list
    const teeList = document.getElementById('wolfTeeOrderList');
    if (teeList && (g.wolfPlayers || []).length >= 4) {
      const order = g.wolfTeeOrder.length ? g.wolfTeeOrder : g.wolfPlayers;
      teeList.innerHTML = order.map((pid, idx, arr) => {
        const playerIdx = parseInt(pid.slice(1)) - 1;
        const player = this.data.players[playerIdx];
        const isFirst = idx === 0;
        const isLast = idx === arr.length - 1;
        return player && player.name ? `<div class="wolf-tee-order-item" data-wolf-order-pid="${pid}" style="display:flex;align-items:center;gap:8px;padding:8px 12px;background:var(--card);border:1px solid var(--border);border-radius:8px;">
          <span style="color:var(--muted);font-weight:600;min-width:20px;">${idx+1}.</span>
          <span style="flex:1;">${player.name}</span>
          <button type="button" class="wolf-order-btn" data-wolf-move="up" data-wolf-pid="${pid}" ${isFirst?'disabled':''} style="padding:4px 10px;font-size:16px;border:1px solid var(--border);border-radius:4px;background:${isFirst?'var(--muted)':'var(--card)'};cursor:${isFirst?'default':'pointer'};">‚ñ≤</button>
          <button type="button" class="wolf-order-btn" data-wolf-move="down" data-wolf-pid="${pid}" ${isLast?'disabled':''} style="padding:4px 10px;font-size:16px;border:1px solid var(--border);border-radius:4px;background:${isLast?'var(--muted)':'var(--card)'};cursor:${isLast?'default':'pointer'};">‚ñº</button>
        </div>` : '';
      }).join('');

      // Re-attach tee order button handlers
      teeList.querySelectorAll('.wolf-order-btn').forEach(btn => {
        btn.onclick = (e) => {
          e.preventDefault();
          e.stopPropagation();
          const pid = btn.dataset.wolfPid;
          const dir = btn.dataset.wolfMove;
          const currentOrder = g.wolfTeeOrder.length ? [...g.wolfTeeOrder] : [...g.wolfPlayers];
          const idx = currentOrder.indexOf(pid);
          if (idx === -1) return;
          if (dir === 'up' && idx > 0) {
            [currentOrder[idx-1], currentOrder[idx]] = [currentOrder[idx], currentOrder[idx-1]];
          } else if (dir === 'down' && idx < currentOrder.length - 1) {
            [currentOrder[idx], currentOrder[idx+1]] = [currentOrder[idx+1], currentOrder[idx]];
          }
          g.wolfTeeOrder = currentOrder;
          State.scheduleSave();
          this.updateWolfUI();
        };
      });
    }
  },

  render() {
    this.removeOverlay();
    if (!this.active) return;

    const overlay = document.createElement('div');
    overlay.id = 'wizardOverlay';
    overlay.className = 'wizard-overlay';

    let content;
    switch(this.step) {
      case 'splash': content = this.renderSplash(); break;
      case 'course': content = this.renderCourse(); break;
      case 'courseSetup': content = this.renderCourseSetup(); break;
      case 'players': content = this.renderPlayers(); break;
      case 'game': content = this.renderGame(); break;
      default: content = document.createElement('div');
    }

    overlay.appendChild(content);
    document.body.appendChild(overlay);
  },

  renderSplash() {
    const div = document.createElement('div');
    div.className = 'wizard-splash';
    div.innerHTML = `<img src="https://raw.githubusercontent.com/Bunch313131/nassau-app/main/BunchBets180.png" alt="Bunch Bets">`;
    return div;
  },

  renderCourse() {
    const div = document.createElement('div');
    div.className = 'wizard-screen';

    const presetNames = Object.keys(State.presets || {});
    const coursesHtml = presetNames.map(name => `
      <div class="wizard-course-card" data-course="${name}">
        <h3>${name}</h3>
        <p>Saved course preset</p>
      </div>
    `).join('');

    div.innerHTML = `
      <div class="wizard-header">
        <h2>Select Course</h2>
        <p>Choose a saved course or use current setup</p>
      </div>
      <div class="wizard-content">
        <div class="wizard-course-card selected" data-course="__current__">
          <h3>Current Course</h3>
          <p>Use existing course configuration</p>
        </div>
        ${coursesHtml}
        <div class="wizard-course-card" data-course="__new__">
          <h3>+ Set Up New Course</h3>
          <p>Configure par and handicap for each hole</p>
        </div>
      </div>
      <div class="wizard-footer">
        <button class="btn primary" id="wizardCourseNext">Next</button>
        <div class="wizard-skip">
          <a id="wizardSkip">Skip to Advanced Setup</a>
        </div>
      </div>
    `;

    // Event handlers
    setTimeout(() => {
      div.querySelectorAll('.wizard-course-card').forEach(card => {
        card.onclick = () => {
          div.querySelectorAll('.wizard-course-card').forEach(c => c.classList.remove('selected'));
          card.classList.add('selected');
          this.data.selectedCourse = card.dataset.course;
        };
      });

      document.getElementById('wizardCourseNext').onclick = () => {
        if (this.data.selectedCourse === '__new__') {
          // Go to course setup screen
          this.step = 'courseSetup';
          this.render();
          return;
        }
        if (this.data.selectedCourse && this.data.selectedCourse !== '__current__') {
          // Load preset
          const preset = State.presets[this.data.selectedCourse];
          if (preset) {
            State.data.course.par = [...preset.par];
            State.data.course.hcp = [...preset.hcp];
          }
        }
        this.step = 'players';
        this.render();
      };

      document.getElementById('wizardSkip').onclick = () => this.skip();
    }, 0);

    return div;
  },

  renderCourseSetup() {
    const div = document.createElement('div');
    div.className = 'wizard-screen';

    // Initialize temp course data if not set
    if (!this.data.newCourse) {
      this.data.newCourse = {
        name: '',
        par: [...State.data.course.par],
        hcp: [...State.data.course.hcp]
      };
    }

    const frontHoles = [];
    const backHoles = [];
    for (let i = 0; i < 9; i++) {
      frontHoles.push(`
        <div class="wizard-hole-col">
          <div class="wizard-hole-num">${i+1}</div>
          <input type="number" class="wizard-hole-input" data-hole="${i}" data-field="par" value="${this.data.newCourse.par[i] || ''}" min="3" max="6" placeholder="P">
          <input type="number" class="wizard-hole-input" data-hole="${i}" data-field="hcp" value="${this.data.newCourse.hcp[i] || ''}" min="1" max="18" placeholder="H">
        </div>
      `);
      backHoles.push(`
        <div class="wizard-hole-col">
          <div class="wizard-hole-num">${i+10}</div>
          <input type="number" class="wizard-hole-input" data-hole="${i+9}" data-field="par" value="${this.data.newCourse.par[i+9] || ''}" min="3" max="6" placeholder="P">
          <input type="number" class="wizard-hole-input" data-hole="${i+9}" data-field="hcp" value="${this.data.newCourse.hcp[i+9] || ''}" min="1" max="18" placeholder="H">
        </div>
      `);
    }

    div.innerHTML = `
      <div class="wizard-header">
        <h2>Course Setup</h2>
        <p>Enter course details</p>
      </div>
      <div class="wizard-content">
        <div class="wizard-section">
          <div class="wizard-section-title">Course Name</div>
          <input type="text" id="wizardCourseName" placeholder="Course name" value="${this.data.newCourse.name}" style="width:100%;margin-bottom:16px;">
        </div>
        <div class="wizard-section">
          <div class="wizard-section-title">Front 9 (Par / Handicap)</div>
          <div class="wizard-holes-grid">${frontHoles.join('')}</div>
        </div>
        <div class="wizard-section">
          <div class="wizard-section-title">Back 9 (Par / Handicap)</div>
          <div class="wizard-holes-grid">${backHoles.join('')}</div>
        </div>
        <div class="wizard-section">
          <label style="display:flex;align-items:center;gap:8px;cursor:pointer;">
            <input type="checkbox" id="wizardSavePreset" checked>
            <span>Save as course preset</span>
          </label>
        </div>
      </div>
      <div class="wizard-footer">
        <button class="btn secondary" id="wizardCourseSetupBack">Back</button>
        <button class="btn primary" id="wizardCourseSetupNext">Next</button>
      </div>
    `;

    setTimeout(() => {
      // Course name input
      document.getElementById('wizardCourseName').oninput = (e) => {
        this.data.newCourse.name = e.target.value;
      };

      // Par and handicap inputs
      div.querySelectorAll('.wizard-hole-input').forEach(input => {
        input.oninput = (e) => {
          const hole = parseInt(e.target.dataset.hole);
          const field = e.target.dataset.field;
          const val = parseInt(e.target.value) || 0;
          this.data.newCourse[field][hole] = val;
        };
      });

      document.getElementById('wizardCourseSetupBack').onclick = () => {
        this.step = 'course';
        this.render();
      };

      document.getElementById('wizardCourseSetupNext').onclick = () => {
        // Apply course to state
        State.data.course.name = this.data.newCourse.name || 'New Course';
        State.data.course.par = [...this.data.newCourse.par];
        State.data.course.hcp = [...this.data.newCourse.hcp];

        // Save as preset if checked
        if (document.getElementById('wizardSavePreset').checked && this.data.newCourse.name.trim()) {
          State.presets[this.data.newCourse.name.trim()] = {
            par: [...this.data.newCourse.par],
            hcp: [...this.data.newCourse.hcp]
          };
        }

        this.step = 'players';
        this.render();
      };
    }, 0);

    return div;
  },

  renderPlayers() {
    const div = document.createElement('div');
    div.className = 'wizard-screen';

    const playersHtml = this.data.players.map((p, i) => `
      <div class="wizard-player-row">
        <input type="text" placeholder="Player ${i+1} name" value="${p.name}" data-idx="${i}" data-field="name">
        <input type="number" placeholder="HCP" value="${p.handicap || ''}" data-idx="${i}" data-field="handicap" min="0" max="54">
        ${i >= 2 ? `<button class="delete-btn" data-idx="${i}">&times;</button>` : '<div></div>'}
      </div>
    `).join('');

    div.innerHTML = `
      <div class="wizard-header">
        <h2>Who's Playing?</h2>
        <p>Add players and their course handicaps</p>
      </div>
      <div class="wizard-content">
        <div class="wizard-player-row header">
          <div>Name</div>
          <div>Handicap</div>
          <div></div>
        </div>
        <div id="wizardPlayersList">${playersHtml}</div>
        ${this.data.players.length < 5 ? '<button class="wizard-add-btn" id="wizardAddPlayer">+ Add Player</button>' : ''}
      </div>
      <div class="wizard-footer">
        <button class="btn secondary" id="wizardPlayersBack">Back</button>
        <button class="btn primary" id="wizardPlayersNext">Next</button>
      </div>
    `;

    setTimeout(() => {
      div.querySelectorAll('input[data-field="name"]').forEach(input => {
        input.oninput = (e) => {
          this.data.players[parseInt(e.target.dataset.idx)].name = e.target.value;
        };
      });

      div.querySelectorAll('input[data-field="handicap"]').forEach(input => {
        input.oninput = (e) => {
          this.data.players[parseInt(e.target.dataset.idx)].handicap = parseInt(e.target.value) || 0;
        };
      });

      div.querySelectorAll('.delete-btn').forEach(btn => {
        btn.onclick = (e) => {
          this.data.players.splice(parseInt(e.target.dataset.idx), 1);
          this.render();
        };
      });

      const addBtn = document.getElementById('wizardAddPlayer');
      if (addBtn) {
        addBtn.onclick = () => {
          this.data.players.push({name:'', handicap:0});
          this.render();
        };
      }

      document.getElementById('wizardPlayersNext').onclick = () => {
        const validPlayers = this.data.players.filter(p => p.name.trim());
        if (validPlayers.length < 2) {
          Err.toast('Need at least 2 players');
          return;
        }
        // Auto-assign teams for first game if not already set
        const g = this.getCurrentGame();
        if (g.teamA.length === 0 && g.teamB.length === 0) {
          const pids = validPlayers.map((p, i) => 'p' + (i+1));
          if (pids.length >= 4) {
            g.teamA = [pids[0], pids[1]];
            g.teamB = [pids[2], pids[3]];
          } else if (pids.length === 3) {
            g.teamA = [pids[0]];
            g.teamB = [pids[1]];
          } else {
            g.teamA = [pids[0]];
            g.teamB = [pids[1]];
          }
        }
        this.step = 'game';
        this.render();
      };

      document.getElementById('wizardPlayersBack').onclick = () => {
        this.step = 'course';
        this.render();
      };
    }, 0);

    return div;
  },

  renderGame() {
    const div = document.createElement('div');
    div.className = 'wizard-screen';
    const g = this.getCurrentGame();
    const validPlayers = this.data.players.filter(p => p.name.trim()).map((p, i) => ({id: 'p'+(i+1), name: p.name}));

    const teamAHtml = g.teamA.map(pid => {
      const p = validPlayers.find(x => x.id === pid);
      return p ? `<span class="wizard-player-chip team-a" data-pid="${pid}">${p.name}</span>` : '';
    }).join('');

    const teamBHtml = g.teamB.map(pid => {
      const p = validPlayers.find(x => x.id === pid);
      return p ? `<span class="wizard-player-chip team-b" data-pid="${pid}">${p.name}</span>` : '';
    }).join('');

    const unassigned = validPlayers.filter(p => !g.teamA.includes(p.id) && !g.teamB.includes(p.id));
    const unassignedHtml = unassigned.map(p => `<span class="wizard-player-chip" data-pid="${p.id}">${p.name}</span>`).join('');

    // Build game tabs
    const gameTabsHtml = this.data.games.map((game, idx) => {
      const isActive = idx === this.currentGameIndex;
      const canDelete = this.data.games.length > 1;
      const gameLabel = game.gameType === 'vegas' ? 'Vegas' : game.gameType === 'skins' ? 'Skins' : 'Nassau';
      return `<span class="wizard-game-tab ${isActive ? 'active' : ''}" data-game-idx="${idx}">
        Game ${idx + 1}${canDelete && isActive ? '<span class="delete-game" data-delete-idx="' + idx + '">&times;</span>' : ''}
      </span>`;
    }).join('');

    div.innerHTML = `
      <div class="wizard-header">
        <h2>Game Setup</h2>
        <div class="wizard-game-tabs">${gameTabsHtml}<span class="wizard-game-tab" data-add-game="1">+ New</span></div>
      </div>
      <div class="wizard-content">
        <div class="wizard-section">
          <div class="wizard-section-title">Game Type</div>
          <div class="wizard-option ${g.gameType==='nassau'?'selected':''}" data-type="nassau">
            <input type="radio" name="gameType" ${g.gameType==='nassau'?'checked':''}>
            <div style="flex:1;"><strong>Nassau</strong><br><span class="muted">2v2 match play - high/low ball with presses</span></div>
            <button type="button" class="help-btn" data-help="nassau">?</button>
          </div>
          <div class="wizard-option ${g.gameType==='vegas'?'selected':''}" data-type="vegas">
            <input type="radio" name="gameType" ${g.gameType==='vegas'?'checked':''}>
            <div style="flex:1;"><strong>Vegas</strong><br><span class="muted">2v2 team digits - combine scores, birdies flip</span></div>
            <button type="button" class="help-btn" data-help="vegas">?</button>
          </div>
          <div class="wizard-option ${g.gameType==='skins'?'selected':''}" data-type="skins">
            <input type="radio" name="gameType" ${g.gameType==='skins'?'checked':''}>
            <div style="flex:1;"><strong>Skins</strong><br><span class="muted">2-5 players - win hole outright to take the skin</span></div>
            <button type="button" class="help-btn" data-help="skins">?</button>
          </div>
          <div class="wizard-option ${g.gameType==='wolf'?'selected':''}" data-type="wolf">
            <input type="radio" name="gameType" ${g.gameType==='wolf'?'checked':''}>
            <div style="flex:1;"><strong>Wolf</strong><br><span class="muted">4-5 players - pick your partner each hole</span></div>
            <button type="button" class="help-btn" data-help="wolf">?</button>
          </div>
          <div class="wizard-option ${g.gameType==='ninepoint'?'selected':''}" data-type="ninepoint">
            <input type="radio" name="gameType" ${g.gameType==='ninepoint'?'checked':''}>
            <div style="flex:1;"><strong>9-Point</strong><br><span class="muted">3 players - 5/3/1 points per hole</span></div>
            <button type="button" class="help-btn" data-help="ninepoint">?</button>
          </div>
        </div>

        ${g.gameType === 'skins' ? `
        <div class="wizard-section">
          <div class="wizard-section-title">Players (tap to toggle, 2-5 players)</div>
          <div style="display:flex;flex-wrap:wrap;gap:8px;justify-content:center;">
            ${this.data.players.filter(p=>p.name.trim()).map((p,i) => {
              const pid = 'p'+(i+1);
              const inGame = (g.skinsPlayers || []).includes(pid);
              return `<div class="wizard-player-chip ${inGame?'skins-selected':'skins-unselected'}" data-skins-pid="${pid}" style="cursor:pointer;">${p.name}</div>`;
            }).join('')}
          </div>
          <div class="muted" style="font-size:12px;margin-top:8px;text-align:center;">${(g.skinsPlayers||[]).length} player${(g.skinsPlayers||[]).length!==1?'s':''} selected</div>
        </div>
        <div class="wizard-section">
          <div class="wizard-section-title">Skins Mode</div>
          <div class="wizard-option ${g.skinsMode==='net'?'selected':''}" data-skins-mode="net">
            <input type="radio" name="skinsMode" ${g.skinsMode==='net'?'checked':''}>
            <div><strong>Net</strong><br><span class="muted">Handicap strokes apply</span></div>
          </div>
          <div class="wizard-option ${g.skinsMode==='gross'?'selected':''}" data-skins-mode="gross">
            <input type="radio" name="skinsMode" ${g.skinsMode==='gross'?'checked':''}>
            <div><strong>Gross</strong><br><span class="muted">Raw scores only</span></div>
          </div>
          <div class="wizard-option ${g.skinsMode==='both'?'selected':''}" data-skins-mode="both">
            <input type="radio" name="skinsMode" ${g.skinsMode==='both'?'checked':''}>
            <div><strong>Net + Gross</strong><br><span class="muted">Two separate pots</span></div>
          </div>
        </div>
        ` : g.gameType === 'wolf' ? `
        <div class="wizard-section">
          <div class="wizard-section-title">Players (tap to toggle, 4-5 players)</div>
          <div id="wolfPlayerChips" style="display:flex;flex-wrap:wrap;gap:8px;justify-content:center;">
            ${this.data.players.filter(p=>p.name.trim()).map((p,i) => {
              const pid = 'p'+(i+1);
              const inGame = (g.wolfPlayers || []).includes(pid);
              return `<div class="wizard-player-chip ${inGame?'skins-selected':'skins-unselected'}" data-wolf-pid="${pid}" style="cursor:pointer;">${p.name}</div>`;
            }).join('')}
          </div>
          <div id="wolfPlayerCount" class="muted" style="font-size:12px;margin-top:8px;text-align:center;">${(g.wolfPlayers||[]).length} player${(g.wolfPlayers||[]).length!==1?'s':''} selected</div>
        </div>
        <div id="wolfTeeOrderSection" style="${(g.wolfPlayers||[]).length >= 4 ? '' : 'display:none;'}">
        <div class="wizard-section">
          <div class="wizard-section-title">Tee Order (tap arrows to reorder)</div>
          <div id="wolfTeeOrderList" style="display:flex;flex-direction:column;gap:6px;">
            ${(g.wolfTeeOrder.length ? g.wolfTeeOrder : g.wolfPlayers).map((pid, idx, arr) => {
              const playerIdx = parseInt(pid.slice(1)) - 1;
              const player = this.data.players[playerIdx];
              const isFirst = idx === 0;
              const isLast = idx === arr.length - 1;
              return player && player.name ? `<div class="wolf-tee-order-item" data-wolf-order-pid="${pid}" style="display:flex;align-items:center;gap:8px;padding:8px 12px;background:var(--card);border:1px solid var(--border);border-radius:8px;">
                <span style="color:var(--muted);font-weight:600;min-width:20px;">${idx+1}.</span>
                <span style="flex:1;">${player.name}</span>
                <button type="button" class="wolf-order-btn" data-wolf-move="up" data-wolf-pid="${pid}" ${isFirst?'disabled':''} style="padding:4px 10px;font-size:16px;border:1px solid var(--border);border-radius:4px;background:${isFirst?'var(--muted)':'var(--card)'};cursor:${isFirst?'default':'pointer'};">‚ñ≤</button>
                <button type="button" class="wolf-order-btn" data-wolf-move="down" data-wolf-pid="${pid}" ${isLast?'disabled':''} style="padding:4px 10px;font-size:16px;border:1px solid var(--border);border-radius:4px;background:${isLast?'var(--muted)':'var(--card)'};cursor:${isLast?'default':'pointer'};">‚ñº</button>
              </div>` : '';
            }).join('')}
          </div>
          <div class="muted" style="font-size:12px;margin-top:8px;">Player 1 tees off first on hole 1, then rotates each hole.</div>
        </div>
        </div>
        ` : g.gameType === 'ninepoint' ? `
        <div class="wizard-section">
          <div class="wizard-section-title">Players (exactly 3 players)</div>
          <div id="ninePointPlayerChips" style="display:flex;flex-wrap:wrap;gap:8px;justify-content:center;">
            ${this.data.players.filter(p=>p.name.trim()).map((p,i) => {
              const pid = 'p'+(i+1);
              const inGame = (g.ninePointPlayers || []).includes(pid);
              return `<div class="wizard-player-chip ${inGame?'skins-selected':'skins-unselected'}" data-ninepoint-pid="${pid}" style="cursor:pointer;">${p.name}</div>`;
            }).join('')}
          </div>
          <div id="ninePointPlayerCount" class="muted" style="font-size:12px;margin-top:8px;text-align:center;">${(g.ninePointPlayers||[]).length}/3 players</div>
        </div>
        <div class="wizard-section">
          <div class="wizard-section-title">Scoring Mode</div>
          <div class="wizard-option ${g.ninePointMode==='net'?'selected':''}" data-ninepoint-mode="net">
            <input type="radio" name="ninePointMode" ${g.ninePointMode==='net'?'checked':''}>
            <div><strong>Net</strong><br><span class="muted">Handicap strokes apply</span></div>
          </div>
          <div class="wizard-option ${g.ninePointMode==='gross'?'selected':''}" data-ninepoint-mode="gross">
            <input type="radio" name="ninePointMode" ${g.ninePointMode==='gross'?'checked':''}>
            <div><strong>Gross</strong><br><span class="muted">Raw scores only</span></div>
          </div>
        </div>
        <div class="wizard-section">
          <div class="wizard-section-title">Optional Rules</div>
          <label style="display:flex;align-items:center;gap:8px;cursor:pointer;padding:8px 0;">
            <input type="checkbox" id="wizardNinePointWinBy2" ${g.ninePointWinBy2?'checked':''} style="width:20px;height:20px;">
            <div><strong>Win by 2</strong><br><span class="muted">Win by 2+ strokes = all 9 points</span></div>
          </label>
          <label style="display:flex;align-items:center;gap:8px;cursor:pointer;padding:8px 0;">
            <input type="checkbox" id="wizardNinePointBirdieDouble" ${g.ninePointBirdieDouble?'checked':''} style="width:20px;height:20px;">
            <div><strong>Birdie Doubles</strong><br><span class="muted">Win by 2+ with birdie = 18 points</span></div>
          </label>
        </div>
        ` : `
        <div class="wizard-section">
          <div class="wizard-section-title">Teams (tap to reassign)</div>
          <div class="grid grid-2" style="gap:12px;">
            <div class="wizard-team-zone" id="teamAZone">
              <h4>Team A</h4>
              ${teamAHtml || '<span class="muted">Tap players below</span>'}
            </div>
            <div class="wizard-team-zone" id="teamBZone">
              <h4>Team B</h4>
              ${teamBHtml || '<span class="muted">Tap players below</span>'}
            </div>
          </div>
          ${unassignedHtml ? `<div style="margin-top:12px;text-align:center;"><div class="muted" style="font-size:12px;margin-bottom:6px;">Not in game:</div>${unassignedHtml}</div>` : ''}
        </div>
        `}

        ${g.gameType !== 'skins' || g.skinsMode !== 'gross' ? `
        <div class="wizard-section">
          <div class="wizard-section-title">Handicap Mode</div>
          <div class="wizard-option ${g.handicapMode==='full'?'selected':''}" data-hcp="full">
            <input type="radio" name="hcpMode" ${g.handicapMode==='full'?'checked':''}>
            <div><strong>Full Strokes</strong><br><span class="muted">Everyone gets their full handicap</span></div>
          </div>
          <div class="wizard-option ${g.handicapMode==='off_low'?'selected':''}" data-hcp="off_low">
            <input type="radio" name="hcpMode" ${g.handicapMode==='off_low'?'checked':''}>
            <div><strong>Off the Low</strong><br><span class="muted">Reduce all by lowest handicap</span></div>
          </div>
          ${g.gameType !== 'skins' && g.gameType !== 'wolf' && g.gameType !== 'ninepoint' ? `
          <div class="wizard-option ${g.handicapMode==='team_delta'?'selected':''}" data-hcp="team_delta">
            <input type="radio" name="hcpMode" ${g.handicapMode==='team_delta'?'checked':''}>
            <div><strong>Team Delta</strong><br><span class="muted">High player on high team gets difference</span></div>
          </div>
          ` : ''}
        </div>
        ` : ''}

        ${g.gameType !== 'skins' ? `
        <div class="wizard-section">
          <label style="display:flex;align-items:center;gap:8px;cursor:pointer;">
            <input type="checkbox" id="wizardJunkToggle" ${g.withJunk?'checked':''} style="width:20px;height:20px;">
            <span>Include Junk (birdies, sandies, etc.)</span>
          </label>
        </div>
        ` : ''}

        ${g.gameType === 'skins' ? `
        <div class="wizard-section">
          <div class="wizard-section-title">Buy-in (per player)</div>
          <div style="max-width:120px;">
            <div class="currency-input-wrap">
              <input type="number" class="currency-input" id="wizardSkinsBuyIn" value="${(g.stakes.front||20).toFixed(2)}" min="0" step="1">
            </div>
          </div>
          <div class="muted" style="font-size:12px;margin-top:8px;">Total pot: $${((g.stakes.front||20) * (g.skinsPlayers||[]).length).toFixed(2)}</div>
        </div>
        ` : g.gameType === 'wolf' ? `
        <div class="wizard-section">
          <div class="wizard-section-title">Point Value</div>
          <div style="max-width:120px;">
            <div class="currency-input-wrap">
              <input type="number" class="currency-input" id="wizardWolfPointValue" value="${(g.wolfPointValue||1).toFixed(2)}" min="0" step="0.01">
            </div>
          </div>
          <div class="muted" style="font-size:12px;margin-top:8px;">Wolf = 2x points, Blind Wolf = 4x points</div>
        </div>
        ` : g.gameType === 'ninepoint' ? `
        <div class="wizard-section">
          <div class="wizard-section-title">Point Value ($/point)</div>
          <div style="max-width:120px;">
            <div class="currency-input-wrap">
              <input type="number" class="currency-input" id="wizardNinePointValue" value="${(g.ninePointValue||1).toFixed(2)}" min="0" step="0.01">
            </div>
          </div>
          <div class="muted" style="font-size:12px;margin-top:8px;">9 points per hole √ó 18 holes = 162 total points</div>
        </div>
        ` : `
        <div class="wizard-section">
          <div class="wizard-section-title">${g.gameType==='vegas'?'$/Point':'Stakes'}</div>
          <div class="grid grid-3" style="gap:8px;">
            <div>
              <div class="muted" style="font-size:12px;margin-bottom:4px;">Front</div>
              <div class="currency-input-wrap">
                <input type="number" class="currency-input" id="wizardStakesFront" value="${(g.gameType==='vegas'?g.pointValue.front:g.stakes.front).toFixed(2)}" min="0" step="0.01">
              </div>
            </div>
            <div>
              <div class="muted" style="font-size:12px;margin-bottom:4px;">Back</div>
              <div class="currency-input-wrap">
                <input type="number" class="currency-input" id="wizardStakesBack" value="${(g.gameType==='vegas'?g.pointValue.back:g.stakes.back).toFixed(2)}" min="0" step="0.01">
              </div>
            </div>
            ${g.gameType==='nassau'?`
            <div>
              <div class="muted" style="font-size:12px;margin-bottom:4px;">Overall</div>
              <div class="currency-input-wrap">
                <input type="number" class="currency-input" id="wizardStakesOverall" value="${g.stakes.overall.toFixed(2)}" min="0" step="0.01">
              </div>
            </div>
            `:'<div></div>'}
          </div>
        </div>
        `}

        <div class="wizard-section" id="wizardJunkStakes" style="${g.withJunk && g.gameType !== 'skins'?'':'display:none;'}">
          <div class="wizard-section-title">Junk $/point</div>
          <div class="grid grid-2" style="gap:8px;">
            <div>
              <div class="muted" style="font-size:12px;margin-bottom:4px;">Front</div>
              <div class="currency-input-wrap">
                <input type="number" class="currency-input" id="wizardJunkFront" value="${g.junkValue.front.toFixed(2)}" min="0" step="0.01">
              </div>
            </div>
            <div>
              <div class="muted" style="font-size:12px;margin-bottom:4px;">Back</div>
              <div class="currency-input-wrap">
                <input type="number" class="currency-input" id="wizardJunkBack" value="${g.junkValue.back.toFixed(2)}" min="0" step="0.01">
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="wizard-footer">
        <button class="btn secondary" id="wizardGameBack">Back</button>
        <button class="btn" id="wizardGameNext">+ Add Game</button>
        <button class="btn primary" id="wizardStartScoring" style="background:var(--success);border-color:var(--success);">Start Scoring</button>
      </div>
    `;

    setTimeout(() => {
      // Game tabs - switch between games
      div.querySelectorAll('[data-game-idx]').forEach(tab => {
        tab.onclick = (e) => {
          if (e.target.classList.contains('delete-game')) return;
          this.switchToGame(parseInt(tab.dataset.gameIdx));
        };
      });

      // Add new game tab
      div.querySelectorAll('[data-add-game]').forEach(tab => {
        tab.onclick = () => this.addNewGame();
      });

      // Delete game buttons
      div.querySelectorAll('[data-delete-idx]').forEach(btn => {
        btn.onclick = (e) => {
          e.stopPropagation();
          this.deleteGame(parseInt(btn.dataset.deleteIdx));
        };
      });

      // Game type
      div.querySelectorAll('[data-type]').forEach(opt => {
        opt.onclick = () => {
          const newType = opt.dataset.type;
          if (newType !== g.gameType) {
            g.gameType = newType;
            // Apply default stakes for game type
            if (newType === 'nassau') {
              g.stakes = {front:2, back:5, overall:2};
              g.junkValue = {front:1, back:2};
            } else if (newType === 'vegas') {
              g.stakes = {front:1, back:2, overall:0};
              g.junkValue = {front:1, back:2};
            } else if (newType === 'skins') {
              g.stakes = {front:20, back:0, overall:0};
              g.junkValue = {front:0, back:0};
              g.withJunk = false;
              g.skinsMode = g.skinsMode || 'net';
            } else if (newType === 'wolf') {
              g.wolfPointValue = g.wolfPointValue || 1;
              g.junkValue = {front:1, back:2};
              g.withJunk = true;
              g.wolfPlayers = g.wolfPlayers || [];
              g.wolfTeeOrder = g.wolfTeeOrder || [];
            } else if (newType === 'ninepoint') {
              g.ninePointValue = g.ninePointValue || 1;
              g.junkValue = {front:1, back:2};
              g.withJunk = true;
              g.ninePointPlayers = g.ninePointPlayers || [];
              g.ninePointMode = g.ninePointMode || 'net';
              g.ninePointWinBy2 = g.ninePointWinBy2 !== false;
              g.ninePointBirdieDouble = g.ninePointBirdieDouble === true;
            }
            // Update visual state immediately before re-render
            div.querySelectorAll('[data-type]').forEach(o => {
              const isSelected = o.dataset.type === newType;
              o.classList.toggle('selected', isSelected);
              const radio = o.querySelector('input[type="radio"]');
              if (radio) radio.checked = isSelected;
            });
          }
          this.render();
        };
      });

      // Help buttons for game types
      div.querySelectorAll('.help-btn[data-help]').forEach(btn => {
        btn.onclick = (e) => {
          e.stopPropagation();
          const type = btn.dataset.help;
          let title = '';
          let content = '';
          if (type === 'nassau') {
            title = 'Nassau';
            content = '<p><strong>Nassau</strong> is a 2v2 match play format with three separate bets: Front 9, Back 9, and Overall 18.</p>' +
              '<p><strong>How it works:</strong></p>' +
              '<ul>' +
              '<li><strong>Low Ball:</strong> Best score on each team competes</li>' +
              '<li><strong>High Ball:</strong> Worst score on each team competes</li>' +
              '<li>Win both = win the hole (+1)</li>' +
              '<li>Split = push (0)</li>' +
              '<li>Lose both = lose the hole (-1)</li>' +
              '</ul>' +
              '<p><strong>Presses:</strong> When a team is down 2 or more, a new bet automatically starts (auto-press). All active bets run in parallel.</p>' +
              '<p><strong>Scoring:</strong> Each bet pays out based on the final margin. Stakes are per player.</p>';
          } else if (type === 'vegas') {
            title = 'Vegas';
            content = '<p><strong>Vegas</strong> is a 2v2 format where team scores are combined as digits, not added.</p>' +
              '<p><strong>How it works:</strong></p>' +
              '<ul>' +
              '<li>If Team A shoots 4 and 5, their score is <strong>45</strong> (not 9)</li>' +
              '<li>Lower digit always goes first (4-5 = 45, not 54)</li>' +
              '<li>Point difference = higher team number minus lower</li>' +
              '</ul>' +
              '<p><strong>Flip Rule:</strong> Your digits flip (45‚Üí54) if: (1) opponent makes a gross birdie, OR (2) no one on your team has net par or better.</p>' +
              '<p><strong>Triple Bogey Max:</strong> No individual score counts higher than triple bogey to prevent blowouts.</p>' +
              '<p><strong>Presses:</strong> The trailing team can press after the first team tees off (2x points) or blind press before anyone tees off (4x points).</p>' +
              '<p><strong>Scoring:</strong> Point differential times stake value. Stakes are per player.</p>';
          } else if (type === 'skins') {
            title = 'Skins';
            content = '<p><strong>Skins</strong> is an individual game for 2-5 players where each hole is worth a "skin."</p>' +
              '<p><strong>How it works:</strong></p>' +
              '<ul>' +
              '<li>Win the hole outright (lowest score, no ties) to win the skin</li>' +
              '<li>If two or more players tie for lowest, the skin <strong>carries over</strong> to the next hole</li>' +
              '<li>Carryovers accumulate until someone wins outright</li>' +
              '</ul>' +
              '<p><strong>Modes:</strong></p>' +
              '<ul>' +
              '<li><strong>Net:</strong> Handicap strokes apply - lowest net score wins</li>' +
              '<li><strong>Gross:</strong> Raw scores only - lowest gross score wins</li>' +
              '<li><strong>Net + Gross:</strong> Two separate pots - can win both on same hole</li>' +
              '</ul>' +
              '<p><strong>Payout:</strong> Total pot divided by number of skins won. If Net+Gross, each pot is calculated separately.</p>' +
              '<p><strong>Final hole ties:</strong> If the last hole ties with carryovers, the pot splits evenly among tied players.</p>';
          } else if (type === 'wolf') {
            title = 'Wolf';
            content = '<p><strong>Wolf</strong> is a 4-5 player game where one player (the Wolf) chooses their partner each hole.</p>' +
              '<p><strong>Tee Order:</strong> Players rotate who tees off first. The first player is the Wolf for that hole.</p>' +
              '<p><strong>Wolf\'s Choices:</strong></p>' +
              '<ul>' +
              '<li><strong>Pick a Partner:</strong> After seeing a player\'s tee shot, call them as your partner (2v2 or 2v3)</li>' +
              '<li><strong>Wolf:</strong> Go alone after all tee shots (1v3 or 1v4) - worth <strong>2x points</strong></li>' +
              '<li><strong>Blind Wolf:</strong> Declare before teeing off (1v3 or 1v4) - worth <strong>4x points</strong></li>' +
              '</ul>' +
              '<p><strong>Scoring:</strong> Lowest net score wins the hole (best ball). Winners earn points, losers pay up the ladder at the end.</p>' +
              '<p><strong>Carryovers:</strong> If a hole ties, points carry over with multipliers stacking.</p>' +
              '<p><strong>Catch-up:</strong> On the final holes (17-18 for 4 players, 16-18 for 5 players), the player with the lowest dollars becomes Wolf.</p>' +
              '<p><strong>Junk:</strong> Individual bets (birdies, sandies, etc.) are paid separately.</p>';
          } else if (type === 'ninepoint') {
            title = '9-Point';
            content = '<p><strong>9-Point</strong> (also called 5-3-1) is a game for exactly 3 players where each hole is worth 9 points.</p>' +
              '<p><strong>Point Distribution:</strong></p>' +
              '<ul>' +
              '<li><strong>All different scores:</strong> 5 / 3 / 1 (best to worst)</li>' +
              '<li><strong>Two tied for best:</strong> 4 / 4 / 1</li>' +
              '<li><strong>Two tied for worst:</strong> 5 / 2 / 2</li>' +
              '<li><strong>Three-way tie:</strong> 3 / 3 / 3</li>' +
              '</ul>' +
              '<p><strong>Win by 2 (optional):</strong> If you win by 2+ strokes, you get all 9 points (9/0/0).</p>' +
              '<p><strong>Birdie Doubles (optional):</strong> Win by 2+ with a birdie or better = 18 points.</p>' +
              '<p><strong>Settlement:</strong> At the end, compare point totals and pay based on the difference √ó $/point.</p>';
          }
          // Show modal
          const modal = document.createElement('div');
          modal.className = 'modal-overlay';
          modal.innerHTML = '<div class="modal" style="max-width:400px;"><div class="modal-header"><span class="modal-title">' + title + '</span><button class="modal-close">&times;</button></div><div class="modal-body" style="text-align:left;font-size:14px;">' + content + '</div></div>';
          document.body.appendChild(modal);
          modal.querySelector('.modal-close').onclick = () => modal.remove();
          modal.onclick = (ev) => { if (ev.target === modal) modal.remove(); };
        };
      });

      // Handicap mode
      div.querySelectorAll('[data-hcp]').forEach(opt => {
        opt.onclick = () => {
          g.handicapMode = opt.dataset.hcp;
          this.render();
        };
      });

      // Team assignment (max 2 per team)
      div.querySelectorAll('.wizard-player-chip').forEach(chip => {
        chip.onclick = () => {
          const pid = chip.dataset.pid;
          // Cycle: unassigned -> A -> B -> unassigned (max 2 per team)
          if (g.teamA.includes(pid)) {
            g.teamA = g.teamA.filter(x => x !== pid);
            if (g.teamB.length < 2) g.teamB.push(pid);
          } else if (g.teamB.includes(pid)) {
            g.teamB = g.teamB.filter(x => x !== pid);
          } else {
            // Unassigned - try to add to Team A first, then B
            if (g.teamA.length < 2) g.teamA.push(pid);
            else if (g.teamB.length < 2) g.teamB.push(pid);
          }
          this.render();
        };
      });

      // Junk toggle (only exists for non-skins games)
      const junkToggle = document.getElementById('wizardJunkToggle');
      if (junkToggle) {
        junkToggle.onchange = (e) => {
          g.withJunk = e.target.checked;
          document.getElementById('wizardJunkStakes').style.display = g.withJunk ? '' : 'none';
        };
      }

      // Skins player toggle
      div.querySelectorAll('[data-skins-pid]').forEach(chip => {
        chip.onclick = () => {
          const pid = chip.dataset.skinsPid;
          g.skinsPlayers = g.skinsPlayers || [];
          const wasSelected = g.skinsPlayers.includes(pid);
          if (wasSelected) {
            g.skinsPlayers = g.skinsPlayers.filter(x => x !== pid);
            chip.classList.remove('skins-selected');
            chip.classList.add('skins-unselected');
          } else if (g.skinsPlayers.length < 5) {
            g.skinsPlayers.push(pid);
            chip.classList.remove('skins-unselected');
            chip.classList.add('skins-selected');
          }
          State.scheduleSave();
        };
      });

      // Skins mode selection
      div.querySelectorAll('[data-skins-mode]').forEach(opt => {
        opt.onclick = () => {
          g.skinsMode = opt.dataset.skinsMode;
          this.render();
        };
      });

      // Skins buy-in
      const skinsBuyIn = document.getElementById('wizardSkinsBuyIn');
      if (skinsBuyIn) {
        skinsBuyIn.onchange = (e) => {
          g.stakes.front = parseFloat(e.target.value) || 20;
          this.render();
        };
      }

      // Wolf player toggle
      div.querySelectorAll('[data-wolf-pid]').forEach(chip => {
        chip.onclick = () => {
          const pid = chip.dataset.wolfPid;
          g.wolfPlayers = g.wolfPlayers || [];
          g.wolfTeeOrder = g.wolfTeeOrder || [];
          const wasSelected = g.wolfPlayers.includes(pid);
          if (wasSelected) {
            g.wolfPlayers = g.wolfPlayers.filter(x => x !== pid);
            g.wolfTeeOrder = g.wolfTeeOrder.filter(x => x !== pid);
          } else if (g.wolfPlayers.length < 5) {
            g.wolfPlayers.push(pid);
            if (!g.wolfTeeOrder.includes(pid)) {
              g.wolfTeeOrder.push(pid);
            }
          }
          // Sync tee order with players
          g.wolfTeeOrder = g.wolfTeeOrder.filter(x => g.wolfPlayers.includes(x));
          State.scheduleSave();
          this.updateWolfUI();
        };
      });

      // Wolf tee order up/down buttons
      div.querySelectorAll('.wolf-order-btn').forEach(btn => {
        btn.onclick = (e) => {
          e.preventDefault();
          e.stopPropagation();
          const pid = btn.dataset.wolfPid;
          const dir = btn.dataset.wolfMove;
          const order = g.wolfTeeOrder.length ? [...g.wolfTeeOrder] : [...g.wolfPlayers];
          const idx = order.indexOf(pid);
          if (idx === -1) return;
          if (dir === 'up' && idx > 0) {
            [order[idx-1], order[idx]] = [order[idx], order[idx-1]];
          } else if (dir === 'down' && idx < order.length - 1) {
            [order[idx], order[idx+1]] = [order[idx+1], order[idx]];
          }
          g.wolfTeeOrder = order;
          State.scheduleSave();
          this.updateWolfUI();
        };
      });

      // Wolf point value input
      const wolfPointInput = document.getElementById('wizardWolfPointValue');
      if (wolfPointInput) {
        wolfPointInput.onchange = (e) => {
          g.wolfPointValue = parseFloat(e.target.value) || 1;
        };
      }

      // 9-Point player toggle
      div.querySelectorAll('[data-ninepoint-pid]').forEach(chip => {
        chip.onclick = () => {
          const pid = chip.dataset.ninepointPid;
          g.ninePointPlayers = g.ninePointPlayers || [];
          const wasSelected = g.ninePointPlayers.includes(pid);
          if (wasSelected) {
            g.ninePointPlayers = g.ninePointPlayers.filter(x => x !== pid);
            chip.classList.remove('skins-selected');
            chip.classList.add('skins-unselected');
          } else if (g.ninePointPlayers.length < 3) {
            g.ninePointPlayers.push(pid);
            chip.classList.remove('skins-unselected');
            chip.classList.add('skins-selected');
          }
          // Update player count display
          const countEl = document.getElementById('ninePointPlayerCount');
          if (countEl) countEl.textContent = `${g.ninePointPlayers.length}/3 players`;
          State.scheduleSave();
        };
      });

      // 9-Point mode selection
      div.querySelectorAll('[data-ninepoint-mode]').forEach(opt => {
        opt.onclick = () => {
          g.ninePointMode = opt.dataset.ninepointMode;
          this.render();
        };
      });

      // 9-Point optional rules
      const ninePointWinBy2 = document.getElementById('wizardNinePointWinBy2');
      if (ninePointWinBy2) {
        ninePointWinBy2.onchange = (e) => {
          g.ninePointWinBy2 = e.target.checked;
          State.scheduleSave();
        };
      }
      const ninePointBirdieDouble = document.getElementById('wizardNinePointBirdieDouble');
      if (ninePointBirdieDouble) {
        ninePointBirdieDouble.onchange = (e) => {
          g.ninePointBirdieDouble = e.target.checked;
          State.scheduleSave();
        };
      }

      // 9-Point value input
      const ninePointValueInput = document.getElementById('wizardNinePointValue');
      if (ninePointValueInput) {
        ninePointValueInput.onchange = (e) => {
          g.ninePointValue = parseFloat(e.target.value) || 1;
        };
      }

      // Stakes inputs (only for non-skins games)
      const stakesFront = document.getElementById('wizardStakesFront');
      if (stakesFront) {
        stakesFront.onchange = (e) => {
          const v = parseFloat(e.target.value) || 0;
          if (g.gameType === 'vegas') g.pointValue.front = v;
          else g.stakes.front = v;
        };
      }
      const stakesBack = document.getElementById('wizardStakesBack');
      if (stakesBack) {
        stakesBack.onchange = (e) => {
          const v = parseFloat(e.target.value) || 0;
          if (g.gameType === 'vegas') g.pointValue.back = v;
          else g.stakes.back = v;
        };
      }
      const overallInput = document.getElementById('wizardStakesOverall');
      if (overallInput) {
        overallInput.onchange = (e) => {
          g.stakes.overall = parseFloat(e.target.value) || 0;
        };
      }
      const junkFront = document.getElementById('wizardJunkFront');
      if (junkFront) {
        junkFront.onchange = (e) => {
          g.junkValue.front = parseFloat(e.target.value) || 0;
        };
      }
      const junkBack = document.getElementById('wizardJunkBack');
      if (junkBack) {
        junkBack.onchange = (e) => {
          g.junkValue.back = parseFloat(e.target.value) || 0;
        };
      }

      // Navigation
      document.getElementById('wizardGameNext').onclick = () => {
        if (g.gameType === 'skins') {
          if ((g.skinsPlayers || []).length < 2) {
            Err.toast('Select at least 2 players for Skins');
            return;
          }
        } else if (g.gameType === 'wolf') {
          if ((g.wolfPlayers || []).length < 4) {
            Err.toast('Select at least 4 players for Wolf');
            return;
          }
        } else if (g.gameType === 'ninepoint') {
          if ((g.ninePointPlayers || []).length !== 3) {
            Err.toast('Select exactly 3 players for 9-Point');
            return;
          }
        } else if (g.teamA.length === 0 || g.teamB.length === 0) {
          Err.toast('Assign players to both teams');
          return;
        }
        this.addNewGame();
      };

      document.getElementById('wizardStartScoring').onclick = () => {
        // Validate all games have proper assignments
        for (let i = 0; i < this.data.games.length; i++) {
          const game = this.data.games[i];
          if (game.gameType === 'skins') {
            if ((game.skinsPlayers || []).length < 2) {
              Err.toast(`Game ${i+1} needs at least 2 players`);
              this.switchToGame(i);
              return;
            }
          } else if (game.gameType === 'wolf') {
            if ((game.wolfPlayers || []).length < 4) {
              Err.toast(`Game ${i+1} needs at least 4 players`);
              this.switchToGame(i);
              return;
            }
          } else if (game.gameType === 'ninepoint') {
            if ((game.ninePointPlayers || []).length !== 3) {
              Err.toast(`Game ${i+1} needs exactly 3 players`);
              this.switchToGame(i);
              return;
            }
          } else if (game.teamA.length === 0 || game.teamB.length === 0) {
            Err.toast(`Game ${i+1} needs teams assigned`);
            this.switchToGame(i);
            return;
          }
        }
        this.finish();
      };

      document.getElementById('wizardGameBack').onclick = () => {
        this.step = 'players';
        this.render();
      };
    }, 0);

    return div;
  }
};

// === UI ===
const UI = {
  playerName(id) {
    const p = State.data.players.find(x => x.id === id);
    return p ? p.name : id;
  },

  gameLabel(g) {
    const abbr = (pid, used) => {
      const nm = this.playerName(pid);
      if (/[0-9]/.test(nm)) {
        const s = nm.toUpperCase();
        if (!used[s]) { used[s] = true; return s; }
      }
      const base = nm.replace(/[^A-Za-z]/g, '').toUpperCase() || String(pid).toUpperCase();
      for (let len = 1; len <= Math.min(3, base.length); len++) {
        const c = base.slice(0, len);
        if (!used[c]) { used[c] = true; return c; }
      }
      const stem = base.slice(0, 2) || base;
      let n = 2;
      while (used[stem + n]) n++;
      used[stem + n] = true;
      return stem + n;
    };
    const used = {};
    const a1 = g.teamA && g.teamA[0] ? abbr(g.teamA[0], used) : '';
    const a2 = g.teamA && g.teamA[1] ? abbr(g.teamA[1], used) : '';
    const b1 = g.teamB && g.teamB[0] ? abbr(g.teamB[0], used) : '';
    const b2 = g.teamB && g.teamB[1] ? abbr(g.teamB[1], used) : '';
    const left = (a1 && a2) ? `${a1}/${a2}` : (a1 || a2 || 'Team A');
    const right = (b1 && b2) ? `${b1}/${b2}` : (b1 || b2 || 'Team B');
    
    if (g.gameType === 'skins') {
      const count = (g.skinsPlayers || []).length;
      const modeLabel = g.skinsMode === 'both' ? 'Net+Gross' : (g.skinsMode === 'gross' ? 'Gross' : 'Net');
      return `Skins ${modeLabel} (${count}p)`;
    } else if (g.gameType === 'wolf') {
      const count = (g.wolfPlayers || []).length;
      return `Wolf (${count}p)`;
    } else if (g.gameType === 'ninepoint') {
      const modeLabel = g.ninePointMode === 'gross' ? 'Gross' : 'Net';
      return `9-Point ${modeLabel}`;
    } else if (g.gameType === 'vegas') {
      return `Vegas: ${left} vs ${right}`;
    } else {
      const mode = g.scoringMode === 'low_net' ? 'Best Ball' : 'Hi/Low';
      return `${mode}: ${left} vs ${right}`;
    }
  },

  render() {
    if (State.locks > 0) return;
    this.renderTabs();
    const root = document.getElementById('app');
    root.innerHTML = '';
    let view;
    switch (State.data.tab) {
      case 'setup': view = this.setup(); break;
      case 'scores': view = this.scores(); break;
      case 'junk': view = this.junk(); break;
      case 'status': view = this.status(); break;
      case 'game': view = this.game(); break;
      case 'transactions': view = this.transactions(); break;
      case 'highlights': view = this.highlights(); break;
      case 'rules': view = this.rules(); break;
      case 'live': view = this.scores(); break; // Live tab defaults to scores view
      default: view = this.scores(); // Default to scores instead of error
    }
    // Header always visible now (contains hamburger menu)
    root.appendChild(view);
  },

  renderTabs() {
    const tabs = [
      ['scores','Scores'],['junk','Junk'],
      ['status','Status'],['game','Game Details'],['transactions','Payments'],['highlights','Highlights'],['rules','Rules'],
      ['setup','Setup (Advanced)']
    ];

    // Populate menu navigation
    const menuNav = document.getElementById('menuNav');
    if (menuNav) {
      menuNav.innerHTML = '';
      tabs.forEach(([id, label]) => {
        const btn = document.createElement('button');
        btn.className = `menu-item ${State.data.tab === id ? 'active' : ''}`;
        btn.textContent = label;
        btn.onclick = () => {
          State.data.tab = id;
          this.closeMenu();
          State.scheduleRender();
        };
        menuNav.appendChild(btn);
      });
    }

    // Hide old tabs bar (keeping element for compatibility)
    const tabsEl = document.getElementById('tabs');
    if (tabsEl) tabsEl.style.display = 'none';
  },

  openMenu() {
    document.getElementById('menuOverlay').classList.add('open');
    document.getElementById('slideMenu').classList.add('open');
    document.body.style.overflow = 'hidden';
  },

  closeMenu() {
    document.getElementById('menuOverlay').classList.remove('open');
    document.getElementById('slideMenu').classList.remove('open');
    document.body.style.overflow = '';
  },

  initMenu() {
    document.getElementById('menuToggle').onclick = () => this.openMenu();
    document.getElementById('menuClose').onclick = () => this.closeMenu();
    document.getElementById('menuOverlay').onclick = () => this.closeMenu();

    // Theme toggle (checkbox)
    const themeToggle = document.getElementById('themeToggle');
    // Load saved theme
    const savedTheme = localStorage.getItem('bunchbets-theme');
    if (savedTheme === 'light') {
      document.documentElement.classList.add('light-mode');
      themeToggle.checked = true;
    }
    themeToggle.onchange = () => {
      document.documentElement.classList.toggle('light-mode', themeToggle.checked);
      localStorage.setItem('bunchbets-theme', themeToggle.checked ? 'light' : 'dark');
    };
  },

  setup() {
    // Players
    const playerInputs = State.data.players.map(p => 
      h('div', {style:'display:grid;grid-template-columns:64px 1fr;gap:8px;'}, [
        h('span', {class:'muted',style:'text-align:right;'}, p.id),
        h('input', {
          type:'text', value:p.name,
          onfocus:() => State.begin(),
          oninput:(e) => p.name = e.target.value,
          onblur:() => State.end()
        })
      ])
    );

    // Course
    const presetSel = h('select', {
      onchange:(e) => {
        const pr = State.presets[e.target.value];
        if (pr) {
          State.data.course.hcp = [...pr.hcp];
          State.data.course.par = [...pr.par];
          State.data.course.name = e.target.value;
          State.scheduleSave();
          State.scheduleRender();
        }
      }
    });
    Object.keys(State.presets).forEach(nm => {
      presetSel.appendChild(h('option', {value:nm, selected:nm===State.data.course.name}, nm));
    });

    const hcpHead = [h('th',{class:'sticky'},'HOLE')];
    for (let i = 0; i < 18; i++) hcpHead.push(h('th',{},String(i+1)));
    const parRow = [h('td',{class:'sticky'},'PAR')];
    for (let i = 0; i < 18; i++) {
      parRow.push(h('td',{},[
        h('input',{
          type:'tel',inputmode:'numeric',value:State.data.course.par[i]||4,
          style:'width:56px;text-align:center;',
          onfocus:()=>State.begin(),
          oninput:(e)=>{e.target.value=Utils.sanitize(e.target.value);},
          onblur:(e)=>{
            const v = Math.min(6, Math.max(3, parseInt(e.target.value)||4));
            State.data.course.par[i] = v;
            e.target.value = String(v);
            State.end();
          }
        })
      ]));
    }
    const hcpRow = [h('td',{class:'sticky'},'HCP')];
    for (let i = 0; i < 18; i++) {
      hcpRow.push(h('td',{},[
        h('input',{
          type:'tel',inputmode:'numeric',value:State.data.course.hcp[i],
          style:'width:56px;text-align:center;',
          onfocus:()=>State.begin(),
          oninput:(e)=>{e.target.value=Utils.sanitize(e.target.value);},
          onblur:(e)=>{
            const v = Math.min(18, Math.max(1, parseInt(e.target.value)||1));
            State.data.course.hcp[i] = v;
            e.target.value = String(v);
            State.end();
          }
        })
      ]));
    }

    const courseCard = h('div',{class:'card'},[
      h('div',{class:'pill'},'Course Handicap'),
      h('div',{style:'margin-top:8px;'},presetSel),
      h('div',{class:'note',style:'margin-top:6px;'},`Loaded: ${State.data.course.name}`),
      h('div',{class:'card scroll',style:'margin-top:8px;'},
        h('table',{},[
          h('thead',{},[h('tr',{},hcpHead)]),
          h('tbody',{},[h('tr',{},parRow),h('tr',{},hcpRow)])
        ])
      ),
      h('button',{class:'btn small',style:'margin-top:8px;',onclick:()=>{
        const nm = prompt('Name this preset:');
        if (!nm) return;
        State.presets[nm] = {hcp:[...State.data.course.hcp], par:[...State.data.course.par]};
        State.data.course.name = nm;
        State.scheduleSave();
        State.scheduleRender();
        Err.toast('Preset saved');
      }},'Save as New Preset')
    ]);

    // Games
    const gamesHeader = h('div',{class:'row',style:'align-items:center;justify-content:space-between;'},[
      h('div',{class:'pill'},'Games'),
      h('button',{class:'btn small',onclick:()=>{
        const ng = Game.create(true);
        State.data.games.push(ng);
        State.scheduleSave();
        State.scheduleRender();
      }},'Add Game')
    ]);

    const gameCards = State.data.games.map((g,idx) => {
      const theme = `theme-g${(idx%6)+1}`;
      
      const teamBtns = (key) => {
        const team = key==='A'?g.teamA:g.teamB;
        const btns = State.data.players.map(p => {
          const on = team.indexOf(p.id)>=0;
          const full = !on && team.length >= g.teamSize;
          return h('button',{
            class:`btn small ${on?'primary':''}`,
            disabled:full,
            onclick:()=>{
              const i = team.indexOf(p.id);
              if (i>=0) team.splice(i,1);
              else if (team.length < g.teamSize) team.push(p.id);
              State.scheduleSave();
              State.scheduleRender();
            }
          },p.name);
        });
        return h('div',{class:'row'},btns);
      };


      const gameTypeSelector = () => h('div',{style:'margin:12px 0;'},[
        h('div',{class:'muted'},'Game Type'),
        h('div',{class:'row',style:'margin-top:6px;flex-wrap:wrap;gap:8px;'},[
          h('label',{class:'nowrap'},[
            h('input',{type:'radio',name:`type_${g.id}`,checked:g.gameType==='nassau',
              onchange:()=>{g.gameType='nassau';State.scheduleSave();State.scheduleRender();}}),
            ' Nassau'
          ]),
          h('label',{class:'nowrap'},[
            h('input',{type:'radio',name:`type_${g.id}`,checked:g.gameType==='vegas',
              onchange:()=>{
                g.gameType='vegas';
                g.teamA=g.teamA.slice(0,2);
                g.teamB=g.teamB.slice(0,2);
                State.scheduleSave();
                State.scheduleRender();
              }}),
            ' Vegas'
          ]),
          h('label',{class:'nowrap'},[
            h('input',{type:'radio',name:`type_${g.id}`,checked:g.gameType==='skins',
              onchange:()=>{g.gameType='skins';State.scheduleSave();State.scheduleRender();}}),
            ' Skins'
          ]),
          h('label',{class:'nowrap'},[
            h('input',{type:'radio',name:`type_${g.id}`,checked:g.gameType==='wolf',
              onchange:()=>{g.gameType='wolf';State.scheduleSave();State.scheduleRender();}}),
            ' Wolf'
          ]),
          h('label',{class:'nowrap'},[
            h('input',{type:'radio',name:`type_${g.id}`,checked:g.gameType==='ninepoint',
              onchange:()=>{g.gameType='ninepoint';State.scheduleSave();State.scheduleRender();}}),
            ' 9-Point'
          ])
        ])
      ]);

      const strokesEditor = () => {
        const playerRow = (ids) => {
          const grid = h('div',{style:'display:grid;gap:12px;grid-template-columns:repeat(auto-fit,minmax(96px,1fr));'});
          ids.forEach(pid => {
            grid.appendChild(h('div',{style:'display:flex;flex-direction:column;gap:6px;'},[
              h('div',{class:'muted',style:'text-align:center;font-size:12px;'},this.playerName(pid)),
              h('input',{
                type:'tel',inputmode:'numeric',value:g.strokesCount[pid]||0,
                style:'width:100%;text-align:center;padding:8px 10px;',
                onfocus:()=>State.begin(),
                oninput:(e)=>{e.target.value=Utils.sanitize(e.target.value);},
                onblur:(e)=>{
                  g.strokesCount[pid]=parseInt(e.target.value)||0;
                  e.target.value=String(g.strokesCount[pid]);
                  State.end();
                }
              })
            ]));
          });
          return grid;
        };
        const teamRow = (lbl, ids) => {
          return h('div',{},[h('div',{class:'muted',style:'margin:6px 0 8px;'},lbl),playerRow(ids)]);
        };
        const body = [];
        // Wolf, Skins, and 9-Point use player lists, not teams
        if (g.gameType === 'wolf') {
          const wolfPlayers = g.wolfPlayers || [];
          if (wolfPlayers.length) {
            body.push(playerRow(wolfPlayers));
            body.push(h('div',{class:'note'},'Strokes apply on HCP 1‚Ä¶n'));
          } else {
            body.push(h('div',{class:'note'},'Select players above to edit strokes'));
          }
        } else if (g.gameType === 'skins') {
          const skinsPlayers = g.skinsPlayers || [];
          if (skinsPlayers.length) {
            body.push(playerRow(skinsPlayers));
            body.push(h('div',{class:'note'},'Strokes apply on HCP 1‚Ä¶n'));
          } else {
            body.push(h('div',{class:'note'},'Select players above to edit strokes'));
          }
        } else if (g.gameType === 'ninepoint') {
          const ninePointPlayers = g.ninePointPlayers || [];
          if (ninePointPlayers.length) {
            body.push(playerRow(ninePointPlayers));
            body.push(h('div',{class:'note'},'Strokes apply on HCP 1‚Ä¶n'));
          } else {
            body.push(h('div',{class:'note'},'Select players above to edit strokes'));
          }
        } else {
          // Nassau/Vegas use teams
          if (g.teamA.length) body.push(teamRow('Team A:',g.teamA));
          if (g.teamB.length) body.push(teamRow('Team B:',g.teamB));
          if (!g.teamA.length && !g.teamB.length) body.push(h('div',{class:'note'},'Pick players to edit strokes'));
          else body.push(h('div',{class:'note'},'Strokes apply on HCP 1‚Ä¶n'));
        }
        return h('div',{class:'card'},[h('div',{class:'pill'},'Strokes'),h('div',{},body)]);
      };

      return h('div',{class:theme},[
        h('div',{class:'card'},[
          h('div',{class:'row',style:'align-items:center;justify-content:space-between;'},[
            h('div',{class:'pill'},this.gameLabel(g)),
            h('div',{},[
              h('button',{class:'btn small',onclick:()=>{
                State.data.tab='scores';
                State.scheduleRender();
              }},'Go to SCORES'),
              h('button',{class:'btn small',style:'margin-left:6px;',onclick:()=>{
                const i = State.data.games.indexOf(g);
                if (i>=0) State.data.games.splice(i,1);
                if (!State.data.games.length) State.data.games.push(Game.create());
                State.scheduleSave();
                State.scheduleRender();
              }},'Delete')
            ])
          ]),
          
          gameTypeSelector(),
          
          g.gameType === 'nassau' ? h('div',{},[h('div',{class:'game-options-row',style:'margin:6px 0;'},[
            h('div',{},[
              h('div',{class:'muted nowrap'},'Nassau Scoring'),
              h('label',{class:'nowrap',style:'display:block;margin-top:6px;'},[
                h('input',{type:'radio',name:`mode_${g.id}`,checked:g.scoringMode==='hi_low',
                  onchange:()=>{g.scoringMode='hi_low';State.scheduleSave();State.scheduleRender();}}),
                ' Hi/Low'
              ]),
              h('label',{class:'nowrap',style:'display:block;margin-top:6px;'},[
                h('input',{type:'radio',name:`mode_${g.id}`,checked:g.scoringMode==='low_net',
                  onchange:()=>{g.scoringMode='low_net';State.scheduleSave();State.scheduleRender();}}),
                ' Best Ball'
              ])
            ]),
            h('div',{},[
              h('div',{class:'muted nowrap'},'Team Size'),
              h('label',{class:'nowrap',style:'display:block;margin-top:6px;'},[
                h('input',{type:'radio',name:`ts_${g.id}`,checked:g.teamSize===2,
                  onchange:()=>{g.teamSize=2;State.scheduleSave();State.scheduleRender();}}),
                ' 2v2'
              ]),
              h('label',{class:'nowrap',style:'display:block;margin-top:6px;'},[
                h('input',{type:'radio',name:`ts_${g.id}`,checked:g.teamSize===1,
                  onchange:()=>{g.teamSize=1;g.teamA=g.teamA.slice(0,1);g.teamB=g.teamB.slice(0,1);State.scheduleSave();State.scheduleRender();}}),
                ' 1v1'
              ])
            ])
          ]),
          g.scoringMode==='hi_low' && g.teamSize===1 ? h('div',{class:'note',style:'margin-top:4px;'},'Hi/Low needs 2v2. Using Best Ball until teams full.') : h('div',{}),
          h('div',{class:'grid grid-2'},[
            h('div',{},[h('div',{class:'muted'},`Team A (pick ${g.teamSize})`),teamBtns('A')]),
            h('div',{},[h('div',{class:'muted'},`Team B (pick ${g.teamSize})`),teamBtns('B')])
          ]),
          h('div',{class:'grid grid-3'},[
            h('div',{},[h('div',{class:'muted'},'Front $'),h('input',{type:'tel',inputmode:'numeric',value:g.stakes.front,onfocus:()=>State.begin(),oninput:(e)=>{e.target.value=Utils.sanitize(e.target.value);},onblur:(e)=>{g.stakes.front=parseInt(e.target.value)||0;e.target.value=String(g.stakes.front);State.end();}})]),
            h('div',{},[h('div',{class:'muted'},'Back $'),h('input',{type:'tel',inputmode:'numeric',value:g.stakes.back,onfocus:()=>State.begin(),oninput:(e)=>{e.target.value=Utils.sanitize(e.target.value);},onblur:(e)=>{g.stakes.back=parseInt(e.target.value)||0;e.target.value=String(g.stakes.back);State.end();}})]),
            h('div',{},[h('div',{class:'muted'},'Overall $'),h('input',{type:'tel',inputmode:'numeric',value:g.stakes.overall,onfocus:()=>State.begin(),oninput:(e)=>{e.target.value=Utils.sanitize(e.target.value);},onblur:(e)=>{g.stakes.overall=parseInt(e.target.value)||0;e.target.value=String(g.stakes.overall);State.end();}})]),
          ]),
          h('div',{class:'grid grid-3'},[
            h('label',{},[h('input',{type:'checkbox',checked:g.autoPress.front,onclick:(e)=>{g.autoPress.front=e.target.checked;State.scheduleSave();State.scheduleRender();}}),' Auto-Press 2DN']),
            h('label',{},[h('input',{type:'checkbox',checked:g.autoPress.back,onclick:(e)=>{g.autoPress.back=e.target.checked;State.scheduleSave();State.scheduleRender();}}),' Auto-Press 2DN']),
            h('label',{},[h('input',{type:'checkbox',checked:g.autoPress.overall,onclick:(e)=>{g.autoPress.overall=e.target.checked;State.scheduleSave();State.scheduleRender();}}),' Auto-Press 2DN'])
          ]),
          h('div',{class:'row',style:'align-items:center;gap:12px;margin:8px 0;'},[
            h('div',{class:'pill'},'Junk $/point'),
            h('div',{},[h('div',{class:'muted'},'Front'),h('input',{type:'tel',inputmode:'numeric',value:g.junkValue.front,style:'width:64px;text-align:center;',onfocus:()=>State.begin(),oninput:(e)=>{e.target.value=Utils.sanitize(e.target.value);},onblur:(e)=>{g.junkValue.front=parseInt(e.target.value)||0;e.target.value=String(g.junkValue.front);State.end();}})]),
            h('div',{},[h('div',{class:'muted'},'Back'),h('input',{type:'tel',inputmode:'numeric',value:g.junkValue.back,style:'width:64px;text-align:center;',onfocus:()=>State.begin(),oninput:(e)=>{e.target.value=Utils.sanitize(e.target.value);},onblur:(e)=>{g.junkValue.back=parseInt(e.target.value)||0;e.target.value=String(g.junkValue.back);State.end();}})]),
          ]),
]) : h('div',{}),

          g.gameType === 'vegas' ? h('div',{},[
            h('div',{class:'grid grid-2'},[
              h('div',{},[h('div',{class:'muted'},'Team A (pick 2)'),teamBtns('A')]),
              h('div',{},[h('div',{class:'muted'},'Team B (pick 2)'),teamBtns('B')])
            ]),
            h('div',{class:'grid grid-2',style:'margin-top:12px;'},[
              h('div',{},[h('div',{class:'muted'},'Front $/pt'),h('input',{type:'number',step:'0.25',value:g.pointValue.front,onfocus:()=>State.begin(),onblur:(e)=>{g.pointValue.front=parseFloat(e.target.value)||1;State.end();}})]),
              h('div',{},[h('div',{class:'muted'},'Back $/pt'),h('input',{type:'number',step:'0.25',value:g.pointValue.back,onfocus:()=>State.begin(),onblur:(e)=>{g.pointValue.back=parseFloat(e.target.value)||1;State.end();}})]),
            ]),
            h('div',{class:'row',style:'align-items:center;gap:12px;margin:8px 0;'},[
              h('div',{class:'pill'},'Junk $/point'),
              h('div',{},[h('div',{class:'muted'},'Front'),h('input',{type:'tel',inputmode:'numeric',value:g.junkValue.front,style:'width:64px;text-align:center;',onfocus:()=>State.begin(),oninput:(e)=>{e.target.value=Utils.sanitize(e.target.value);},onblur:(e)=>{g.junkValue.front=parseInt(e.target.value)||0;e.target.value=String(g.junkValue.front);State.end();}})]),
              h('div',{},[h('div',{class:'muted'},'Back'),h('input',{type:'tel',inputmode:'numeric',value:g.junkValue.back,style:'width:64px;text-align:center;',onfocus:()=>State.begin(),oninput:(e)=>{e.target.value=Utils.sanitize(e.target.value);},onblur:(e)=>{g.junkValue.back=parseInt(e.target.value)||0;e.target.value=String(g.junkValue.back);State.end();}})]),
            ]),
            h('div',{class:'note',style:'margin-top:8px;'},'Flip if: opponent birdie, OR no one on your team has net par or better')
          ]) : h('div',{}),

          g.gameType === 'skins' ? h('div',{},[
            h('div',{style:'margin:8px 0;'},[
              h('div',{class:'muted'},'Players (tap to toggle)'),
              h('div',{class:'row',style:'flex-wrap:wrap;gap:6px;margin-top:6px;'},
                State.data.players.map(p => {
                  const inGame = (g.skinsPlayers || []).includes(p.id);
                  return h('button',{
                    class:`btn small ${inGame?'primary':''}`,
                    onclick:(e)=>{
                      g.skinsPlayers = g.skinsPlayers || [];
                      if (inGame) {
                        g.skinsPlayers = g.skinsPlayers.filter(x => x !== p.id);
                        e.target.classList.remove('primary');
                      } else if (g.skinsPlayers.length < 5) {
                        g.skinsPlayers.push(p.id);
                        e.target.classList.add('primary');
                      }
                      State.scheduleSave();
                    }
                  },p.name);
                })
              )
            ]),
            h('div',{style:'margin:8px 0;'},[
              h('div',{class:'muted'},'Mode'),
              h('div',{class:'row',style:'gap:12px;margin-top:6px;'},[
                h('label',{},[h('input',{type:'radio',name:`smode_${g.id}`,checked:g.skinsMode==='net',onchange:()=>{g.skinsMode='net';State.scheduleSave();State.scheduleRender();}}),' Net']),
                h('label',{},[h('input',{type:'radio',name:`smode_${g.id}`,checked:g.skinsMode==='gross',onchange:()=>{g.skinsMode='gross';State.scheduleSave();State.scheduleRender();}}),' Gross']),
                h('label',{},[h('input',{type:'radio',name:`smode_${g.id}`,checked:g.skinsMode==='both',onchange:()=>{g.skinsMode='both';State.scheduleSave();State.scheduleRender();}}),' Both'])
              ])
            ]),
            h('div',{style:'margin:8px 0;'},[
              h('div',{class:'muted'},'Buy-in $'),
              h('input',{type:'number',value:g.stakes.front||20,style:'width:80px;',onfocus:()=>State.begin(),onblur:(e)=>{g.stakes.front=parseFloat(e.target.value)||20;State.end();}}),
              h('span',{class:'muted',style:'margin-left:8px;'},`Pot: $${((g.stakes.front||20) * (g.skinsPlayers||[]).length).toFixed(0)}`)
            ])
          ]) : h('div',{}),

          g.gameType === 'wolf' ? h('div',{},[
            h('div',{style:'margin:8px 0;'},[
              h('div',{class:'muted'},'Players (tap to toggle, 4-5)'),
              h('div',{class:'row',style:'flex-wrap:wrap;gap:6px;margin-top:6px;'},
                State.data.players.map(p => {
                  const inGame = (g.wolfPlayers || []).includes(p.id);
                  return h('button',{
                    class:`btn small ${inGame?'primary':''}`,
                    onclick:()=>{
                      g.wolfPlayers = g.wolfPlayers || [];
                      g.wolfTeeOrder = g.wolfTeeOrder || [];
                      if (inGame) {
                        g.wolfPlayers = g.wolfPlayers.filter(x => x !== p.id);
                        g.wolfTeeOrder = g.wolfTeeOrder.filter(x => x !== p.id);
                      } else if (g.wolfPlayers.length < 5) {
                        g.wolfPlayers.push(p.id);
                        if (!g.wolfTeeOrder.includes(p.id)) g.wolfTeeOrder.push(p.id);
                      }
                      State.scheduleSave();
                      State.scheduleRender();
                    }
                  },p.name);
                })
              )
            ]),
            h('div',{style:'margin:8px 0;'},[
              h('div',{class:'muted'},'Point Value $'),
              h('input',{type:'number',step:'0.25',value:g.wolfPointValue||1,style:'width:80px;',onfocus:()=>State.begin(),onblur:(e)=>{g.wolfPointValue=parseFloat(e.target.value)||1;State.end();}})
            ]),
            h('div',{class:'row',style:'align-items:center;gap:12px;margin:8px 0;'},[
              h('div',{class:'pill'},'Junk $/point'),
              h('div',{},[h('div',{class:'muted'},'Front'),h('input',{type:'tel',inputmode:'numeric',value:g.junkValue.front,style:'width:64px;text-align:center;',onfocus:()=>State.begin(),oninput:(e)=>{e.target.value=Utils.sanitize(e.target.value);},onblur:(e)=>{g.junkValue.front=parseInt(e.target.value)||0;e.target.value=String(g.junkValue.front);State.end();}})]),
              h('div',{},[h('div',{class:'muted'},'Back'),h('input',{type:'tel',inputmode:'numeric',value:g.junkValue.back,style:'width:64px;text-align:center;',onfocus:()=>State.begin(),oninput:(e)=>{e.target.value=Utils.sanitize(e.target.value);},onblur:(e)=>{g.junkValue.back=parseInt(e.target.value)||0;e.target.value=String(g.junkValue.back);State.end();}})]),
            ]),
            h('div',{class:'note',style:'margin-top:8px;'},'Wolf=2x, Blind Wolf=4x. Catch-up: 17-18 (4P) or 16-18 (5P).')
          ]) : h('div',{}),

          g.gameType === 'ninepoint' ? h('div',{},[
            h('div',{style:'margin:8px 0;'},[
              h('div',{class:'muted'},'Players (exactly 3)'),
              h('div',{class:'row',style:'flex-wrap:wrap;gap:6px;margin-top:6px;'},
                State.data.players.map(p => {
                  const inGame = (g.ninePointPlayers || []).includes(p.id);
                  return h('button',{
                    class:`btn small ${inGame?'primary':''}`,
                    onclick:()=>{
                      g.ninePointPlayers = g.ninePointPlayers || [];
                      if (inGame) {
                        g.ninePointPlayers = g.ninePointPlayers.filter(x => x !== p.id);
                      } else if (g.ninePointPlayers.length < 3) {
                        g.ninePointPlayers.push(p.id);
                      }
                      State.scheduleSave();
                      State.scheduleRender();
                    }
                  },p.name);
                })
              )
            ]),
            h('div',{style:'margin:8px 0;'},[
              h('div',{class:'muted'},'Mode'),
              h('div',{class:'row',style:'gap:12px;margin-top:6px;'},[
                h('label',{},[h('input',{type:'radio',name:`npmode_${g.id}`,checked:g.ninePointMode==='net',onchange:()=>{g.ninePointMode='net';State.scheduleSave();State.scheduleRender();}}),' Net']),
                h('label',{},[h('input',{type:'radio',name:`npmode_${g.id}`,checked:g.ninePointMode==='gross',onchange:()=>{g.ninePointMode='gross';State.scheduleSave();State.scheduleRender();}}),' Gross'])
              ])
            ]),
            h('div',{style:'margin:8px 0;'},[
              h('div',{class:'muted'},'Optional Rules'),
              h('div',{style:'margin-top:6px;'},[
                h('label',{style:'display:block;margin-bottom:4px;'},[h('input',{type:'checkbox',checked:g.ninePointWinBy2!==false,onclick:(e)=>{g.ninePointWinBy2=e.target.checked;State.scheduleSave();}}),' Win by 2 (9/0/0)']),
                h('label',{style:'display:block;'},[h('input',{type:'checkbox',checked:g.ninePointBirdieDouble===true,onclick:(e)=>{g.ninePointBirdieDouble=e.target.checked;State.scheduleSave();}}),' Birdie Doubles'])
              ])
            ]),
            h('div',{style:'margin:8px 0;'},[
              h('div',{class:'muted'},'Point Value $'),
              h('input',{type:'number',step:'0.25',value:g.ninePointValue||1,style:'width:80px;',onfocus:()=>State.begin(),onblur:(e)=>{g.ninePointValue=parseFloat(e.target.value)||1;State.end();}})
            ]),
            h('div',{class:'row',style:'align-items:center;gap:12px;margin:8px 0;'},[
              h('div',{class:'pill'},'Junk $/point'),
              h('div',{},[h('div',{class:'muted'},'Front'),h('input',{type:'tel',inputmode:'numeric',value:g.junkValue.front,style:'width:64px;text-align:center;',onfocus:()=>State.begin(),oninput:(e)=>{e.target.value=Utils.sanitize(e.target.value);},onblur:(e)=>{g.junkValue.front=parseInt(e.target.value)||0;e.target.value=String(g.junkValue.front);State.end();}})]),
              h('div',{},[h('div',{class:'muted'},'Back'),h('input',{type:'tel',inputmode:'numeric',value:g.junkValue.back,style:'width:64px;text-align:center;',onfocus:()=>State.begin(),oninput:(e)=>{e.target.value=Utils.sanitize(e.target.value);},onblur:(e)=>{g.junkValue.back=parseInt(e.target.value)||0;e.target.value=String(g.junkValue.back);State.end();}})]),
            ]),
            h('div',{class:'note',style:'margin-top:8px;'},'5/3/1 distribution. Win by 2=9/0/0, with birdie=18/0/0.')
          ]) : h('div',{}),

          strokesEditor(),
          h('div',{class:'note'},'Scores tab shows GROSS. Net is auto from strokes + course HCP.')
        ])
      ]);
    });

    return h('div',{},[
      h('div',{class:'card'},[h('div',{class:'pill'},'Players'),h('div',{},playerInputs)]),
      courseCard,
      h('div',{},[gamesHeader,...gameCards])
    ]);
  },

  scores() {
    const g = State.data.games[0];
    if (!g) return h('div',{class:'card'},'No game. Add one in Setup.');

    const last = Game.getLastScored();
    const updateSums = (pid) => {
      const arr = g.gross[pid];
      const f = Utils.sumRange(arr,0,8);
      const b = Utils.sumRange(arr,9,17);
      const t = (f==null && b==null)?null:((f||0)+(b||0));
      const fEl = document.getElementById(`sumF_${pid}`);
      const bEl = document.getElementById(`sumB_${pid}`);
      const tEl = document.getElementById(`sumT_${pid}`);
      if (fEl) fEl.textContent = f==null?'':String(f);
      if (bEl) bEl.textContent = b==null?'':String(b);
      if (tEl) tEl.textContent = t==null?'':String(t);
    };

    const createDots = (pid, hole) => {
      const dots = [];
      for (let gi = 0; gi < Math.min(6, State.data.games.length); gi++) {
        const gm = State.data.games[gi];
        const inA = (gm.teamA||[]).indexOf(pid)>=0;
        const inB = (gm.teamB||[]).indexOf(pid)>=0;
        if (!inA && !inB) continue;
        const s = Game.strokes(gm, pid, hole);
        if (s > 0) dots.push(h('span',{class:`dot g${gi+1}`}));
      }
      return dots.length ? h('span',{class:'dots'},dots) : null;
    };

    const head = [h('th',{class:'sticky'},'Hole')];
    for (let i = 0; i < 18; i++) head.push(h('th',{id:`col_h_${i}`},String(i+1)));
    head.push(h('th',{},'F'),h('th',{},'B'),h('th',{},'TOT'));

    const parRow = [h('th',{class:'sticky'},'Par')];
    for (let i = 0; i < 18; i++) parRow.push(h('th',{},String(State.data.course.par[i]||'')));
    parRow.push(h('th',{}),h('th',{}),h('th',{}));

    // Get score indicator class based on gross score vs par
    const getScoreClass = (score, par) => {
      if (score == null) return '';
      const diff = score - par;
      if (diff <= -2) return 'eagle';
      if (diff === -1) return 'birdie';
      if (diff === 0) return '';
      if (diff === 1) return 'bogey';
      return 'double-bogey';
    };

    const rows = State.data.players.map((p, ri) => {
      // Ensure gross array exists for this player
      if (!g.gross[p.id]) g.gross[p.id] = Utils.make18(null);
      const cells = [h('td',{class:'sticky'},p.name)];
      for (let hole = 0; hole < 18; hole++) {
        const tabIdx = (hole * State.data.players.length) + ri + 1;
        const score = g.gross[p.id][hole];
        const par = State.data.course.par[hole] || 4;
        const scoreClass = getScoreClass(score, par);
        cells.push(h('td',{},[
          h('div',{class:'cellWrap' + (scoreClass ? ' ' + scoreClass : '')},[
            h('input',{
              type:'tel',inputmode:'numeric',tabindex:tabIdx,
              value:score==null?'':String(score),
              style:'width:54px;text-align:center;',
              placeholder:'-',
              onfocus:()=>State.begin(),
              oninput:(e)=>{
                e.target.value = Utils.sanitize(e.target.value);
                const v = e.target.value===''?null:parseInt(e.target.value);
                State.data.games.forEach(gm => { if (gm.gross[p.id]) gm.gross[p.id][hole] = v; });
                // Update score indicator immediately
                const wrap = e.target.closest('.cellWrap');
                wrap.classList.remove('eagle','birdie','bogey','double-bogey');
                const cls = getScoreClass(v, par);
                if (cls) wrap.classList.add(cls);
                // Check if all players have scores for this hole - if so, update status bars
                const allHaveScore = State.data.players.every(pl => {
                  const s = g.gross[pl.id] && g.gross[pl.id][hole];
                  return s != null;
                });
                if (allHaveScore) {
                  updateStatusBars();
                }
              },
              onkeydown:(e)=>{
                if (e.key==='Enter') {
                  e.preventDefault();
                  let next = tabIdx + 1;
                  const maxCol = (hole+1)*State.data.players.length;
                  if (next > maxCol) {
                    if (hole+1 < 18) next = (hole+1)*State.data.players.length - (State.data.players.length-1);
                    else next = tabIdx;
                  }
                  const nextEl = document.querySelector(`input[tabindex="${next}"]`);
                  if (nextEl) nextEl.focus();
                }
              },
              onblur:(e)=>{
                const v = e.target.value===''?null:parseInt(e.target.value);
                if (v!==null && (v<MIN_SCORE || v>MAX_SCORE)) {
                  Err.show(`Invalid score ${v}. Use ${MIN_SCORE}-${MAX_SCORE}`);
                  e.target.value = '';
                  State.data.games.forEach(gm => { if (gm.gross[p.id]) gm.gross[p.id][hole] = null; });
                } else {
                  State.data.games.forEach(gm => { if (gm.gross[p.id]) gm.gross[p.id][hole] = v; });
                  e.target.value = v==null?'':String(v);
                }
                updateSums(p.id);
                State.end();
              }
            }),
            h('div',{class:'score-indicator'}),
            createDots(p.id, hole) || ''
          ])
        ]));
      }
      const arr = g.gross[p.id];
      const f = Utils.sumRange(arr,0,8);
      const b = Utils.sumRange(arr,9,17);
      const t = (f==null && b==null)?null:((f||0)+(b||0));
      cells.push(
        h('td',{id:`sumF_${p.id}`},f==null?'':String(f)),
        h('td',{id:`sumB_${p.id}`},b==null?'':String(b)),
        h('td',{id:`sumT_${p.id}`},t==null?'':String(t))
      );
      return h('tr',{},cells);
    });


    // Build Vegas press rows
    const vegasRows = State.data.games.filter(g => g.gameType === 'vegas').map((game,gi) => {
      const actualIdx = State.data.games.indexOf(game);
      const theme = `theme-g${(actualIdx%6)+1}`;
      const cells = [h('td',{class:'sticky press-label',style:'font-weight:600;'},UI.gameLabel(game))];
      for (let hole = 0; hole < 18; hole++) {
        const currentPress = game.presses[hole] || '';
        const sel = h('select',{
          class:'press-select',
          onchange:(e)=>{
            game.presses[hole] = e.target.value;
            State.scheduleSave();
            State.scheduleRender();
          }
        },[
          h('option',{value:'',selected:currentPress===''},'‚Äî'),
          h('option',{value:'press',selected:currentPress==='press'},'P'),
          h('option',{value:'blind',selected:currentPress==='blind'},'B')
        ]);
        cells.push(h('td',{},[sel]));
      }
      cells.push(h('td',{colspan:'3'}));
      return h('tr',{class:`press-row ${theme}`},cells);
    });

    // Build Wolf selection rows
    const wolfRows = State.data.games.filter(g => g.gameType === 'wolf').flatMap((game,gi) => {
      const actualIdx = State.data.games.indexOf(game);
      const theme = `theme-g${(actualIdx%6)+1}`;
      const wolfPlayers = game.wolfPlayers || [];
      // Skip if no wolf players configured
      if (wolfPlayers.length < 4) {
        const cells = [h('td',{class:'sticky press-label',style:'font-weight:600;'},UI.gameLabel(game))];
        for (let hole = 0; hole < 18; hole++) {
          cells.push(h('td',{class:'muted',style:'font-size:10px;'},'-'));
        }
        cells.push(h('td',{colspan:'3'}));
        return [h('tr',{class:`press-row ${theme}`},cells)];
      }
      // Compute wolf result to get actual wolf for each hole (includes catch-up logic)
      const wolfResult = Game.computeWolfResult(game);

      // Determine catch-up start hole: 4 players = hole 17 (index 16), 5 players = hole 16 (index 15)
      const catchUpStart = wolfPlayers.length === 4 ? 16 : 15;

      // Row 1: Wolf name for each hole
      const wolfNameCells = [h('td',{class:'sticky press-label',style:'font-weight:600;font-size:11px;'},'Wolf')];
      for (let hole = 0; hole < 18; hole++) {
        const detail = wolfResult.holeDetails[hole] || {};
        const isCatchUp = hole >= catchUpStart;
        // For catch-up holes, show TBD unless we can determine from current standings
        let displayName;
        if (isCatchUp) {
          // Check if all prior holes have selections made - if so, wolf is determined
          const allPriorSelected = Array.from({length: hole}, (_, h) => game.wolfSelections[h]).every(s => s);
          if (allPriorSelected && detail.wolf) {
            const name = UI.playerName(detail.wolf) || '?';
            displayName = name.length <= 3 ? name : name.slice(0,2);
          } else {
            displayName = 'TBD';
          }
        } else {
          const wolfPid = detail.wolf || wolfPlayers[hole % wolfPlayers.length];
          const name = UI.playerName(wolfPid) || '?';
          displayName = name.length <= 3 ? name : name.slice(0,2);
        }
        wolfNameCells.push(h('td',{style:'font-size:11px;text-align:center;' + (isCatchUp ? 'color:#ca8a04;' : '')},displayName));
      }
      wolfNameCells.push(h('td',{colspan:'3'}));
      const wolfNameRow = h('tr',{class:`press-row ${theme}`},wolfNameCells);

      // Row 2: Partner selection dropdown
      const pickCells = [h('td',{class:'sticky press-label',style:'font-weight:600;font-size:11px;'},'Pick')];
      for (let hole = 0; hole < 18; hole++) {
        const detail = wolfResult.holeDetails[hole] || {};
        const isCatchUp = hole >= catchUpStart;
        const wolfPid = detail.wolf || wolfPlayers[hole % wolfPlayers.length];
        const currentSel = game.wolfSelections[hole] || '';
        // Options: player names (except wolf), Wolf, Blind Wolf
        const otherPlayers = wolfPlayers.filter(p => p !== wolfPid);
        const options = [
          h('option',{value:'',selected:currentSel===''},'?'),
          ...otherPlayers.map(pid => {
            const name = UI.playerName(pid) || '?';
            const abbr = name.length <= 3 ? name : name.slice(0,2);
            return h('option',{value:pid,selected:currentSel===pid},abbr);
          }),
          h('option',{value:'wolf',selected:currentSel==='wolf'},'W'),
          h('option',{value:'blind',selected:currentSel==='blind'},'BW')
        ];
        const sel = h('select',{
          class:'press-select',
          style:'font-size:12px;',
          onchange:(e)=>{
            game.wolfSelections[hole] = e.target.value;
            State.scheduleSave();
            State.scheduleRender();
          }
        },options);
        pickCells.push(h('td',{},[sel]));
      }
      pickCells.push(h('td',{colspan:'3'}));
      const pickRow = h('tr',{class:`press-row ${theme}`},pickCells);

      return [wolfNameRow, pickRow];
    });

    const tbl = h('table',{},[
      h('thead',{},[h('tr',{},head),h('tr',{},parRow)]),
      h('tbody',{},[...rows,...vegasRows,...wolfRows])
    ]);

    const scroller = h('div',{class:'card scroll',id:'scoresScroll'},tbl);

    setTimeout(()=>{
      try {
        if (last>=0) {
          const col = document.getElementById(`col_h_${last}`);
          const sc = document.getElementById('scoresScroll');
          if (col && sc) {
            const tgt = Math.max(0, col.offsetLeft - sc.clientWidth*0.2);
            sc.scrollLeft = tgt;
          }
        }
      } catch(e) {}
    },0);

    // Function to build status bars - called on render and on score updates
    const buildGameStatusRows = () => State.data.games.map((game, idx) => {
      const theme = `theme-g${(idx%6)+1}`;

      // Check if ANY scores have been entered
      const hasAnyScore = State.data.players.some(p => {
        const arr = game.gross[p.id] || [];
        return arr.some(score => score != null);
      });

      // Check if back 9 has any scores (hole 10+)
      const hasBack9Score = State.data.players.some(p => {
        const arr = game.gross[p.id] || [];
        return arr.slice(9).some(score => score != null);
      });

      if (!hasAnyScore) {
        return h('div',{class:theme,style:'margin-bottom:6px;'},[
          h('div',{class:'card',style:'padding:8px 12px;'},[
            h('div',{class:'row',style:'align-items:center;justify-content:space-between;gap:12px;'},[
              h('div',{class:'pill',style:'font-size:12px;'},UI.gameLabel(game)),
              h('div',{class:'muted',style:'font-size:14px;'},'No scores yet')
            ])
          ])
        ]);
      }

      let frontLine, backLine;
      const fmtPts = (pts) => pts > 0 ? `+${pts}` : pts === 0 ? 'E' : String(pts);

      // Get junk breakdown for front/back if junk is enabled
      const junk = game.withJunk ? Game.computeJunk(game) : null;

      // Junk per-player = delta pts √ó junk value (simple flat amount per player)
      const frontJunkVal = junk ? junk.frontNetVal : 0;
      const backJunkVal = junk ? junk.backNetVal : 0;

      if (game.gameType === 'skins') {
        const result = Game.computeSkinsResult(game);
        const mode = game.skinsMode || 'net';
        const players = game.skinsPlayers || [];

        // Build player skin counts (e.g., "Tom:1 Dick:0 Harry:2")
        const playerCounts = players.map(pid => {
          const name = UI.playerName(pid);
          const abbr = name.length <= 4 ? name : name.slice(0,3);
          const skins = mode === 'gross' ? result.grossSkins[pid] :
                        mode === 'net' ? result.netSkins[pid] :
                        (result.grossSkins[pid] + result.netSkins[pid]);
          return `${abbr}:${skins || 0}`;
        }).join(' ');

        const carry = mode === 'gross' ? result.grossCarry :
                      mode === 'net' ? result.netCarry :
                      (result.grossCarry + result.netCarry);

        frontLine = playerCounts + (carry > 0 ? ` | Carry:${carry}` : '');
        backLine = `Pot: ${Utils.fmt(result.totalPot)} | $/Skin: ${Utils.fmt(mode === 'gross' ? result.grossSkinValue : result.netSkinValue)}`;
      } else if (game.gameType === 'wolf') {
        const result = Game.computeWolfResult(game);
        const players = game.wolfPlayers || [];

        // Calculate junk pay-up-the-ladder for Wolf
        const sumWolfJunkPid = (pid, start, end) => {
          let tot = 0;
          const arr = game.junkCounts[pid] || [];
          for (let h = start; h <= end; h++) tot += (arr[h]||0);
          return tot;
        };
        const junkStandings = players.map(pid => {
          const frontJunk = sumWolfJunkPid(pid, 0, 8);
          const backJunk = sumWolfJunkPid(pid, 9, 17);
          const junkVal = frontJunk * (game.junkValue.front||0) + backJunk * (game.junkValue.back||0);
          return { pid, junkVal };
        }).sort((a, b) => b.junkVal - a.junkVal);
        const junkNet = {};
        players.forEach(pid => { junkNet[pid] = 0; });
        let totalJunkMoney = 0;
        for (let i = 0; i < junkStandings.length; i++) {
          for (let j = i + 1; j < junkStandings.length; j++) {
            const diff = junkStandings[i].junkVal - junkStandings[j].junkVal;
            if (diff > 0) {
              junkNet[junkStandings[i].pid] += diff;
              junkNet[junkStandings[j].pid] -= diff;
              totalJunkMoney += diff;
            }
          }
        }

        // Build player net $ standings (Wolf + junk pay-up-the-ladder)
        const playerAmts = players.map(pid => {
          const name = UI.playerName(pid);
          const abbr = name.length <= 3 ? name : name.slice(0,2);
          const wolfAmt = result.playerNet[pid] || 0;
          const junkAmt = junkNet[pid] || 0;
          return `${abbr}:${Utils.fmt(wolfAmt + junkAmt)}`;
        }).join(' ');

        frontLine = playerAmts + (result.carryover > 0 ? ` | Carry:${result.carryover}` : '');
        const junkPart = totalJunkMoney > 0 ? ` | Junk: ${Utils.fmt(totalJunkMoney)}` : '';
        backLine = `$${game.wolfPointValue}/pt | Total: ${Utils.fmt(result.totalMoney + totalJunkMoney)}${junkPart}`;
      } else if (game.gameType === 'ninepoint') {
        const result = Game.computeNinePointResult(game);
        const players = game.ninePointPlayers || [];

        // Calculate junk for 9-Point
        const sumNinePointJunkPid = (pid, start, end) => {
          let tot = 0;
          const arr = game.junkCounts[pid] || [];
          for (let h = start; h <= end; h++) tot += (arr[h]||0);
          return tot;
        };
        const junkStandings = players.map(pid => {
          const frontJunk = sumNinePointJunkPid(pid, 0, 8);
          const backJunk = sumNinePointJunkPid(pid, 9, 17);
          const junkVal = frontJunk * (game.junkValue.front||0) + backJunk * (game.junkValue.back||0);
          return { pid, junkVal };
        }).sort((a, b) => b.junkVal - a.junkVal);
        const junkNet = {};
        players.forEach(pid => { junkNet[pid] = 0; });
        let totalJunkMoney9 = 0;
        for (let i = 0; i < junkStandings.length; i++) {
          for (let j = i + 1; j < junkStandings.length; j++) {
            const diff = junkStandings[i].junkVal - junkStandings[j].junkVal;
            if (diff > 0) {
              junkNet[junkStandings[i].pid] += diff;
              junkNet[junkStandings[j].pid] -= diff;
              totalJunkMoney9 += diff;
            }
          }
        }

        const playerAmts = players.map(pid => {
          const name = UI.playerName(pid);
          const abbr = name.length <= 3 ? name : name.slice(0,2);
          const nineAmt = result.playerNet[pid] || 0;
          const junkAmt = junkNet[pid] || 0;
          return `${abbr}:${Utils.fmt(nineAmt + junkAmt)}`;
        }).join(' ');

        frontLine = playerAmts;
        backLine = `$${game.ninePointValue}/pt`;
      } else if (game.gameType === 'vegas') {
        const result = Game.computeVegasResult(game);
        // Per-player value = points √ó $/point (no team multiplier)
        const frontPerPlayer = result.frontPoints * (game.pointValue.front || 0);
        const backPerPlayer = result.backPoints * (game.pointValue.back || 0);
        const frontTotal = frontPerPlayer + frontJunkVal;
        const backTotal = backPerPlayer + backJunkVal;
        frontLine = junk
          ? `Front: ${fmtPts(result.frontPoints)} pts | Junk: ${fmtPts(junk.frontNetPts)} | Tot: ${Utils.fmt(frontTotal)}/ea`
          : `Front: ${fmtPts(result.frontPoints)} pts (${Utils.fmt(frontPerPlayer)}/ea)`;
        backLine = hasBack9Score ? (junk
          ? `Back: ${fmtPts(result.backPoints)} pts | Junk: ${fmtPts(junk.backNetPts)} | Tot: ${Utils.fmt(backTotal)}/ea`
          : `Back: ${fmtPts(result.backPoints)} pts (${Utils.fmt(backPerPlayer)}/ea)`) : null;
      } else {
        const result = Game.computeResult(game);
        const seg = result.segments;
        // Format Nassau status: show each bet line result (always from Team A perspective)
        const fmtSeg = (s) => s.winners.join('/');
        // Per-player value = just the stake, no team multiplier (payA not teamPayA)
        const frontPerPlayer = seg.front.payA;
        const backPerPlayer = seg.back.payA;
        const frontTotal = frontPerPlayer + frontJunkVal;
        const backTotal = backPerPlayer + backJunkVal;
        frontLine = junk
          ? `Front: ${fmtSeg(seg.front)} | Junk: ${fmtPts(junk.frontNetPts)} | Tot: ${Utils.fmt(frontTotal)}/ea`
          : `Front: ${fmtSeg(seg.front)} (${Utils.fmt(frontPerPlayer)}/ea)`;
        backLine = hasBack9Score ? (junk
          ? `Back: ${fmtSeg(seg.back)} | Junk: ${fmtPts(junk.backNetPts)} | Tot: ${Utils.fmt(backTotal)}/ea`
          : `Back: ${fmtSeg(seg.back)} (${Utils.fmt(backPerPlayer)}/ea)`) : null;
      }

      return h('div',{class:theme,style:'margin-bottom:6px;'},[
        h('div',{class:'card',style:'padding:8px 12px;'},[
          h('div',{class:'row',style:'align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap;'},[
            h('div',{class:'pill',style:'font-size:12px;'},UI.gameLabel(game)),
            h('div',{style:'text-align:right;font-size:13px;'},[
              h('div',{},frontLine),
              backLine ? h('div',{style:'margin-top:2px;'},backLine) : ''
            ])
          ])
        ])
      ]);
    });

    // Update status bars without full re-render
    const updateStatusBars = () => {
      const container = document.getElementById('gameStatusBars');
      if (container) {
        container.innerHTML = '';
        buildGameStatusRows().forEach(el => container.appendChild(el));
      }
    };

    const gameStatusRows = buildGameStatusRows();

    const toggleBar = h('div',{class:'scoring-toggle'},[
      h('button',{class:'scoring-toggle-btn active',onclick:()=>{}},'Scores'),
      h('button',{class:'scoring-toggle-btn',onclick:()=>{State.data.tab='junk';State.scheduleRender();}},'Junk')
    ]);

    return h('div',{},[
      toggleBar,
      h('div',{class:'row',style:'align-items:center;justify-content:space-between;margin-bottom:8px;'},[
        h('div',{class:'pill'},'Entering GROSS for all players'),
        (() => {
          const notes = [];
          const gameTypes = State.data.games.map(g => g.gameType);
          if (gameTypes.includes('vegas')) notes.push('Vegas: P=2x, B=4x');
          if (gameTypes.includes('wolf')) notes.push('Wolf: pick partner or W/BW');
          if (gameTypes.includes('skins')) notes.push('Skins: lowest wins');
          return notes.length ? h('div',{class:'note'},notes.join(' | ')) : h('div',{});
        })()
      ]),
      scroller,
      h('div',{id:'gameStatusBars',style:'margin-top:12px;'},gameStatusRows)
    ]);
  },

  junk() {
    const last = Game.getLastScored();
    const blocks = State.data.games.map((g, gi) => {
      // Get players for this game type
      let pids;
      if (g.gameType === 'skins') {
        pids = g.skinsPlayers || [];
      } else if (g.gameType === 'wolf') {
        pids = g.wolfPlayers || [];
      } else if (g.gameType === 'ninepoint') {
        pids = g.ninePointPlayers || [];
      } else {
        pids = [...(g.teamA||[]),...(g.teamB||[])];
      }
      const theme = `theme-g${(gi%6)+1}`;
      const baseTab = gi * 10000;

      const createInput = (pid, hole, ri) => {
        if (!g.junkCounts[pid]) g.junkCounts[pid] = Utils.make18(0);
        let cur = g.junkCounts[pid][hole];
        if (!Number.isFinite(cur)) { cur = 0; g.junkCounts[pid][hole] = 0; }
        const disp = cur===0?'':String(cur);
        const badge = h('span',{class:'junkVal'},disp);
        const tabIdx = baseTab + (hole * pids.length) + ri + 1;
        const inp = h('input',{
          class:'junkBox',type:'text',inputmode:'numeric',autocomplete:'off',placeholder:'-',tabindex:tabIdx,value:disp,
          oninput:(e)=>{
            const dig = Utils.sanitize(e.target.value);
            if (dig !== e.target.value) e.target.value = dig;
            const v = dig===''?0:parseInt(dig);
            g.junkCounts[pid][hole] = v;
            badge.textContent = v===0?'':String(v);
            try { localStorage.setItem(STORAGE_KEY, JSON.stringify({...State.data, presets:State.presets})); } catch(e) {}
          },
          onkeydown:(e)=>{
            if (e.key==='Enter') {
              e.preventDefault();
              let next = tabIdx + 1;
              const colEnd = baseTab + ((hole+1)*pids.length);
              if (next > colEnd) next = baseTab + ((hole+1)*pids.length - (pids.length-1));
              const nextEl = document.querySelector(`input[tabindex="${next}"]`);
              if (nextEl) nextEl.focus();
            }
          },
          onblur:(e)=>{
            const dig = Utils.sanitize(e.target.value);
            const v = dig===''?0:parseInt(dig);
            g.junkCounts[pid][hole] = v;
            e.target.value = v===0?'':String(v);
            badge.textContent = v===0?'':String(v);
            State.scheduleSave();
          }
        });
        return h('div',{class:'junkWrap'},[inp, badge]);
      };

      const head = [h('th',{class:'sticky'},'Hole')];
      for (let i = 0; i < 18; i++) head.push(h('th',{id:`junk_col_${gi}_${i}`},String(i+1)));

      const rows = pids.map((pid,ri) => {
        const cells = [h('td',{class:'sticky'},UI.playerName(pid))];
        for (let hole = 0; hole < 18; hole++) {
          cells.push(h('td',{},[createInput(pid, hole, ri)]));
        }
        return h('tr',{},cells);
      });

      const tbl = h('table',{},[
        h('thead',{},[h('tr',{},head)]),
        h('tbody',{},rows)
      ]);

      const scroller = h('div',{class:'card scroll',id:`junkScroll_${gi}`},tbl);

      if (last >= 0) {
        setTimeout(()=>{
          try {
            const col = document.getElementById(`junk_col_${gi}_${last}`);
            const sc = document.getElementById(`junkScroll_${gi}`);
            if (col && sc) {
              const tgt = Math.max(0, col.offsetLeft - sc.clientWidth*0.2);
              sc.scrollLeft = tgt;
            }
          } catch(e) {}
        },0);
      }

      return h('div',{class:theme},scroller);
    });

    const toggleBar = h('div',{class:'scoring-toggle'},[
      h('button',{class:'scoring-toggle-btn',onclick:()=>{State.data.tab='scores';State.scheduleRender();}},'Scores'),
      h('button',{class:'scoring-toggle-btn active',onclick:()=>{}},'Junk')
    ]);

    return h('div',{},[
      toggleBar,
      h('div',{class:'note',style:'margin-bottom:8px;'},'Sweeps (+3) Sweeps/Quads (+6) on last Par 3'),
      ...blocks
    ]);
  },

  status() {
    const blocks = State.data.games.map((g,idx) => {
      const theme = `theme-g${(idx%6)+1}`;
      
      if (g.gameType === 'vegas') {
        const result = Game.computeVegasResult(g);
        const teamANames = (g.teamA||[]).map(pid => UI.playerName(pid)).join(' & ');
        const teamBNames = (g.teamB||[]).map(pid => UI.playerName(pid)).join(' & ');
        
        return h('div',{class:theme},[
          h('div',{class:'card'},[
            h('div',{class:'pill'},UI.gameLabel(g)),
            h('div',{class:'note',style:'margin-top:6px;'},`A: ${teamANames}  |  B: ${teamBNames}`),
            h('div',{style:'margin-top:12px;'},[
              h('div',{class:'muted'},'Front: ' + (result.frontPoints>0?'+':'') + result.frontPoints + ' pts = ' + Utils.fmt(result.frontValue)),
              h('div',{class:'muted',style:'margin-top:4px;'},'Back: ' + (result.backPoints>0?'+':'') + result.backPoints + ' pts = ' + Utils.fmt(result.backValue)),
              h('div',{class:'muted',style:'margin-top:4px;'},'Junk: ' + Utils.fmt(result.junkValue)),
              h('div',{style:'margin-top:8px;font-weight:700;'},'Total: ' + Utils.fmt(result.totalValue))
            ])
          ])
        ]);
      }

      if (g.gameType === 'skins') {
        const result = Game.computeSkinsResult(g);
        const players = g.skinsPlayers || [];
        const mode = g.skinsMode || 'net';
        const buyIn = g.stakes.front || 20;

        // Player standings
        const playerRows = players.map(pid => {
          const name = UI.playerName(pid);
          const skins = mode === 'gross' ? result.grossSkins[pid] :
                        mode === 'net' ? result.netSkins[pid] :
                        (result.grossSkins[pid] + result.netSkins[pid]);
          const value = (skins || 0) * (mode === 'gross' ? result.grossSkinValue : result.netSkinValue);
          return h('div',{style:'display:flex;justify-content:space-between;padding:4px 0;'},
            [h('span',{},name), h('span',{},`${skins || 0} skins = ${Utils.fmt(value)}`)]
          );
        });

        const carry = mode === 'gross' ? result.grossCarry :
                      mode === 'net' ? result.netCarry :
                      (result.grossCarry + result.netCarry);

        return h('div',{class:theme},[
          h('div',{class:'card'},[
            h('div',{class:'pill'},UI.gameLabel(g)),
            h('div',{class:'note',style:'margin-top:6px;'},`Mode: ${mode} | Buy-in: ${Utils.fmt(buyIn)} | Pot: ${Utils.fmt(result.totalPot)}`),
            h('div',{style:'margin-top:12px;'},playerRows),
            carry > 0 ? h('div',{class:'muted',style:'margin-top:8px;'},`Carryover: ${carry} skin${carry>1?'s':''}`) : '',
            h('div',{style:'margin-top:8px;font-weight:700;'},`$/Skin: ${Utils.fmt(mode === 'gross' ? result.grossSkinValue : result.netSkinValue)}`)
          ])
        ]);
      }

      if (g.gameType === 'wolf') {
        const result = Game.computeWolfResult(g);
        const players = g.wolfPlayers || [];
        const pointValue = g.wolfPointValue || 1;

        // Calculate junk pay-up-the-ladder for Wolf
        const sumJunkPid = (pid, start, end) => {
          let tot = 0;
          const arr = g.junkCounts[pid] || [];
          for (let h = start; h <= end; h++) tot += (arr[h]||0);
          return tot;
        };
        const junkStandings = players.map(pid => {
          const frontJunk = sumJunkPid(pid, 0, 8);
          const backJunk = sumJunkPid(pid, 9, 17);
          const junkVal = frontJunk * (g.junkValue.front||0) + backJunk * (g.junkValue.back||0);
          return { pid, junkVal };
        }).sort((a, b) => b.junkVal - a.junkVal);
        // Calculate junk net per player (pay up the ladder)
        const junkNet = {};
        players.forEach(pid => { junkNet[pid] = 0; });
        let totalJunkMoney = 0;
        for (let i = 0; i < junkStandings.length; i++) {
          for (let j = i + 1; j < junkStandings.length; j++) {
            const diff = junkStandings[i].junkVal - junkStandings[j].junkVal;
            if (diff > 0) {
              junkNet[junkStandings[i].pid] += diff;
              junkNet[junkStandings[j].pid] -= diff;
              totalJunkMoney += diff;
            }
          }
        }
        const hasJunk = totalJunkMoney > 0;

        // Player standings with Wolf + junk net amounts
        const playerRows = players.map(pid => {
          const name = UI.playerName(pid);
          const wolfAmt = result.playerNet[pid] || 0;
          const junkAmt = junkNet[pid] || 0;
          const totalAmt = wolfAmt + junkAmt;
          return h('div',{style:'display:flex;justify-content:space-between;padding:4px 0;'},
            [h('span',{},name), h('span',{},Utils.fmt(totalAmt))]
          );
        });

        return h('div',{class:theme},[
          h('div',{class:'card'},[
            h('div',{class:'pill'},UI.gameLabel(g)),
            h('div',{class:'note',style:'margin-top:6px;'},`$${pointValue}/pt | Carryover: ${result.carryover}`),
            h('div',{style:'margin-top:12px;'},playerRows),
            hasJunk ? h('div',{class:'muted',style:'margin-top:8px;'},`Junk in play: ${Utils.fmt(totalJunkMoney)}`) : '',
            h('div',{style:'margin-top:8px;font-weight:700;'},`Total in play: ${Utils.fmt(result.totalMoney + totalJunkMoney)}`)
          ])
        ]);
      }

      if (g.gameType === 'ninepoint') {
        const result = Game.computeNinePointResult(g);
        const players = g.ninePointPlayers || [];
        const pointValue = g.ninePointValue || 1;

        // Calculate junk pay-up-the-ladder for 9-Point
        const sumJunkPid = (pid, start, end) => {
          let tot = 0;
          const arr = g.junkCounts[pid] || [];
          for (let h = start; h <= end; h++) tot += (arr[h]||0);
          return tot;
        };
        const junkStandings = players.map(pid => {
          const frontJunk = sumJunkPid(pid, 0, 8);
          const backJunk = sumJunkPid(pid, 9, 17);
          const junkVal = frontJunk * (g.junkValue.front||0) + backJunk * (g.junkValue.back||0);
          return { pid, junkVal };
        }).sort((a, b) => b.junkVal - a.junkVal);
        const junkNet = {};
        players.forEach(pid => { junkNet[pid] = 0; });
        let totalJunkMoney = 0;
        for (let i = 0; i < junkStandings.length; i++) {
          for (let j = i + 1; j < junkStandings.length; j++) {
            const diff = junkStandings[i].junkVal - junkStandings[j].junkVal;
            if (diff > 0) {
              junkNet[junkStandings[i].pid] += diff;
              junkNet[junkStandings[j].pid] -= diff;
              totalJunkMoney += diff;
            }
          }
        }
        const hasJunk = totalJunkMoney > 0;

        // Player standings
        const playerRows = players.map(pid => {
          const name = UI.playerName(pid);
          const nineAmt = result.playerNet[pid] || 0;
          const junkAmt = junkNet[pid] || 0;
          const totalAmt = nineAmt + junkAmt;
          const pts = result.playerPoints[pid] || 0;
          return h('div',{style:'display:flex;justify-content:space-between;padding:4px 0;'},
            [h('span',{},`${name} (${pts} pts)`), h('span',{},Utils.fmt(totalAmt))]
          );
        });

        const rulesNote = [];
        if (g.ninePointWinBy2) rulesNote.push('Win by 2');
        if (g.ninePointBirdieDouble) rulesNote.push('Birdie 2x');
        const rulesText = rulesNote.length ? ` | ${rulesNote.join(', ')}` : '';

        return h('div',{class:theme},[
          h('div',{class:'card'},[
            h('div',{class:'pill'},UI.gameLabel(g)),
            h('div',{class:'note',style:'margin-top:6px;'},`$${pointValue}/pt${rulesText}`),
            h('div',{style:'margin-top:12px;'},playerRows),
            hasJunk ? h('div',{class:'muted',style:'margin-top:8px;'},`Junk: ${Utils.fmt(totalJunkMoney)}`) : ''
          ])
        ]);
      }

      const renderSeg = (lbl, start, end, autoKey) => {
        const stake = g.stakes[autoKey] || 0;
        const seg = Game.buildSegment(g, start, end, stake, g.autoPress[autoKey]);
        const diffs = [];
        for (let i = 0; i < 18; i++) diffs.push(Game.holeDiff(g, i));
        const calcCum = (line) => {
          let cum = 0, hasAny = false;
          for (let h = line.start; h <= line.end; h++) {
            if (diffs[h] != null) {
              cum += diffs[h];
              hasAny = true;
            }
          }
          return hasAny ? cum : null;
        };
        const bets = seg.lines.map(line => {
          const c = calcCum(line);
          if (c===null) return '‚Äî';
          if (c>0) return `+${c}`;
          if (c<0) return String(c);
          return 'E';
        });
        const hasAny = bets.some(t => t !== '‚Äî');
        const betsTxt = hasAny ? bets.join(' / ') : '‚Äî';

        const sumJunk = (team) => {
          let tot = 0;
          team.forEach(pid => {
            const arr = g.junkCounts[pid] || [];
            for (let h = start; h <= end && h < 18; h++) tot += (arr[h]||0);
          });
          return tot;
        };
        const aJ = sumJunk(g.teamA||[]);
        const bJ = sumJunk(g.teamB||[]);

        return h('div',{class:'card'},[
          h('div',{class:'row',style:'align-items:center;justify-content:space-between;'},[
            h('div',{class:'muted'},lbl),
            h('div',{class:'pill'},[
              h('div',{},`Bets: ${betsTxt}`),
              h('div',{},`Junk: A=${aJ} B=${bJ}`)
            ])
          ])
        ]);
      };

      const aN = (g.teamA||[]).map(pid => UI.playerName(pid)).join(' & ');
      const bN = (g.teamB||[]).map(pid => UI.playerName(pid)).join(' & ');

      return h('div',{class:theme},[
        h('div',{class:'card'},[
          h('div',{class:'row',style:'align-items:center;justify-content:space-between;'},[
            h('div',{class:'pill'},this.gameLabel(g)),
            h('div',{class:'note'},'Positive = Team A')
          ]),
          h('div',{class:'note'},`A: ${aN||'‚Äî'}  |  B: ${bN||'‚Äî'}`),
          renderSeg('Front (1‚Äì9)',0,8,'front'),
          renderSeg('Back (10‚Äì18)',9,17,'back'),
          renderSeg('Overall (1‚Äì18)',0,17,'overall')
        ])
      ]);
    });

    return h('div',{},[
      h('div',{class:'note',style:'margin-bottom:8px;'},'Current match standings'),
      ...blocks
    ]);
  },

  game() {
    const blocks = State.data.games.map((g,idx) => {
      const theme = `theme-g${(idx%6)+1}`;

      // Check if any scores entered
      if (!Game.hasAnyScores(g)) {
        return h('div',{class:theme},[
          h('div',{class:'card'},[
            h('div',{class:'pill'},UI.gameLabel(g)),
            h('div',{class:'muted',style:'margin-top:12px;text-align:center;padding:20px;'},'No scores entered yet. Go to SCORES tab to enter scores.')
          ])
        ]);
      }

      const teamANames = (g.teamA||[]).map(pid => UI.playerName(pid));
      const teamBNames = (g.teamB||[]).map(pid => UI.playerName(pid));
      const fmtPts = (p) => p > 0 ? `+${p}` : p === 0 ? 'E' : String(p);

      if (g.gameType === 'vegas') {
        const result = Game.computeVegasResult(g);
        const par = State.data.course.par;

        // Build hole-by-hole rows for Vegas
        const buildVegasHoleRows = (startHole, endHole) => {
          let runningTotal = 0;
          const rows = [];

          for (let hole = startHole; hole <= endHole; hole++) {
            const detail = result.holeDetails[hole];
            if (!detail) {
              rows.push(h('div',{style:'padding:6px 0;border-bottom:1px solid var(--border);color:var(--muted);font-size:12px;'},
                `Hole ${hole+1}: No scores`));
              continue;
            }

            runningTotal += detail.pointsToA;

            // Build flip reason text
            let flipReasonA = '', flipReasonB = '';
            if (detail.aFlip) {
              if (detail.bHasBirdie) flipReasonA = '(B birdie)';
              else flipReasonA = '(no net par)';
            }
            if (detail.bFlip) {
              if (detail.aHasBirdie) flipReasonB = '(A birdie)';
              else flipReasonB = '(no net par)';
            }

            const aFlipTxt = detail.aFlip ? ' FLIP' + flipReasonA : '';
            const bFlipTxt = detail.bFlip ? ' FLIP' + flipReasonB : '';

            const diffAbs = Math.abs(detail.numA - detail.numB);
            const winner = detail.numA < detail.numB ? 'A' : detail.numA > detail.numB ? 'B' : 'TIE';
            const mathTxt = winner === 'TIE' ? `${detail.numA} vs ${detail.numB} = Push`
              : `${Math.min(detail.numA,detail.numB)} vs ${Math.max(detail.numA,detail.numB)} = ${winner} +${diffAbs}`;

            const ptClass = detail.pointsToA > 0 ? 'points-positive' : detail.pointsToA < 0 ? 'points-negative' : '';

            rows.push(h('div',{style:'padding:8px 0;border-bottom:1px solid var(--border);font-size:12px;'},[
              h('div',{style:'display:flex;justify-content:space-between;align-items:center;'},[
                h('span',{style:'font-weight:600;'},`#${hole+1}`),
                h('span',{class:ptClass,style:'font-weight:600;'},`${fmtPts(detail.pointsToA)} pts`)
              ]),
              h('div',{style:'margin-top:4px;color:var(--muted);'},[
                h('div',{},`A: ${detail.numA}${aFlipTxt}  |  B: ${detail.numB}${bFlipTxt}`),
                h('div',{style:'margin-top:2px;'},mathTxt + (detail.multiplier > 1 ? ` √ó${detail.multiplier}` : ''))
              ])
            ]));
          }
          return rows;
        };

        const frontRows = buildVegasHoleRows(0, 8);
        const backRows = buildVegasHoleRows(9, 17);
        const frontPts = result.frontPoints;
        const backPts = result.backPoints;
        const frontVal = frontPts * (g.pointValue.front || 0);
        const backVal = backPts * (g.pointValue.back || 0);

        return h('div',{class:theme},[
          h('div',{class:'card'},[
            h('div',{class:'pill'},UI.gameLabel(g)),
            h('div',{class:'note',style:'margin-top:6px;'},`Team A: ${teamANames.join(' & ')}  |  Team B: ${teamBNames.join(' & ')}`),

            // Front 9
            h('div',{style:'margin-top:12px;'},[
              h('div',{style:'font-weight:600;margin-bottom:8px;display:flex;justify-content:space-between;'},[
                h('span',{},'Front 9'),
                h('span',{class:frontPts>0?'points-positive':frontPts<0?'points-negative':''},
                  `${fmtPts(frontPts)} pts = ${Utils.fmt(frontVal)}/ea`)
              ]),
              ...frontRows
            ]),

            // Back 9
            h('div',{style:'margin-top:16px;'},[
              h('div',{style:'font-weight:600;margin-bottom:8px;display:flex;justify-content:space-between;'},[
                h('span',{},'Back 9'),
                h('span',{class:backPts>0?'points-positive':backPts<0?'points-negative':''},
                  `${fmtPts(backPts)} pts = ${Utils.fmt(backVal)}/ea`)
              ]),
              ...backRows
            ]),

            // Junk & Total
            h('div',{class:'card',style:'margin-top:12px;'},[
              h('div',{class:'row',style:'justify-content:space-between;'},[
                h('div',{class:'muted'},'Junk:'),
                h('div',{style:'font-weight:600;'},Utils.fmt(result.junkValue) + ' (' + Utils.fmt(result.junkValue / ((g.teamA||[]).length || 1)) + '/ea)')
              ])
            ]),
            h('div',{class:'card',style:'margin-top:12px;background:linear-gradient(135deg,rgba(59,130,246,0.1),rgba(22,163,74,0.1));'},[
              h('div',{class:'row',style:'justify-content:space-between;align-items:center;'},[
                h('div',{},[
                  h('div',{class:'muted'},'TOTAL TO TEAM A'),
                  h('div',{class:'muted',style:'font-size:11px;margin-top:2px;'},Utils.fmt(result.totalValue / ((g.teamA||[]).length || 1))+' per player')
                ]),
                h('div',{style:'font-size:24px;font-weight:700;',class:result.totalValue>0?'points-positive':'points-negative'},
                  Utils.fmt(result.totalValue))
              ])
            ])
          ])
        ]);
      }

      // Skins - hole-by-hole view with skin winners
      if (g.gameType === 'skins') {
        const result = Game.computeSkinsResult(g);
        const mode = g.skinsMode || 'net';
        const players = g.skinsPlayers || [];

        const buildSkinsHoleRows = () => {
          const rows = [];
          for (let hole = 0; hole < 18; hole++) {
            const detail = result.holeDetails[hole];
            if (!detail) {
              rows.push(h('div',{style:'padding:6px 0;border-bottom:1px solid var(--border);color:var(--muted);font-size:12px;'},
                `Hole ${hole+1}: No scores`));
              continue;
            }

            const winnerLines = [];
            if (mode === 'gross' || mode === 'both') {
              if (detail.grossWinner === 'split') {
                winnerLines.push(h('span',{},`Gross: SPLIT (${detail.grossSkins} skins)`));
              } else if (detail.grossWinner) {
                winnerLines.push(h('span',{class:'points-positive'},`Gross: ${UI.playerName(detail.grossWinner)} wins ${detail.grossSkins} skin${detail.grossSkins>1?'s':''}`));
              } else if (detail.grossCarry > 0) {
                winnerLines.push(h('span',{class:'muted'},`Gross: Carry (${detail.grossCarry})`));
              }
            }
            if (mode === 'net' || mode === 'both') {
              if (detail.netWinner === 'split') {
                winnerLines.push(h('span',{},`Net: SPLIT (${detail.netSkins} skins)`));
              } else if (detail.netWinner) {
                winnerLines.push(h('span',{class:'points-positive'},`Net: ${UI.playerName(detail.netWinner)} wins ${detail.netSkins} skin${detail.netSkins>1?'s':''}`));
              } else if (detail.netCarry > 0) {
                winnerLines.push(h('span',{class:'muted'},`Net: Carry (${detail.netCarry})`));
              }
            }

            rows.push(h('div',{style:'padding:8px 0;border-bottom:1px solid var(--border);font-size:12px;'},[
              h('div',{style:'display:flex;justify-content:space-between;align-items:center;'},[
                h('span',{style:'font-weight:600;'},`#${hole+1}`),
                h('div',{style:'text-align:right;'},winnerLines.length > 0 ? winnerLines.map((w,i) => h('div',{key:i},w)) : h('span',{class:'muted'},'Carry'))
              ])
            ]));
          }
          return rows;
        };

        const holeRows = buildSkinsHoleRows();

        // Player results table
        const playerRows = players.map(pid => {
          const pr = result.playerResults[pid];
          const profitClass = pr.profit > 0 ? 'points-positive' : pr.profit < 0 ? 'points-negative' : '';
          return h('div',{style:'display:flex;justify-content:space-between;padding:6px 0;border-bottom:1px solid var(--border);'},[
            h('span',{},UI.playerName(pid)),
            h('div',{style:'text-align:right;'},[
              mode === 'both'
                ? h('span',{class:'muted'},`G:${pr.grossSkins} N:${pr.netSkins} `)
                : h('span',{class:'muted'},`${mode === 'gross' ? pr.grossSkins : pr.netSkins} skins `),
              h('span',{class:profitClass,style:'font-weight:600;'},Utils.fmt(pr.profit))
            ])
          ]);
        });

        return h('div',{class:theme},[
          h('div',{class:'card'},[
            h('div',{class:'pill'},UI.gameLabel(g)),
            h('div',{class:'note',style:'margin-top:6px;'},`Players: ${players.map(pid => UI.playerName(pid)).join(', ')}`),
            h('div',{class:'note'},`Buy-in: ${Utils.fmt(result.buyIn)} | Pot: ${Utils.fmt(result.totalPot)}`),

            // Hole-by-hole
            h('div',{style:'margin-top:12px;'},[
              h('div',{style:'font-weight:600;margin-bottom:8px;'},'Hole by Hole'),
              ...holeRows
            ]),

            // Carryovers remaining
            (result.grossCarry > 0 || result.netCarry > 0) ?
              h('div',{class:'card',style:'margin-top:12px;background:rgba(234,179,8,0.1);'},[
                h('div',{style:'font-weight:600;color:#ca8a04;'},
                  mode === 'both' ? `Carryovers: Gross ${result.grossCarry} | Net ${result.netCarry}`
                    : `${result.grossCarry + result.netCarry} skin${(result.grossCarry + result.netCarry) > 1 ? 's' : ''} carrying`)
              ]) : '',

            // Skin values
            h('div',{class:'card',style:'margin-top:12px;'},[
              h('div',{style:'font-weight:600;margin-bottom:4px;'},'Skin Values'),
              mode === 'both' ? h('div',{class:'muted'},`Gross: ${Utils.fmt(result.grossSkinValue)}/skin (${result.totalGrossSkins} total) | Net: ${Utils.fmt(result.netSkinValue)}/skin (${result.totalNetSkins} total)`)
                : h('div',{class:'muted'},`${Utils.fmt(mode === 'gross' ? result.grossSkinValue : result.netSkinValue)}/skin (${mode === 'gross' ? result.totalGrossSkins : result.totalNetSkins} total)`)
            ]),

            // Player results
            h('div',{style:'margin-top:12px;'},[
              h('div',{style:'font-weight:600;margin-bottom:8px;'},'Results (+/- from buy-in)'),
              ...playerRows
            ])
          ])
        ]);
      }

      // Wolf - hole-by-hole view with partner selections and results
      if (g.gameType === 'wolf') {
        const result = Game.computeWolfResult(g);
        const players = g.wolfPlayers || [];
        const pointValue = g.wolfPointValue || 1;

        const buildWolfHoleRows = () => {
          const rows = [];
          for (let hole = 0; hole < 18; hole++) {
            const detail = result.holeDetails[hole];
            if (!detail || !detail.selection) {
              const wolfPid = detail ? detail.wolf : null;
              const wolfName = wolfPid ? UI.playerName(wolfPid) : '?';
              rows.push(h('div',{style:'padding:6px 0;border-bottom:1px solid var(--border);color:var(--muted);font-size:12px;'},
                `Hole ${hole+1}: Wolf=${wolfName} - No selection`));
              continue;
            }

            const wolfName = UI.playerName(detail.wolf);
            let selText = '';
            if (detail.selection === 'blind') selText = 'Blind Wolf (4x)';
            else if (detail.selection === 'wolf') selText = 'Wolf alone (2x)';
            else selText = `Partner: ${UI.playerName(detail.selection)}`;

            const wolfTeamNames = detail.wolfTeam.map(pid => UI.playerName(pid)).join(' & ');
            const otherTeamNames = detail.otherTeam.map(pid => UI.playerName(pid)).join(' & ');

            let resultText = '';
            let resultClass = '';
            if (detail.winner === 'wolf') {
              resultText = `Wolf team wins +${detail.points} pts`;
              resultClass = 'points-positive';
            } else if (detail.winner === 'others') {
              resultText = `Others win +${detail.points} pts`;
              resultClass = 'points-negative';
            } else if (detail.winner === 'tie') {
              resultText = `Tie - carry ${detail.carryover}`;
              resultClass = '';
            } else {
              resultText = 'In progress';
            }

            const catchUpText = detail.catchUp ? ' (catch-up)' : '';

            rows.push(h('div',{style:'padding:8px 0;border-bottom:1px solid var(--border);font-size:12px;'},[
              h('div',{style:'display:flex;justify-content:space-between;align-items:center;'},[
                h('span',{style:'font-weight:600;'},`#${hole+1}${catchUpText}`),
                h('span',{class:resultClass,style:'font-weight:600;'},resultText)
              ]),
              h('div',{style:'margin-top:4px;color:var(--muted);'},[
                h('div',{},`Wolf: ${wolfName} | ${selText}`),
                h('div',{style:'margin-top:2px;'},`${wolfTeamNames} (${detail.wolfBest || '?'}) vs ${otherTeamNames} (${detail.otherBest || '?'})`)
              ])
            ]));
          }
          return rows;
        };

        const holeRows = buildWolfHoleRows();

        // Calculate junk pay-up-the-ladder
        const sumJunkPid = (pid, start, end) => {
          let tot = 0;
          const arr = g.junkCounts[pid] || [];
          for (let h = start; h <= end; h++) tot += (arr[h]||0);
          return tot;
        };
        const junkStandings = players.map(pid => {
          const frontJunk = sumJunkPid(pid, 0, 8);
          const backJunk = sumJunkPid(pid, 9, 17);
          const junkVal = frontJunk * (g.junkValue.front||0) + backJunk * (g.junkValue.back||0);
          return { pid, junkVal, frontJunk, backJunk };
        }).sort((a, b) => b.junkVal - a.junkVal);
        // Calculate junk net per player (pay up the ladder)
        const junkNet = {};
        players.forEach(pid => { junkNet[pid] = 0; });
        let totalJunkMoney = 0;
        const junkTxns = [];
        for (let i = 0; i < junkStandings.length; i++) {
          for (let j = i + 1; j < junkStandings.length; j++) {
            const diff = junkStandings[i].junkVal - junkStandings[j].junkVal;
            if (diff > 0) {
              junkNet[junkStandings[i].pid] += diff;
              junkNet[junkStandings[j].pid] -= diff;
              totalJunkMoney += diff;
              junkTxns.push({ from: junkStandings[j].pid, to: junkStandings[i].pid, amount: diff });
            }
          }
        }
        const hasJunk = totalJunkMoney > 0;

        // Wolf per-player summary
        const wolfPlayerRows = players.map(pid => {
          const wolfAmt = result.playerNet[pid] || 0;
          const profitClass = wolfAmt > 0 ? 'points-positive' : wolfAmt < 0 ? 'points-negative' : '';
          return h('div',{style:'display:flex;justify-content:space-between;padding:4px 0;font-size:12px;'},[
            h('span',{},UI.playerName(pid)),
            h('span',{class:profitClass,style:'font-weight:600;'},Utils.fmt(wolfAmt))
          ]);
        });

        // Junk per-player summary
        const junkPlayerRows = players.map(pid => {
          const junkAmt = junkNet[pid] || 0;
          const profitClass = junkAmt > 0 ? 'points-positive' : junkAmt < 0 ? 'points-negative' : '';
          return h('div',{style:'display:flex;justify-content:space-between;padding:4px 0;font-size:12px;'},[
            h('span',{},UI.playerName(pid)),
            h('span',{class:profitClass,style:'font-weight:600;'},Utils.fmt(junkAmt))
          ]);
        });

        // Player results table (Wolf + junk combined)
        const playerRows = players.map(pid => {
          const wolfAmt = result.playerNet[pid] || 0;
          const junkAmt = junkNet[pid] || 0;
          const totalAmt = wolfAmt + junkAmt;
          const profitClass = totalAmt > 0 ? 'points-positive' : totalAmt < 0 ? 'points-negative' : '';
          return h('div',{style:'display:flex;justify-content:space-between;padding:6px 0;border-bottom:1px solid var(--border);'},[
            h('span',{},UI.playerName(pid)),
            h('span',{class:profitClass,style:'font-weight:600;'},Utils.fmt(totalAmt))
          ]);
        });

        return h('div',{class:theme},[
          h('div',{class:'card'},[
            h('div',{class:'pill'},UI.gameLabel(g)),
            h('div',{class:'note',style:'margin-top:6px;'},`Players: ${players.map(pid => UI.playerName(pid)).join(', ')}`),
            h('div',{class:'note'},`$${pointValue}/pt | Carryover: ${result.carryover}`),

            // Hole-by-hole
            h('div',{style:'margin-top:12px;'},[
              h('div',{style:'font-weight:600;margin-bottom:8px;'},'Hole by Hole'),
              ...holeRows
            ]),

            // Carryover warning
            result.carryover > 0 ?
              h('div',{class:'card',style:'margin-top:12px;background:rgba(234,179,8,0.1);'},[
                h('div',{style:'font-weight:600;color:#ca8a04;'},`${result.carryover} pts carrying to next hole`)
              ]) : '',

            // Wolf per-player results
            h('div',{style:'margin-top:12px;'},[
              h('div',{style:'font-weight:600;margin-bottom:8px;'},'Wolf'),
              ...wolfPlayerRows
            ]),

            // Junk per-player results
            hasJunk ?
              h('div',{style:'margin-top:12px;'},[
                h('div',{style:'font-weight:600;margin-bottom:8px;'},'Junk'),
                ...junkPlayerRows
              ]) : '',

            // Player results
            h('div',{style:'margin-top:12px;'},[
              h('div',{style:'font-weight:600;margin-bottom:8px;'},'Player Results (Wolf + Junk)'),
              ...playerRows
            ]),

            // Total
            h('div',{class:'card',style:'margin-top:12px;background:linear-gradient(135deg,rgba(59,130,246,0.1),rgba(22,163,74,0.1));'},[
              h('div',{class:'row',style:'justify-content:space-between;align-items:center;'},[
                h('div',{},[
                  h('div',{class:'muted'},'TOTAL IN PLAY'),
                  hasJunk ? h('div',{class:'muted',style:'font-size:11px;'},`Wolf: ${Utils.fmt(result.totalMoney)} + Junk: ${Utils.fmt(totalJunkMoney)}`) : ''
                ]),
                h('div',{style:'font-size:24px;font-weight:700;'},Utils.fmt(result.totalMoney + totalJunkMoney))
              ])
            ])
          ])
        ]);
      }

      // 9-Point - hole-by-hole view with point distribution
      if (g.gameType === 'ninepoint') {
        const result = Game.computeNinePointResult(g);
        const players = g.ninePointPlayers || [];
        const pointValue = g.ninePointValue || 1;

        const buildNinePointHoleRows = () => {
          const rows = [];
          for (let hole = 0; hole < 18; hole++) {
            const detail = result.holeDetails[hole];
            if (!detail || Object.keys(detail.scores).length !== 3) {
              rows.push(h('div',{style:'padding:6px 0;border-bottom:1px solid var(--border);color:var(--muted);font-size:12px;'},
                `Hole ${hole+1}: No scores`));
              continue;
            }

            // Get scores and points for display
            const playerInfo = players.map(pid => ({
              pid,
              name: UI.playerName(pid),
              score: detail.scores[pid] ? detail.scores[pid].net : '?',
              pts: detail.points[pid] || 0
            })).sort((a, b) => a.score - b.score);

            const scoreText = playerInfo.map(p => `${p.name.slice(0,3)}:${p.score}`).join(' ');
            const ptsText = playerInfo.map(p => `${p.pts}`).join('/');

            let specialText = '';
            if (detail.birdieDoubleApplied) specialText = ' (Birdie 2x)';
            else if (detail.winBy2Applied) specialText = ' (Win by 2)';

            rows.push(h('div',{style:'padding:8px 0;border-bottom:1px solid var(--border);font-size:12px;'},[
              h('div',{style:'display:flex;justify-content:space-between;align-items:center;'},[
                h('span',{style:'font-weight:600;'},`#${hole+1}`),
                h('span',{style:'font-weight:600;'},`${ptsText}${specialText}`)
              ]),
              h('div',{style:'margin-top:4px;color:var(--muted);'},scoreText)
            ]));
          }
          return rows;
        };

        const holeRows = buildNinePointHoleRows();

        // Player results
        const playerRows = players.map(pid => {
          const pts = result.playerPoints[pid] || 0;
          const amt = result.playerNet[pid] || 0;
          const profitClass = amt > 0 ? 'points-positive' : amt < 0 ? 'points-negative' : '';
          return h('div',{style:'display:flex;justify-content:space-between;padding:6px 0;border-bottom:1px solid var(--border);'},[
            h('span',{},`${UI.playerName(pid)} (${pts} pts)`),
            h('span',{class:profitClass,style:'font-weight:600;'},Utils.fmt(amt))
          ]);
        });

        const rulesNote = [];
        if (g.ninePointWinBy2) rulesNote.push('Win by 2');
        if (g.ninePointBirdieDouble) rulesNote.push('Birdie 2x');
        const rulesText = rulesNote.length ? ` | ${rulesNote.join(', ')}` : '';

        return h('div',{class:theme},[
          h('div',{class:'card'},[
            h('div',{class:'pill'},UI.gameLabel(g)),
            h('div',{class:'note',style:'margin-top:6px;'},`Players: ${players.map(pid => UI.playerName(pid)).join(', ')}`),
            h('div',{class:'note'},`$${pointValue}/pt${rulesText}`),

            // Hole-by-hole
            h('div',{style:'margin-top:12px;'},[
              h('div',{style:'font-weight:600;margin-bottom:8px;'},'Hole by Hole'),
              ...holeRows
            ]),

            // Player results
            h('div',{style:'margin-top:12px;'},[
              h('div',{style:'font-weight:600;margin-bottom:8px;'},'Player Results'),
              ...playerRows
            ])
          ])
        ]);
      }

      // Nassau - detailed hole-by-hole view
      let res;
      try {
        res = Game.computeResult(g);
      } catch(e) {
        console.error('computeResult failed:', e);
        return h('div',{class:theme},[h('div',{class:'card'},[h('div',{},'Error calculating Nassau result: ' + e.message)])]);
      }

      const buildNassauHoleRows = (startHole, endHole, autoPress) => {
        const rows = [];
        const A = g.teamA || [];
        const B = g.teamB || [];

        // Pre-calculate all hole diffs for this segment
        const diffs = [];
        for (let h = startHole; h <= endHole; h++) {
          diffs.push(Game.holeDiff(g, h));
        }

        // Track bet lines - each has a start hole and we track cumulative
        const betLines = [{ start: startHole, pressesTriggered: 0 }];

        for (let hole = startHole; hole <= endHole; hole++) {
          const holeIdx = hole - startHole;

          // Get net scores for each player
          const getNetScore = (pid) => {
            const gr = g.gross[pid] && g.gross[pid][hole];
            if (gr == null) return null;
            return Game.net(gr, Game.strokes(g, pid, hole));
          };

          const aNets = A.map(pid => ({ name: UI.playerName(pid), net: getNetScore(pid) }));
          const bNets = B.map(pid => ({ name: UI.playerName(pid), net: getNetScore(pid) }));

          // Check if all scores are in
          const allScored = aNets.every(p => p.net !== null) && bNets.every(p => p.net !== null);
          if (!allScored) {
            rows.push(h('div',{style:'padding:6px 0;border-bottom:1px solid var(--border);color:var(--muted);font-size:12px;'},
              `Hole ${hole+1}: Incomplete`));
            continue;
          }

          // Calculate high/low results for this hole
          const aLow = Math.min(...aNets.map(p => p.net));
          const aHi = Math.max(...aNets.map(p => p.net));
          const bLow = Math.min(...bNets.map(p => p.net));
          const bHi = Math.max(...bNets.map(p => p.net));

          const lowWinner = aLow < bLow ? 'A' : bLow < aLow ? 'B' : 'T';
          const hiWinner = aHi < bHi ? 'A' : bHi < aHi ? 'B' : 'T';

          let holeDiff = 0;
          if (aLow < bLow) holeDiff++; else if (bLow < aLow) holeDiff--;
          if (aHi < bHi) holeDiff++; else if (bHi < aHi) holeDiff--;

          // Calculate cumulative for each bet line and check for new presses
          const lineStatuses = [];
          betLines.forEach((line, li) => {
            if (line.start > hole) return; // Press hasn't started yet

            // Calculate cumulative from line start to current hole
            let cum = 0;
            for (let h = line.start; h <= hole; h++) {
              const d = diffs[h - startHole];
              if (d != null) cum += d;
            }

            lineStatuses.push(cum > 0 ? `+${cum}` : cum === 0 ? 'E' : String(cum));

            // Check if new press should be triggered (auto-press logic)
            if (autoPress && hole < endHole) {
              const pressLevel = Math.floor(Math.abs(cum) / 2);
              if (pressLevel > line.pressesTriggered) {
                // Add new press starting next hole if not already there
                const nextHole = hole + 1;
                if (!betLines.some(l => l.start === nextHole)) {
                  betLines.push({ start: nextHole, pressesTriggered: 0 });
                }
                line.pressesTriggered = pressLevel;
              }
            }
          });

          const betStatusTxt = lineStatuses.join('/');
          const statusClass = lineStatuses[0]?.startsWith('+') ? 'points-positive' : lineStatuses[0]?.startsWith('-') ? 'points-negative' : '';

          const aNetsTxt = aNets.map(p => `${p.name.split(' ')[0]}: ${p.net}`).join(' / ');
          const bNetsTxt = bNets.map(p => `${p.name.split(' ')[0]}: ${p.net}`).join(' / ');

          const resultTxt = `Low: ${lowWinner} | Hi: ${hiWinner}`;

          rows.push(h('div',{style:'padding:8px 0;border-bottom:1px solid var(--border);font-size:12px;'},[
            h('div',{style:'display:flex;justify-content:space-between;align-items:center;'},[
              h('span',{style:'font-weight:600;'},`#${hole+1}`),
              h('span',{class:statusClass,style:'font-weight:600;'},betStatusTxt)
            ]),
            h('div',{style:'margin-top:4px;color:var(--muted);'},[
              h('div',{},`A Net: ${aNetsTxt}`),
              h('div',{},`B Net: ${bNetsTxt}`),
              h('div',{style:'margin-top:2px;'},resultTxt + ` | Hole: ${fmtPts(holeDiff)}`)
            ])
          ]));
        }

        // Final cumulative for the segment
        let finalCum = 0;
        for (let h = 0; h < diffs.length; h++) {
          if (diffs[h] != null) finalCum += diffs[h];
        }

        return { rows, cumulative: finalCum };
      };

      const front = buildNassauHoleRows(0, 8, g.autoPress.front);
      const back = buildNassauHoleRows(9, 17, g.autoPress.back);

      const fmtTP = (tot, sz) => {
        const s = Math.max(1, sz||1);
        return `${Utils.fmt(tot)} / ${Utils.fmt(tot/s)}`;
      };

      const aN = teamANames.join(' & ');
      const bN = teamBNames.join(' & ');

      return h('div',{class:theme},[
        h('div',{class:'card'},[
          h('div',{class:'row',style:'align-items:center;justify-content:space-between;'},[
            h('div',{class:'pill'},this.gameLabel(g)),
            h('div',{class:'note'},'Positive = Team A')
          ]),
          h('div',{class:'note'},`A: ${aN||'‚Äî'}  |  B: ${bN||'‚Äî'}`),

          // Front 9 details
          h('div',{style:'margin-top:12px;'},[
            h('div',{style:'font-weight:600;margin-bottom:8px;display:flex;justify-content:space-between;'},[
              h('span',{},'Front 9'),
              h('span',{class:front.cumulative>0?'points-positive':front.cumulative<0?'points-negative':''},
                `${fmtPts(front.cumulative)} (${Utils.fmt(res.segments.front.payA)})`)
            ]),
            ...front.rows
          ]),

          // Back 9 details
          h('div',{style:'margin-top:16px;'},[
            h('div',{style:'font-weight:600;margin-bottom:8px;display:flex;justify-content:space-between;'},[
              h('span',{},'Back 9'),
              h('span',{class:back.cumulative>0?'points-positive':back.cumulative<0?'points-negative':''},
                `${fmtPts(back.cumulative)} (${Utils.fmt(res.segments.back.payA)})`)
            ]),
            ...back.rows
          ]),

          // Overall summary
          h('div',{class:'card',style:'margin-top:12px;'},[
            h('div',{style:'font-weight:600;margin-bottom:4px;'},'Overall (1-18)'),
            h('div',{class:'muted'},`Result: ${res.segments.overall.winners.join(' / ')} = ${Utils.fmt(res.segments.overall.payA)}`)
          ]),

          // Junk
          h('div',{class:'card',style:'margin-top:8px;'},[h('div',{class:'pill'},`Junk to Team A: ${fmtTP(res.teamTotals.junk,(g.teamA||[]).length)}`)]),

          // Total
          h('div',{class:'card',style:'margin-top:8px;background:linear-gradient(135deg,rgba(59,130,246,0.05),rgba(22,163,74,0.05));'},[
            h('div',{class:'row',style:'justify-content:space-between;align-items:center;'},[
              h('div',{},[
                h('div',{style:'font-weight:600;'},'GAME TOTAL TO TEAM A'),
                h('div',{class:'muted',style:'font-size:12px;margin-top:2px;'},Utils.fmt(res.teamTotals.total/((g.teamA||[]).length||1))+' per player')
              ]),
              h('div',{style:'font-size:20px;font-weight:700;',class:res.teamTotals.total>0?'points-positive':'points-negative'},
                Utils.fmt(res.teamTotals.total))
            ])
          ])
        ])
      ]);
    });

    return h('div',{},blocks);
  },

  transactions() {
    const shareBtn = h('div',{style:'margin-bottom:12px;'},[
      h('button',{class:'btn small share',onclick:()=>this.share()},'Share Results')
    ]);

    const net = {};
    State.data.players.forEach(p => net[p.id] = 0);

    const perGameRows = State.data.games.map(g => {
      // Skip if no scores
      if (!Game.hasAnyScores(g)) {
        return h('li',{class:'muted'},`${this.gameLabel(g)}: No scores yet`);
      }

      if (g.gameType === 'skins') {
        const res = Game.computeSkinsResult(g);
        const players = g.skinsPlayers || [];
        players.forEach(pid => {
          const pr = res.playerResults[pid];
          if (pr) net[pid] += pr.profit;
        });
        // Find biggest winner for display
        let best = null, bestProfit = -Infinity;
        players.forEach(pid => {
          const pr = res.playerResults[pid];
          if (pr && pr.profit > bestProfit) { best = pid; bestProfit = pr.profit; }
        });
        return h('li',{},`${this.gameLabel(g)}: ${best ? UI.playerName(best) + ' +' + Utils.fmt(bestProfit) : 'No winner yet'}`);
      }

      if (g.gameType === 'wolf') {
        const res = Game.computeWolfResult(g);
        const players = g.wolfPlayers || [];
        // Add wolf net $ to player totals (pay-up-the-ladder)
        players.forEach(pid => {
          net[pid] += res.playerNet[pid] || 0;
        });
        // Calculate junk for Wolf - pay up the ladder
        const sumJunk = (pid, start, end) => {
          let tot = 0;
          const arr = g.junkCounts[pid] || [];
          for (let h = start; h <= end; h++) tot += (arr[h]||0);
          return tot;
        };
        // Get each player's junk value
        const junkStandings = players.map(pid => {
          const frontJunk = sumJunk(pid, 0, 8);
          const backJunk = sumJunk(pid, 9, 17);
          const junkVal = frontJunk * (g.junkValue.front||0) + backJunk * (g.junkValue.back||0);
          return { pid, junkVal };
        }).sort((a, b) => b.junkVal - a.junkVal);
        // Pay up the ladder for junk
        for (let i = 0; i < junkStandings.length; i++) {
          for (let j = i + 1; j < junkStandings.length; j++) {
            const diff = junkStandings[i].junkVal - junkStandings[j].junkVal;
            if (diff > 0) {
              net[junkStandings[i].pid] += diff;
              net[junkStandings[j].pid] -= diff;
            }
          }
        }
        // Find biggest winner for display (including junk)
        let best = null, bestAmt = -Infinity;
        players.forEach(pid => {
          if (net[pid] > bestAmt) { best = pid; bestAmt = net[pid]; }
        });
        return h('li',{},`${this.gameLabel(g)}: ${best && bestAmt > 0 ? UI.playerName(best) + ' +' + Utils.fmt(bestAmt) : 'No winner yet'}`);
      }

      if (g.gameType === 'ninepoint') {
        const res = Game.computeNinePointResult(g);
        const players = g.ninePointPlayers || [];
        // Add 9-Point net $ to player totals (pay-up-the-ladder)
        players.forEach(pid => {
          net[pid] += res.playerNet[pid] || 0;
        });
        // Calculate junk for 9-Point - pay up the ladder
        const sumJunk = (pid, start, end) => {
          let tot = 0;
          const arr = g.junkCounts[pid] || [];
          for (let h = start; h <= end; h++) tot += (arr[h]||0);
          return tot;
        };
        // Get each player's junk value
        const junkStandings = players.map(pid => {
          const frontJunk = sumJunk(pid, 0, 8);
          const backJunk = sumJunk(pid, 9, 17);
          const junkVal = frontJunk * (g.junkValue.front||0) + backJunk * (g.junkValue.back||0);
          return { pid, junkVal };
        }).sort((a, b) => b.junkVal - a.junkVal);
        // Pay up the ladder for junk
        for (let i = 0; i < junkStandings.length; i++) {
          for (let j = i + 1; j < junkStandings.length; j++) {
            const diff = junkStandings[i].junkVal - junkStandings[j].junkVal;
            if (diff > 0) {
              net[junkStandings[i].pid] += diff;
              net[junkStandings[j].pid] -= diff;
            }
          }
        }
        // Find biggest winner for display (including junk)
        let best = null, bestAmt = -Infinity;
        players.forEach(pid => {
          if (net[pid] > bestAmt) { best = pid; bestAmt = net[pid]; }
        });
        return h('li',{},`${this.gameLabel(g)}: ${best && bestAmt > 0 ? UI.playerName(best) + ' +' + Utils.fmt(bestAmt) : 'No winner yet'}`);
      }

      let tot;
      if (g.gameType === 'vegas') {
        const res = Game.computeVegasResult(g);
        tot = res.totalValue;
      } else {
        const res = Game.computeResult(g);
        tot = res.teamTotals.total;
      }
      const szA = (g.teamA||[]).length || 1;
      const szB = (g.teamB||[]).length || 1;
      const aShare = szA ? tot/szA : 0;
      const bShare = szB ? -tot/szB : 0;
      (g.teamA||[]).forEach(id => net[id] += aShare);
      (g.teamB||[]).forEach(id => net[id] += bShare);
      return h('li',{},`${this.gameLabel(g)}: ${Utils.fmt(tot)} to Team A`);
    });

    const perPlayerRows = State.data.players.map(p => 
      h('li',{},`${p.name}: ${Utils.fmt(net[p.id])}`)
    );

    const xfers = this.calcTransfers(net);
    const xferRows = xfers.map(x => 
      h('li',{},`${UI.playerName(x.from)} ‚Üí ${UI.playerName(x.to)}: ${Utils.fmt(x.amount)}`)
    );

    const themed = State.data.games.map((g,idx) => {
      const theme = `theme-g${(idx%6)+1}`;
      return h('div',{class:theme},[h('div',{class:'card'},[h('div',{class:'pill'},this.gameLabel(g))])]);
    });

    return h('div',{},[
      shareBtn,
      h('div',{class:'card'},[
        h('div',{class:'pill'},'Per-Game Totals (to Team A)'),
        perGameRows.length ? h('ul',{},perGameRows) : h('div',{class:'muted'},'No games yet.')
      ]),
      h('div',{class:'card'},[
        h('div',{class:'pill'},'Per-Player Net (All Games + Junk)'),
        h('ul',{},perPlayerRows)
      ]),
      h('div',{class:'card'},[
        h('div',{class:'pill'},'Least-Cash Transfers'),
        xfers.length ? h('ul',{},xferRows) : h('div',{class:'muted'},'All square.')
      ]),
      h('div',{},themed)
    ]);
  },

  rules() {
    return h('div',{style:'max-width:800px;margin:0 auto;'},[
      h('div',{class:'card',style:'margin-bottom:16px;'},[
        h('h2',{style:'margin:0 0 12px 0;'},'Nassau'),
        h('p',{},'Traditional Nassau is three separate bets: Front 9, Back 9, and Overall 18.'),
        h('h3',{style:'margin:16px 0 8px 0;'},'Scoring'),
        h('ul',{style:'margin:8px 0;padding-left:20px;'},[
          h('li',{},'Hi/Low: Each team\'s best and worst net scores combine'),
          h('li',{},'Best Ball: Each team\'s best net score counts')
        ]),
        h('h3',{style:'margin:16px 0 8px 0;'},'Auto-Press'),
        h('p',{},'When a team falls 2-down in a bet, a new "press" bet automatically starts for the remaining holes at the same stake.'),
        h('h3',{style:'margin:16px 0 8px 0;'},'Junk'),
        h('p',{},'Optional side bets for: Birdies, Sandies (sand save par+), Greenies (closest on par 3), etc. Each junk point has a $ value.')
      ]),
      
      h('div',{class:'card',style:'margin-bottom:16px;'},[
        h('h2',{style:'margin:0 0 12px 0;'},'Vegas'),
        h('p',{},'Two-digit scoring game where each team forms a number from their two net scores.'),
        h('h3',{style:'margin:16px 0 8px 0;'},'How Numbers Form'),
        h('ul',{style:'margin:8px 0;padding-left:20px;'},[
          h('li',{},'Normal: Low score = tens digit, High score = ones digit'),
          h('li',{},'Example: Team scores 4 and 5 ‚Üí Number is 45')
        ]),
        h('h3',{style:'margin:16px 0 8px 0;'},'Reversal (The Flip)'),
        h('p',{},'Numbers reverse (high becomes tens digit) when:'),
        h('ul',{style:'margin:8px 0;padding-left:20px;'},[
          h('li',{},'Any opponent makes gross birdie, OR'),
          h('li',{},'Any teammate makes net bogey or worse')
        ]),
        h('p',{},'Example: Team scores 4 and 5, but flips ‚Üí Number is 54'),
        h('h3',{style:'margin:16px 0 8px 0;'},'Scoring'),
        h('ul',{style:'margin:8px 0;padding-left:20px;'},[
          h('li',{},'Lower number wins the difference in points'),
          h('li',{},'Example: 45 vs 56 ‚Üí Lower team wins 11 points'),
          h('li',{},'Points convert to dollars using $/point values for Front and Back 9')
        ]),
        h('h3',{style:'margin:16px 0 8px 0;'},'Presses'),
        h('p',{},'Set per hole to multiply points:'),
        h('ul',{style:'margin:8px 0;padding-left:20px;'},[
          h('li',{},'Blank (‚Äî): 1x multiplier'),
          h('li',{},'Press (P): 2x multiplier'),
          h('li',{},'Blind (B): 4x multiplier')
        ]),
        h('h3',{style:'margin:16px 0 8px 0;'},'Junk'),
        h('p',{},'Same as Nassau - optional side bets with $ values.')
      ]),

      h('div',{class:'card',style:'margin-bottom:16px;'},[
        h('h2',{style:'margin:0 0 12px 0;'},'Skins'),
        h('p',{},'Individual game for 2-5 players. Each hole is worth a "skin" - win the hole outright to claim it.'),
        h('h3',{style:'margin:16px 0 8px 0;'},'Carryovers'),
        h('p',{},'If two or more players tie for lowest score on a hole, the skin carries over to the next hole. Carryovers accumulate until someone wins outright.'),
        h('h3',{style:'margin:16px 0 8px 0;'},'Modes'),
        h('ul',{style:'margin:8px 0;padding-left:20px;'},[
          h('li',{},h('strong',{},'Net:'),' Handicap strokes apply - lowest net score wins'),
          h('li',{},h('strong',{},'Gross:'),' Raw scores only - lowest gross score wins'),
          h('li',{},h('strong',{},'Net + Gross:'),' Two separate pots - can win both on same hole')
        ]),
        h('h3',{style:'margin:16px 0 8px 0;'},'Payout'),
        h('p',{},'Total pot (buy-in √ó players) divided by number of skins won. For Net+Gross, each pot is calculated separately.'),
        h('h3',{style:'margin:16px 0 8px 0;'},'Final Hole Ties'),
        h('p',{},'If the last hole ties with carryovers pending, the pot splits evenly among all tied players.')
      ]),

      h('div',{class:'card',style:'margin-bottom:16px;'},[
        h('h2',{style:'margin:0 0 12px 0;'},'Wolf'),
        h('p',{},'Game for 4-5 players where one player (the Wolf) chooses their partner each hole.'),
        h('h3',{style:'margin:16px 0 8px 0;'},'Tee Order'),
        h('p',{},'Players rotate who tees off first (the Wolf). Set the tee order in game setup, then it rotates each hole.'),
        h('h3',{style:'margin:16px 0 8px 0;'},'Wolf\'s Choices'),
        h('ul',{style:'margin:8px 0;padding-left:20px;'},[
          h('li',{},h('strong',{},'Pick a Partner:'),' Select someone to team up with (2v2 or 2v3). Normal 1x points.'),
          h('li',{},h('strong',{},'Wolf (W):'),' Go alone after seeing all tee shots (1v3 or 1v4). Worth 2x points.'),
          h('li',{},h('strong',{},'Blind Wolf (BW):'),' Declare before teeing off. Worth 4x points.')
        ]),
        h('h3',{style:'margin:16px 0 8px 0;'},'Scoring'),
        h('p',{},'Best ball (lowest net score) wins the hole. Winners earn points, losers pay. Everyone settles up at the end.'),
        h('h3',{style:'margin:16px 0 8px 0;'},'Carryovers'),
        h('p',{},'If the hole ties, points carry over to the next hole. Multipliers stack on tied holes.'),
        h('h3',{style:'margin:16px 0 8px 0;'},'Catch-up'),
        h('p',{},'On the final holes (17-18 for 4 players, 16-18 for 5 players), the player with the lowest dollars becomes Wolf - giving them a chance to catch up.')
      ]),

      h('div',{class:'card',style:'margin-bottom:16px;'},[
        h('h2',{style:'margin:0 0 12px 0;'},'9-Point'),
        h('p',{},'Classic 3-player game where 9 points are distributed each hole based on finishing order.'),
        h('h3',{style:'margin:16px 0 8px 0;'},'Point Distribution'),
        h('ul',{style:'margin:8px 0;padding-left:20px;'},[
          h('li',{},h('strong',{},'All Different:'),' Best = 5 pts, Middle = 3 pts, Worst = 1 pt'),
          h('li',{},h('strong',{},'Two Tied for Best:'),' Both get 4 pts, Worst = 1 pt'),
          h('li',{},h('strong',{},'Two Tied for Worst:'),' Best = 5 pts, Both tied = 2 pts each'),
          h('li',{},h('strong',{},'Three-Way Tie:'),' All get 3 pts each')
        ]),
        h('h3',{style:'margin:16px 0 8px 0;'},'Modes'),
        h('ul',{style:'margin:8px 0;padding-left:20px;'},[
          h('li',{},h('strong',{},'Net:'),' Handicap strokes apply'),
          h('li',{},h('strong',{},'Gross:'),' Raw scores only')
        ]),
        h('h3',{style:'margin:16px 0 8px 0;'},'Optional Rules'),
        h('ul',{style:'margin:8px 0;padding-left:20px;'},[
          h('li',{},h('strong',{},'Win by 2:'),' Outright winner by 2+ strokes gets all 9 points (9/0/0)'),
          h('li',{},h('strong',{},'Birdie Doubles:'),' If winner makes birdie, points double (18/0/0 for win by 2, 10/6/2 normally)')
        ]),
        h('h3',{style:'margin:16px 0 8px 0;'},'Payout'),
        h('p',{},'Set a point value (e.g., $1/pt). Settlement is pay-up-the-ladder: highest earner collects from each other player.')
      ]),

      h('div',{class:'card'},[
        h('h2',{style:'margin:0 0 12px 0;'},'App Tips'),
        h('ul',{style:'margin:8px 0;padding-left:20px;'},[
          h('li',{},'Use SETUP to configure games and player handicaps'),
          h('li',{},'Enter gross scores in SCORES tab'),
          h('li',{},'Track junk in JUNK tab'),
          h('li',{},'STATUS shows live standings as you play'),
          h('li',{},'GAME shows final breakdown when complete'),
          h('li',{},'PAYMENTS calculates who owes what')
        ])
      ])
    ]);
  },

  calcTransfers(net) {
    const debt = [], cred = [];
    Object.entries(net).forEach(([id, amt]) => {
      if (Math.abs(amt) < 0.005) return;
      if (amt < 0) debt.push({id, amount:-amt});
      else cred.push({id, amount:amt});
    });
    debt.sort((a,b) => b.amount - a.amount);
    cred.sort((a,b) => b.amount - a.amount);

    const xfers = [];
    let i = 0, j = 0;
    while (i < debt.length && j < cred.length) {
      const d = debt[i], c = cred[j];
      const pay = Math.min(d.amount, c.amount);
      xfers.push({from:d.id, to:c.id, amount:pay});
      d.amount -= pay;
      c.amount -= pay;
      if (d.amount <= 0.005) i++;
      if (c.amount <= 0.005) j++;
    }
    return xfers;
  },

  showRoundCompleteModal() {
    // Build quick summary
    const net = {};
    State.data.players.forEach(p => net[p.id] = 0);
    State.data.games.forEach(g => {
      let tot;
      if (g.gameType === 'vegas') {
        const res = Game.computeVegasResult(g);
        tot = res.totalValue;
      } else {
        const res = Game.computeResult(g);
        tot = res.teamTotals.total;
      }
      const szA = (g.teamA||[]).length || 1;
      const szB = (g.teamB||[]).length || 1;
      const aShare = szA ? tot/szA : 0;
      const bShare = szB ? -tot/szB : 0;
      (g.teamA||[]).forEach(id => net[id] += aShare);
      (g.teamB||[]).forEach(id => net[id] += bShare);
    });

    const xfers = this.calcTransfers(net);
    let transfersHtml = '<p class="muted">All square!</p>';
    if (xfers.length) {
      transfersHtml = '<ul style="margin:0;padding-left:20px;">' +
        xfers.map(x => `<li>${this.playerName(x.from)} ‚Üí ${this.playerName(x.to)}: ${Utils.fmt(x.amount)}</li>`).join('') +
        '</ul>';
    }

    const overlay = document.createElement('div');
    overlay.className = 'modal-overlay';
    overlay.innerHTML = `
      <div class="modal" style="max-width:340px;">
        <h2 style="text-align:center;margin-bottom:8px;">Round Complete!</h2>
        <p class="muted" style="text-align:center;margin-bottom:16px;">Great round! Here's the settlement:</p>
        <div style="background:var(--card);border-radius:8px;padding:12px;margin-bottom:16px;">
          <div style="font-weight:600;margin-bottom:8px;">Payments:</div>
          ${transfersHtml}
        </div>
        <div class="modal-actions" style="flex-direction:column;gap:8px;">
          <button class="btn primary" id="shareResultsBtn" style="width:100%;">Share Results</button>
          <button class="btn" id="viewPaymentsBtn" style="width:100%;">View Full Details</button>
          <button class="btn secondary" id="dismissCompleteBtn" style="width:100%;">Dismiss</button>
        </div>
      </div>
    `;
    document.body.appendChild(overlay);

    document.getElementById('shareResultsBtn').onclick = () => {
      overlay.remove();
      this.share();
    };
    document.getElementById('viewPaymentsBtn').onclick = () => {
      overlay.remove();
      State.data.tab = 'transactions';
      State.scheduleRender();
    };
    document.getElementById('dismissCompleteBtn').onclick = () => overlay.remove();
    overlay.onclick = (e) => { if (e.target === overlay) overlay.remove(); };
  },

  share() {
    try {
      const lines = ['Round Summary from Bunch Bets:',''];
      lines.push('Player Scores:');
      State.data.players.forEach(p => {
        const g = State.data.games[0];
        const arr = g.gross[p.id] || [];
        const f = Utils.sumRange(arr,0,8);
        const b = Utils.sumRange(arr,9,17);
        const t = (f==null && b==null)?null:((f||0)+(b||0));
        lines.push(`  ${p.name}: ${f??'-'} / ${b??'-'} / ${t??'-'}`);
      });
      lines.push('');

      State.data.games.forEach(g => {
        if (g.gameType === 'vegas') {
          const res = Game.computeVegasResult(g);
          lines.push(this.gameLabel(g));
          lines.push(`  Front:   ${Utils.fmt(res.frontValue)}`);
          lines.push(`  Back:    ${Utils.fmt(res.backValue)}`);
          lines.push(`  Junk:    ${Utils.fmt(res.junkValue)}`);
          lines.push(`  Total:   ${Utils.fmt(res.totalValue)}`);
          lines.push('');
        } else {
          const res = Game.computeResult(g);
          lines.push(this.gameLabel(g));
          lines.push(`  Front:   ${Utils.fmt(res.teamTotals.front)}`);
          lines.push(`  Back:    ${Utils.fmt(res.teamTotals.back)}`);
          lines.push(`  Overall: ${Utils.fmt(res.teamTotals.overall)}`);
          lines.push(`  Junk:    ${Utils.fmt(res.teamTotals.junk)}`);
          lines.push(`  Total:   ${Utils.fmt(res.teamTotals.total)}`);
          lines.push('');
        }
      });

      const net = {};
      State.data.players.forEach(p => net[p.id] = 0);
      State.data.games.forEach(g => {
        let tot;
        if (g.gameType === 'vegas') {
          const res = Game.computeVegasResult(g);
          tot = res.totalValue;
        } else {
          const res = Game.computeResult(g);
          tot = res.teamTotals.total;
        }
        const szA = (g.teamA||[]).length || 1;
        const szB = (g.teamB||[]).length || 1;
        const aShare = szA ? tot/szA : 0;
        const bShare = szB ? -tot/szB : 0;
        (g.teamA||[]).forEach(id => net[id] += aShare);
        (g.teamB||[]).forEach(id => net[id] += bShare);
      });

      lines.push('Per-Player Net:');
      State.data.players.forEach(p => lines.push(`  ${p.name}: ${Utils.fmt(net[p.id])}`));

      const xfers = this.calcTransfers(net);
      if (xfers.length) {
        lines.push('');
        lines.push('Transfers:');
        xfers.forEach(x => lines.push(`  ${UI.playerName(x.from)} ‚Üí ${UI.playerName(x.to)} : ${Utils.fmt(x.amount)}`));
      }

      const txt = lines.join('\n');

      if (navigator.share) {
        navigator.share({text:txt}).catch(() => alert(txt));
      } else if (/Mobi|Android/i.test(navigator.userAgent)) {
        window.location.href = `sms:?&body=${encodeURIComponent(txt)}`;
      } else {
        alert(txt);
      }
    } catch(e) {
      Err.show('Share failed: ' + e.message);
    }
  },

  highlights() {
    const minInp = h('input',{
      type:'number',value:State.data.settings.thMin,style:'width:80px;padding:4px 6px;',
      oninput:(e)=>{State.data.settings.thMin=parseFloat(e.target.value)||0;State.scheduleRender();}
    });
    const topInp = h('input',{
      type:'number',value:State.data.settings.thTop,style:'width:64px;padding:4px 6px;',
      oninput:(e)=>{State.data.settings.thTop=Math.max(1,parseInt(e.target.value)||1);State.scheduleRender();}
    });

    const toolbar = h('div',{class:'row',style:'justify-content:space-between;align-items:center;'},[
      h('div',{class:'pill'},'Highlights (hole vs zero)'),
      h('div',{},[
        h('label',{},['Min $ ',minInp]),
        h('label',{style:'margin-left:8px;'},['Top ',topInp])
      ])
    ]);

    const all = this.buildHighlights()
      .filter(x => x.value >= State.data.settings.thMin)
      .slice(0, State.data.settings.thTop);

    const content = all.length 
      ? h('ul',{}, all.map(x => h('li',{}, x.text)))
      : h('div',{class:'muted',style:'padding:8px 0;'},'No highlights yet.');

    return h('div',{},[h('div',{class:'card'},[toolbar, content])]);
  },

  buildHighlights() {
    const equalizeHole = (g, hole) => {
      const g2 = Utils.clone(g);
      const ids = [...(g2.teamA||[]),...(g2.teamB||[])];
      ids.forEach(pid => {
        const s = Game.strokes(g2, pid, hole) || 0;
        if (!g2.gross[pid]) g2.gross[pid] = Utils.make18(null);
        g2.gross[pid][hole] = s + 100;
        if (!g2.junkCounts[pid]) g2.junkCounts[pid] = Utils.make18(0);
        g2.junkCounts[pid][hole] = 0;
      });
      return g2;
    };

    const aggTotal = (games) => {
      let tot = 0;
      games.forEach(g => {
        if (g.gameType === 'vegas') {
          tot += Game.computeVegasResult(g).totalValue;
        } else {
          tot += Game.computeResult(g).teamTotals.total;
        }
      });
      return tot;
    };

    const actual = aggTotal(State.data.games);
    const lines = [];

    for (let hole = 0; hole < 18; hole++) {
      const hasAny = State.data.games.some(g => {
        const ids = [...(g.teamA||[]),...(g.teamB||[])];
        return ids.some(pid => {
          const v = g.gross[pid] && g.gross[pid][hole];
          return v != null;
        });
      });
      if (!hasAny) continue;

      const neutral = State.data.games.map(g => equalizeHole(g, hole));
      const cf = aggTotal(neutral);
      const swing = actual - cf;
      if (swing === 0) continue;

      const contrib = State.data.games.map((g, idx) => {
        const a = Game.computeResult(g).teamTotals.total;
        const c = Game.computeResult(neutral[idx]).teamTotals.total;
        return {gi:idx, delta:a-c, game:g};
      });
      contrib.sort((a,b) => Math.abs(b.delta) - Math.abs(a.delta));
      const top = contrib[0];

      const getGameTotal = (game) => {
        if (game.gameType === 'vegas') {
          return Game.computeVegasResult(game).totalValue;
        } else {
          return Game.computeResult(game).teamTotals.total;
        }
      };

      const perPlayer = [...(top.game.teamA||[]),...(top.game.teamB||[])].map(pid => {
        const g2 = Utils.clone(top.game);
        const s = Game.strokes(g2, pid, hole) || 0;
        g2.gross[pid][hole] = s + 100;
        g2.junkCounts[pid][hole] = 0;
        const cfRes = getGameTotal(g2);
        const actRes = getGameTotal(top.game);
        return {pid, delta:actRes - cfRes};
      }).filter(pc => Math.abs(pc.delta) > 0.001);

      perPlayer.sort((a,b) => Math.abs(b.delta) - Math.abs(a.delta));

      const swingSign = swing > 0 ? 1 : -1;
      const sameDir = perPlayer.filter(pc => Math.sign(pc.delta) === swingSign);
      const rel = sameDir.length ? sameDir : perPlayer;
      if (!rel.length) continue;

      const maxD = Math.max(...rel.map(pc => Math.abs(pc.delta)));
      const tied = rel.filter(pc => Math.abs(Math.abs(pc.delta) - maxD) < 0.001);

      const labelFor = (pid) => {
        const parVal = State.data.course.par[hole];
        const gross = top.game.gross[pid] && top.game.gross[pid][hole];
        if (parVal == null || gross == null) return '';
        const d = gross - parVal;
        if (d <= -3) return 'albatross';
        if (d === -2) return 'eagle';
        if (d === -1) return 'birdie';
        if (d === 1) return 'bogey';
        if (d >= 2) return 'double bogey';
        return gross === parVal ? 'par' : '';
      };

      const pluralize = (s) => {
        if (s === 'par') return 'pars';
        if (s === 'birdie') return 'birdies';
        if (s === 'eagle') return 'eagles';
        if (s === 'bogey') return 'bogeys';
        if (s === 'double bogey') return 'double bogeys';
        if (s === 'albatross') return 'albatrosses';
        return s ? (s + 's') : s;
      };

      const names = tied.map(t => UI.playerName(t.pid));
      const labels = tied.map(t => labelFor(t.pid));

      let whoText;
      const allSame = labels.length && labels.every(l => l && l === labels[0]);
      if (labels.length === 1) {
        whoText = names[0] + (labels[0] ? (' ' + labels[0]) : '');
      } else if (allSame) {
        whoText = names.join(' & ') + (labels[0] ? ("'s " + pluralize(labels[0])) : '');
      } else {
        const parts = names.map((nm, i) => nm + (labels[i] ? (' ' + labels[i]) : ''));
        whoText = parts.join(' & ');
      }

      const toward = swing > 0 ? 'Team A' : 'Team B';
      lines.push({
        hole,
        value:Math.abs(swing),
        swing,
        text:`Hole ${hole+1}: ${whoText} swung ${Utils.fmt(Math.abs(swing))} toward ${toward}`
      });
    }

    lines.sort((a,b) => (b.value - a.value) || (b.hole - a.hole));
    return lines;
  }
};

// === INIT ===
if (!State.load() || !State.data.games.length) {
  State.data.games = [Game.create()];
  State.scheduleSave();
}

State.data.games = State.data.games.map(Game.sanitize);

document.getElementById('resetBtn').onclick = () => {
  UI.closeMenu();
  if (!confirm('Start a new round? Scores & junk cleared, teams/stakes reset. Custom courses kept.')) return;
  const keepCourse = Utils.clone(State.data.course);
  const keepPresets = Utils.clone(State.presets);
  State.data.games = [Game.create()];
  State.data.course = keepCourse;
  State.presets = keepPresets;
  State.data.roundCompleteShown = false;
  State.scheduleSave();
  State.scheduleRender();
  Err.toast('Round reset');
};

document.getElementById('clearBtn').onclick = () => {
  UI.closeMenu();
  if (!confirm('Clear all scores & junk? Teams/stakes/course stay the same.')) return;
  State.data.games.forEach(g => {
    State.data.players.forEach(p => {
      g.gross[p.id] = Utils.make18(null);
      g.junkCounts[p.id] = Utils.make18(0);
    });
  });
  State.scheduleSave();
  State.scheduleRender();
  Err.toast('Scores cleared');
};

document.getElementById('factoryBtn').onclick = () => {
  UI.closeMenu();
  if (!confirm('Factory reset? EVERYTHING erased: scores, teams, strokes, players, ALL presets!')) return;
  localStorage.removeItem(STORAGE_KEY);
  location.reload();
};

// Live sharing buttons
document.getElementById('hostBtn').onclick = () => { UI.closeMenu(); LiveSync.showHostModal(); };
document.getElementById('joinBtn').onclick = () => { UI.closeMenu(); LiveSync.showJoinModal(); };

// Wizard button
document.getElementById('startWizardBtn').onclick = () => {
  if (!confirm('Start a new game?\n\nThis will erase all scores and settings from the current game.')) return;
  UI.closeMenu();
  Wizard.start();
};

// Check URL for join code on load
let joiningViaUrl = false;
(function() {
  const params = new URLSearchParams(window.location.search);
  const joinCode = params.get('join');
  if (joinCode) {
    joiningViaUrl = true;
    // Remove code from URL to prevent re-joining on refresh
    window.history.replaceState({}, '', window.location.pathname);
    // Delay join to allow app to initialize
    setTimeout(() => LiveSync.joinGame(joinCode), 500);
  }
})();

// iOS detection
(function() {
  const ua = navigator.userAgent || '';
  const isIOS = /iPad|iPhone|iPod/.test(ua) || (ua.includes('Mac') && 'ontouchend' in document);
  if (isIOS) document.documentElement.classList.add('ios');
})();

UI.render();
UI.initMenu();

// Intelligent launch detection
(function() {
  const today = new Date().toDateString();
  const lastActive = State.data.lastActiveDate;

  // Check if there's an active game with scores
  const hasActiveGame = () => {
    // Check if any game has at least one score entered
    for (const g of State.data.games) {
      for (const pid of Object.keys(g.gross || {})) {
        const scores = g.gross[pid];
        if (scores && scores.some(s => s !== null)) return true;
      }
    }
    return false;
  };

  // If joining via URL, don't auto-launch wizard (joinGame will handle navigation)
  if (joiningViaUrl) return;

  // If it's a new day, show wizard for fresh start
  // If same day with active game, go to scores
  if (lastActive !== today) {
    // New day - show wizard
    Wizard.start();
  } else if (hasActiveGame()) {
    // Same day with active game - go to scores tab
    State.data.tab = 'live';
    State.scheduleRender();
    Err.toast('Welcome back');
  } else {
    // Same day but no active game - show wizard
    Wizard.start();
  }
})();

})();
</script>
</body>
</html>
